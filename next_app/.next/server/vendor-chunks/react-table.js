/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-table";
exports.ids = ["vendor-chunks/react-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-table/dist/react-table.development.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-table/dist/react-table.development.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function(global, factory) {\n     true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\")) : 0;\n})(this, function(exports1, React) {\n    \"use strict\";\n    React = React && Object.prototype.hasOwnProperty.call(React, \"default\") ? React[\"default\"] : React;\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self1 = this, args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self1, args);\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                }\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                }\n                _next(undefined);\n            });\n        };\n    }\n    function _extends() {\n        _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        return _extends.apply(this, arguments);\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n        for(i = 0; i < sourceKeys.length; i++){\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n        return target;\n    }\n    function _toPrimitive(input, hint) {\n        if (typeof input !== \"object\" || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || \"default\");\n            if (typeof res !== \"object\") return res;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (hint === \"string\" ? String : Number)(input);\n    }\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, \"string\");\n        return typeof key === \"symbol\" ? key : String(key);\n    }\n    var renderErr = \"Renderer Error ☝️\";\n    var actions = {\n        init: \"init\"\n    };\n    var defaultRenderer = function defaultRenderer(_ref) {\n        var _ref$value = _ref.value, value = _ref$value === void 0 ? \"\" : _ref$value;\n        return value;\n    };\n    var emptyRenderer = function emptyRenderer() {\n        return React.createElement(React.Fragment, null, \"\\xa0\");\n    };\n    var defaultColumn = {\n        Cell: defaultRenderer,\n        width: 150,\n        minWidth: 0,\n        maxWidth: Number.MAX_SAFE_INTEGER\n    };\n    function mergeProps() {\n        for(var _len = arguments.length, propList = new Array(_len), _key = 0; _key < _len; _key++){\n            propList[_key] = arguments[_key];\n        }\n        return propList.reduce(function(props, next) {\n            var style = next.style, className = next.className, rest = _objectWithoutPropertiesLoose(next, [\n                \"style\",\n                \"className\"\n            ]);\n            props = _extends({}, props, {}, rest);\n            if (style) {\n                props.style = props.style ? _extends({}, props.style || {}, {}, style || {}) : style;\n            }\n            if (className) {\n                props.className = props.className ? props.className + \" \" + className : className;\n            }\n            if (props.className === \"\") {\n                delete props.className;\n            }\n            return props;\n        }, {});\n    }\n    function handlePropGetter(prevProps, userProps, meta) {\n        // Handle a lambda, pass it the previous props\n        if (typeof userProps === \"function\") {\n            return handlePropGetter({}, userProps(prevProps, meta));\n        } // Handle an array, merge each item as separate props\n        if (Array.isArray(userProps)) {\n            return mergeProps.apply(void 0, [\n                prevProps\n            ].concat(userProps));\n        } // Handle an object by default, merge the two objects\n        return mergeProps(prevProps, userProps);\n    }\n    var makePropGetter = function makePropGetter(hooks, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return function(userProps) {\n            if (userProps === void 0) {\n                userProps = {};\n            }\n            return [].concat(hooks, [\n                userProps\n            ]).reduce(function(prev, next) {\n                return handlePropGetter(prev, next, _extends({}, meta, {\n                    userProps: userProps\n                }));\n            }, {});\n        };\n    };\n    var reduceHooks = function reduceHooks(hooks, initial, meta, allowUndefined) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return hooks.reduce(function(prev, next) {\n            var nextValue = next(prev, meta);\n            {\n                if (!allowUndefined && typeof nextValue === \"undefined\") {\n                    console.info(next);\n                    throw new Error(\"React Table: A reducer hook ☝️ just returned undefined! This is not allowed.\");\n                }\n            }\n            return nextValue;\n        }, initial);\n    };\n    var loopHooks = function loopHooks(hooks, context, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return hooks.forEach(function(hook) {\n            var nextValue = hook(context, meta);\n            {\n                if (typeof nextValue !== \"undefined\") {\n                    console.info(hook, nextValue);\n                    throw new Error(\"React Table: A loop-type hook ☝️ just returned a value! This is not allowed.\");\n                }\n            }\n        });\n    };\n    function ensurePluginOrder(plugins, befores, pluginName, afters) {\n        if (afters) {\n            throw new Error('Defining plugins in the \"after\" section of ensurePluginOrder is no longer supported (see plugin ' + pluginName + \")\");\n        }\n        var pluginIndex = plugins.findIndex(function(plugin) {\n            return plugin.pluginName === pluginName;\n        });\n        if (pluginIndex === -1) {\n            {\n                throw new Error('The plugin \"' + pluginName + \"\\\" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \" + pluginName + \".pluginName = '\" + pluginName + \"'\\n\");\n            }\n        }\n        befores.forEach(function(before) {\n            var beforeIndex = plugins.findIndex(function(plugin) {\n                return plugin.pluginName === before;\n            });\n            if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n                {\n                    throw new Error(\"React Table: The \" + pluginName + \" plugin hook must be placed after the \" + before + \" plugin hook!\");\n                }\n            }\n        });\n    }\n    function functionalUpdate(updater, old) {\n        return typeof updater === \"function\" ? updater(old) : updater;\n    }\n    function useGetLatest(obj) {\n        var ref = React.useRef();\n        ref.current = obj;\n        return React.useCallback(function() {\n            return ref.current;\n        }, []);\n    } // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n    var safeUseLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n    function useMountedLayoutEffect(fn, deps) {\n        var mountedRef = React.useRef(false);\n        safeUseLayoutEffect(function() {\n            if (mountedRef.current) {\n                fn();\n            }\n            mountedRef.current = true; // eslint-disable-next-line\n        }, deps);\n    }\n    function useAsyncDebounce(defaultFn, defaultWait) {\n        if (defaultWait === void 0) {\n            defaultWait = 0;\n        }\n        var debounceRef = React.useRef({});\n        var getDefaultFn = useGetLatest(defaultFn);\n        var getDefaultWait = useGetLatest(defaultWait);\n        return React.useCallback(/*#__PURE__*/ function() {\n            var _ref2 = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {\n                var _len2, args, _key2, _args2 = arguments;\n                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while(1){\n                        switch(_context2.prev = _context2.next){\n                            case 0:\n                                for(_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                                    args[_key2] = _args2[_key2];\n                                }\n                                if (!debounceRef.current.promise) {\n                                    debounceRef.current.promise = new Promise(function(resolve, reject) {\n                                        debounceRef.current.resolve = resolve;\n                                        debounceRef.current.reject = reject;\n                                    });\n                                }\n                                if (debounceRef.current.timeout) {\n                                    clearTimeout(debounceRef.current.timeout);\n                                }\n                                debounceRef.current.timeout = setTimeout(/*#__PURE__*/ _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n                                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                                        while(1){\n                                            switch(_context.prev = _context.next){\n                                                case 0:\n                                                    delete debounceRef.current.timeout;\n                                                    _context.prev = 1;\n                                                    _context.t0 = debounceRef.current;\n                                                    _context.next = 5;\n                                                    return getDefaultFn().apply(void 0, args);\n                                                case 5:\n                                                    _context.t1 = _context.sent;\n                                                    _context.t0.resolve.call(_context.t0, _context.t1);\n                                                    _context.next = 12;\n                                                    break;\n                                                case 9:\n                                                    _context.prev = 9;\n                                                    _context.t2 = _context[\"catch\"](1);\n                                                    debounceRef.current.reject(_context.t2);\n                                                case 12:\n                                                    _context.prev = 12;\n                                                    delete debounceRef.current.promise;\n                                                    return _context.finish(12);\n                                                case 15:\n                                                case \"end\":\n                                                    return _context.stop();\n                                            }\n                                        }\n                                    }, _callee, null, [\n                                        [\n                                            1,\n                                            9,\n                                            12,\n                                            15\n                                        ]\n                                    ]);\n                                })), getDefaultWait());\n                                return _context2.abrupt(\"return\", debounceRef.current.promise);\n                            case 5:\n                            case \"end\":\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2);\n            }));\n            return function() {\n                return _ref2.apply(this, arguments);\n            };\n        }(), [\n            getDefaultFn,\n            getDefaultWait\n        ]);\n    }\n    function makeRenderer(instance, column, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return function(type, userProps) {\n            if (userProps === void 0) {\n                userProps = {};\n            }\n            var Comp = typeof type === \"string\" ? column[type] : type;\n            if (typeof Comp === \"undefined\") {\n                console.info(column);\n                throw new Error(renderErr);\n            }\n            return flexRender(Comp, _extends({}, instance, {\n                column: column\n            }, meta, {}, userProps));\n        };\n    }\n    function flexRender(Comp, props) {\n        return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n    }\n    function isReactComponent(component) {\n        return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n    }\n    function isClassComponent(component) {\n        return typeof component === \"function\" && function() {\n            var proto = Object.getPrototypeOf(component);\n            return proto.prototype && proto.prototype.isReactComponent;\n        }();\n    }\n    function isExoticComponent(component) {\n        return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n            \"react.memo\",\n            \"react.forward_ref\"\n        ].includes(component.$$typeof.description);\n    }\n    function linkColumnStructure(columns, parent, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        return columns.map(function(column) {\n            column = _extends({}, column, {\n                parent: parent,\n                depth: depth\n            });\n            assignColumnAccessor(column);\n            if (column.columns) {\n                column.columns = linkColumnStructure(column.columns, column, depth + 1);\n            }\n            return column;\n        });\n    }\n    function flattenColumns(columns) {\n        return flattenBy(columns, \"columns\");\n    }\n    function assignColumnAccessor(column) {\n        // First check for string accessor\n        var id = column.id, accessor = column.accessor, Header = column.Header;\n        if (typeof accessor === \"string\") {\n            id = id || accessor;\n            var accessorPath = accessor.split(\".\");\n            accessor = function accessor(row) {\n                return getBy(row, accessorPath);\n            };\n        }\n        if (!id && typeof Header === \"string\" && Header) {\n            id = Header;\n        }\n        if (!id && column.columns) {\n            console.error(column);\n            throw new Error('A column ID (or unique \"Header\" value) is required!');\n        }\n        if (!id) {\n            console.error(column);\n            throw new Error(\"A column ID (or string accessor) is required!\");\n        }\n        Object.assign(column, {\n            id: id,\n            accessor: accessor\n        });\n        return column;\n    }\n    function decorateColumn(column, userDefaultColumn) {\n        if (!userDefaultColumn) {\n            throw new Error();\n        }\n        Object.assign(column, _extends({\n            // Make sure there is a fallback header, just in case\n            Header: emptyRenderer,\n            Footer: emptyRenderer\n        }, defaultColumn, {}, userDefaultColumn, {}, column));\n        Object.assign(column, {\n            originalWidth: column.width\n        });\n        return column;\n    } // Build the header groups from the bottom up\n    function makeHeaderGroups(allColumns, defaultColumn, additionalHeaderProperties) {\n        if (additionalHeaderProperties === void 0) {\n            additionalHeaderProperties = function additionalHeaderProperties() {\n                return {};\n            };\n        }\n        var headerGroups = [];\n        var scanColumns = allColumns;\n        var uid = 0;\n        var getUID = function getUID() {\n            return uid++;\n        };\n        var _loop = function _loop() {\n            // The header group we are creating\n            var headerGroup = {\n                headers: []\n            }; // The parent columns we're going to scan next\n            var parentColumns = [];\n            var hasParents = scanColumns.some(function(d) {\n                return d.parent;\n            }); // Scan each column for parents\n            scanColumns.forEach(function(column) {\n                // What is the latest (last) parent column?\n                var latestParentColumn = [].concat(parentColumns).reverse()[0];\n                var newParent;\n                if (hasParents) {\n                    // If the column has a parent, add it if necessary\n                    if (column.parent) {\n                        newParent = _extends({}, column.parent, {\n                            originalId: column.parent.id,\n                            id: column.parent.id + \"_\" + getUID(),\n                            headers: [\n                                column\n                            ]\n                        }, additionalHeaderProperties(column));\n                    } else {\n                        // If other columns have parents, we'll need to add a place holder if necessary\n                        var originalId = column.id + \"_placeholder\";\n                        newParent = decorateColumn(_extends({\n                            originalId: originalId,\n                            id: column.id + \"_placeholder_\" + getUID(),\n                            placeholderOf: column,\n                            headers: [\n                                column\n                            ]\n                        }, additionalHeaderProperties(column)), defaultColumn);\n                    } // If the resulting parent columns are the same, just add\n                    // the column and increment the header span\n                    if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {\n                        latestParentColumn.headers.push(column);\n                    } else {\n                        parentColumns.push(newParent);\n                    }\n                }\n                headerGroup.headers.push(column);\n            });\n            headerGroups.push(headerGroup); // Start scanning the parent columns\n            scanColumns = parentColumns;\n        };\n        while(scanColumns.length){\n            _loop();\n        }\n        return headerGroups.reverse();\n    }\n    var pathObjCache = new Map();\n    function getBy(obj, path, def) {\n        if (!path) {\n            return obj;\n        }\n        var cacheKey = typeof path === \"function\" ? path : JSON.stringify(path);\n        var pathObj = pathObjCache.get(cacheKey) || function() {\n            var pathObj = makePathArray(path);\n            pathObjCache.set(cacheKey, pathObj);\n            return pathObj;\n        }();\n        var val;\n        try {\n            val = pathObj.reduce(function(cursor, pathPart) {\n                return cursor[pathPart];\n            }, obj);\n        } catch (e) {}\n        return typeof val !== \"undefined\" ? val : def;\n    }\n    function getFirstDefined() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for(var i = 0; i < args.length; i += 1){\n            if (typeof args[i] !== \"undefined\") {\n                return args[i];\n            }\n        }\n    }\n    function isFunction(a) {\n        if (typeof a === \"function\") {\n            return a;\n        }\n    }\n    function flattenBy(arr, key) {\n        var flat = [];\n        var recurse = function recurse(arr) {\n            arr.forEach(function(d) {\n                if (!d[key]) {\n                    flat.push(d);\n                } else {\n                    recurse(d[key]);\n                }\n            });\n        };\n        recurse(arr);\n        return flat;\n    }\n    function expandRows(rows, _ref) {\n        var manualExpandedKey = _ref.manualExpandedKey, expanded = _ref.expanded, _ref$expandSubRows = _ref.expandSubRows, expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;\n        var expandedRows = [];\n        var handleRow = function handleRow(row, addToExpandedRows) {\n            if (addToExpandedRows === void 0) {\n                addToExpandedRows = true;\n            }\n            row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];\n            row.canExpand = row.subRows && !!row.subRows.length;\n            if (addToExpandedRows) {\n                expandedRows.push(row);\n            }\n            if (row.subRows && row.subRows.length && row.isExpanded) {\n                row.subRows.forEach(function(row) {\n                    return handleRow(row, expandSubRows);\n                });\n            }\n        };\n        rows.forEach(function(row) {\n            return handleRow(row);\n        });\n        return expandedRows;\n    }\n    function getFilterMethod(filter, userFilterTypes, filterTypes) {\n        return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n    }\n    function shouldAutoRemoveFilter(autoRemove, value, column) {\n        return autoRemove ? autoRemove(value, column) : typeof value === \"undefined\";\n    }\n    function unpreparedAccessWarning() {\n        throw new Error(\"React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.\");\n    }\n    var passiveSupported = null;\n    function passiveEventSupported() {\n        // memoize support to avoid adding multiple test events\n        if (typeof passiveSupported === \"boolean\") return passiveSupported;\n        var supported = false;\n        try {\n            var options = {\n                get passive () {\n                    supported = true;\n                    return false;\n                }\n            };\n            window.addEventListener(\"test\", null, options);\n            window.removeEventListener(\"test\", null, options);\n        } catch (err) {\n            supported = false;\n        }\n        passiveSupported = supported;\n        return passiveSupported;\n    } //\n    var reOpenBracket = /\\[/g;\n    var reCloseBracket = /\\]/g;\n    function makePathArray(obj) {\n        return flattenDeep(obj) // remove all periods in parts\n        .map(function(d) {\n            return String(d).replace(\".\", \"_\");\n        }) // join parts using period\n        .join(\".\") // replace brackets with periods\n        .replace(reOpenBracket, \".\").replace(reCloseBracket, \"\") // split it back out on periods\n        .split(\".\");\n    }\n    function flattenDeep(arr, newArr) {\n        if (newArr === void 0) {\n            newArr = [];\n        }\n        if (!Array.isArray(arr)) {\n            newArr.push(arr);\n        } else {\n            for(var i = 0; i < arr.length; i += 1){\n                flattenDeep(arr[i], newArr);\n            }\n        }\n        return newArr;\n    }\n    var defaultGetTableProps = function defaultGetTableProps(props) {\n        return _extends({\n            role: \"table\"\n        }, props);\n    };\n    var defaultGetTableBodyProps = function defaultGetTableBodyProps(props) {\n        return _extends({\n            role: \"rowgroup\"\n        }, props);\n    };\n    var defaultGetHeaderProps = function defaultGetHeaderProps(props, _ref) {\n        var column = _ref.column;\n        return _extends({\n            key: \"header_\" + column.id,\n            colSpan: column.totalVisibleHeaderCount,\n            role: \"columnheader\"\n        }, props);\n    };\n    var defaultGetFooterProps = function defaultGetFooterProps(props, _ref2) {\n        var column = _ref2.column;\n        return _extends({\n            key: \"footer_\" + column.id,\n            colSpan: column.totalVisibleHeaderCount\n        }, props);\n    };\n    var defaultGetHeaderGroupProps = function defaultGetHeaderGroupProps(props, _ref3) {\n        var index = _ref3.index;\n        return _extends({\n            key: \"headerGroup_\" + index,\n            role: \"row\"\n        }, props);\n    };\n    var defaultGetFooterGroupProps = function defaultGetFooterGroupProps(props, _ref4) {\n        var index = _ref4.index;\n        return _extends({\n            key: \"footerGroup_\" + index\n        }, props);\n    };\n    var defaultGetRowProps = function defaultGetRowProps(props, _ref5) {\n        var row = _ref5.row;\n        return _extends({\n            key: \"row_\" + row.id,\n            role: \"row\"\n        }, props);\n    };\n    var defaultGetCellProps = function defaultGetCellProps(props, _ref6) {\n        var cell = _ref6.cell;\n        return _extends({\n            key: \"cell_\" + cell.row.id + \"_\" + cell.column.id,\n            role: \"cell\"\n        }, props);\n    };\n    function makeDefaultPluginHooks() {\n        return {\n            useOptions: [],\n            stateReducers: [],\n            useControlledState: [],\n            columns: [],\n            columnsDeps: [],\n            allColumns: [],\n            allColumnsDeps: [],\n            accessValue: [],\n            materializedColumns: [],\n            materializedColumnsDeps: [],\n            useInstanceAfterData: [],\n            visibleColumns: [],\n            visibleColumnsDeps: [],\n            headerGroups: [],\n            headerGroupsDeps: [],\n            useInstanceBeforeDimensions: [],\n            useInstance: [],\n            prepareRow: [],\n            getTableProps: [\n                defaultGetTableProps\n            ],\n            getTableBodyProps: [\n                defaultGetTableBodyProps\n            ],\n            getHeaderGroupProps: [\n                defaultGetHeaderGroupProps\n            ],\n            getFooterGroupProps: [\n                defaultGetFooterGroupProps\n            ],\n            getHeaderProps: [\n                defaultGetHeaderProps\n            ],\n            getFooterProps: [\n                defaultGetFooterProps\n            ],\n            getRowProps: [\n                defaultGetRowProps\n            ],\n            getCellProps: [\n                defaultGetCellProps\n            ],\n            useFinalInstance: []\n        };\n    }\n    actions.resetHiddenColumns = \"resetHiddenColumns\";\n    actions.toggleHideColumn = \"toggleHideColumn\";\n    actions.setHiddenColumns = \"setHiddenColumns\";\n    actions.toggleHideAllColumns = \"toggleHideAllColumns\";\n    var useColumnVisibility = function useColumnVisibility(hooks) {\n        hooks.getToggleHiddenProps = [\n            defaultGetToggleHiddenProps\n        ];\n        hooks.getToggleHideAllColumnsProps = [\n            defaultGetToggleHideAllColumnsProps\n        ];\n        hooks.stateReducers.push(reducer);\n        hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);\n        hooks.headerGroupsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.hiddenColumns\n            ]);\n        });\n        hooks.useInstance.push(useInstance);\n    };\n    useColumnVisibility.pluginName = \"useColumnVisibility\";\n    var defaultGetToggleHiddenProps = function defaultGetToggleHiddenProps(props, _ref2) {\n        var column = _ref2.column;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    column.toggleHidden(!e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: column.isVisible,\n                title: \"Toggle Column Visible\"\n            }\n        ];\n    };\n    var defaultGetToggleHideAllColumnsProps = function defaultGetToggleHideAllColumnsProps(props, _ref3) {\n        var instance = _ref3.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleHideAllColumns(!e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: !instance.allColumnsHidden && !instance.state.hiddenColumns.length,\n                title: \"Toggle All Columns Hidden\",\n                indeterminate: !instance.allColumnsHidden && instance.state.hiddenColumns.length\n            }\n        ];\n    };\n    function reducer(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                hiddenColumns: []\n            }, state);\n        }\n        if (action.type === actions.resetHiddenColumns) {\n            return _extends({}, state, {\n                hiddenColumns: instance.initialState.hiddenColumns || []\n            });\n        }\n        if (action.type === actions.toggleHideColumn) {\n            var should = typeof action.value !== \"undefined\" ? action.value : !state.hiddenColumns.includes(action.columnId);\n            var hiddenColumns = should ? [].concat(state.hiddenColumns, [\n                action.columnId\n            ]) : state.hiddenColumns.filter(function(d) {\n                return d !== action.columnId;\n            });\n            return _extends({}, state, {\n                hiddenColumns: hiddenColumns\n            });\n        }\n        if (action.type === actions.setHiddenColumns) {\n            return _extends({}, state, {\n                hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)\n            });\n        }\n        if (action.type === actions.toggleHideAllColumns) {\n            var shouldAll = typeof action.value !== \"undefined\" ? action.value : !state.hiddenColumns.length;\n            return _extends({}, state, {\n                hiddenColumns: shouldAll ? instance.allColumns.map(function(d) {\n                    return d.id;\n                }) : []\n            });\n        }\n    }\n    function useInstanceBeforeDimensions(instance) {\n        var headers = instance.headers, hiddenColumns = instance.state.hiddenColumns;\n        var isMountedRef = React.useRef(false);\n        if (!isMountedRef.current) ;\n        var handleColumn = function handleColumn(column, parentVisible) {\n            column.isVisible = parentVisible && !hiddenColumns.includes(column.id);\n            var totalVisibleHeaderCount = 0;\n            if (column.headers && column.headers.length) {\n                column.headers.forEach(function(subColumn) {\n                    return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n                });\n            } else {\n                totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n            }\n            column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n            return totalVisibleHeaderCount;\n        };\n        var totalVisibleHeaderCount = 0;\n        headers.forEach(function(subHeader) {\n            return totalVisibleHeaderCount += handleColumn(subHeader, true);\n        });\n    }\n    function useInstance(instance) {\n        var columns = instance.columns, flatHeaders = instance.flatHeaders, dispatch = instance.dispatch, allColumns = instance.allColumns, getHooks = instance.getHooks, hiddenColumns = instance.state.hiddenColumns, _instance$autoResetHi = instance.autoResetHiddenColumns, autoResetHiddenColumns = _instance$autoResetHi === void 0 ? true : _instance$autoResetHi;\n        var getInstance = useGetLatest(instance);\n        var allColumnsHidden = allColumns.length === hiddenColumns.length;\n        var toggleHideColumn = React.useCallback(function(columnId, value) {\n            return dispatch({\n                type: actions.toggleHideColumn,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setHiddenColumns = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.setHiddenColumns,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleHideAllColumns = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleHideAllColumns,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getToggleHideAllColumnsProps = makePropGetter(getHooks().getToggleHideAllColumnsProps, {\n            instance: getInstance()\n        });\n        flatHeaders.forEach(function(column) {\n            column.toggleHidden = function(value) {\n                dispatch({\n                    type: actions.toggleHideColumn,\n                    columnId: column.id,\n                    value: value\n                });\n            };\n            column.getToggleHiddenProps = makePropGetter(getHooks().getToggleHiddenProps, {\n                instance: getInstance(),\n                column: column\n            });\n        });\n        var getAutoResetHiddenColumns = useGetLatest(autoResetHiddenColumns);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetHiddenColumns()) {\n                dispatch({\n                    type: actions.resetHiddenColumns\n                });\n            }\n        }, [\n            dispatch,\n            columns\n        ]);\n        Object.assign(instance, {\n            allColumnsHidden: allColumnsHidden,\n            toggleHideColumn: toggleHideColumn,\n            setHiddenColumns: setHiddenColumns,\n            toggleHideAllColumns: toggleHideAllColumns,\n            getToggleHideAllColumnsProps: getToggleHideAllColumnsProps\n        });\n    }\n    var defaultInitialState = {};\n    var defaultColumnInstance = {};\n    var defaultReducer = function defaultReducer(state, action, prevState) {\n        return state;\n    };\n    var defaultGetSubRows = function defaultGetSubRows(row, index) {\n        return row.subRows || [];\n    };\n    var defaultGetRowId = function defaultGetRowId(row, index, parent) {\n        return \"\" + (parent ? [\n            parent.id,\n            index\n        ].join(\".\") : index);\n    };\n    var defaultUseControlledState = function defaultUseControlledState(d) {\n        return d;\n    };\n    function applyDefaults(props) {\n        var _props$initialState = props.initialState, initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState, _props$defaultColumn = props.defaultColumn, defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn, _props$getSubRows = props.getSubRows, getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows, _props$getRowId = props.getRowId, getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId, _props$stateReducer = props.stateReducer, stateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer, _props$useControlledS = props.useControlledState, useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS, rest = _objectWithoutPropertiesLoose(props, [\n            \"initialState\",\n            \"defaultColumn\",\n            \"getSubRows\",\n            \"getRowId\",\n            \"stateReducer\",\n            \"useControlledState\"\n        ]);\n        return _extends({}, rest, {\n            initialState: initialState,\n            defaultColumn: defaultColumn,\n            getSubRows: getSubRows,\n            getRowId: getRowId,\n            stateReducer: stateReducer,\n            useControlledState: useControlledState\n        });\n    }\n    var useTable = function useTable(props) {\n        for(var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            plugins[_key - 1] = arguments[_key];\n        }\n        // Apply default props\n        props = applyDefaults(props); // Add core plugins\n        plugins = [\n            useColumnVisibility\n        ].concat(plugins); // Create the table instance\n        var instanceRef = React.useRef({}); // Create a getter for the instance (helps avoid a lot of potential memory leaks)\n        var getInstance = useGetLatest(instanceRef.current); // Assign the props, plugins and hooks to the instance\n        Object.assign(getInstance(), _extends({}, props, {\n            plugins: plugins,\n            hooks: makeDefaultPluginHooks()\n        })); // Allow plugins to register hooks as early as possible\n        plugins.filter(Boolean).forEach(function(plugin) {\n            plugin(getInstance().hooks);\n        }); // Consume all hooks and make a getter for them\n        var getHooks = useGetLatest(getInstance().hooks);\n        getInstance().getHooks = getHooks;\n        delete getInstance().hooks; // Allow useOptions hooks to modify the options coming into the table\n        Object.assign(getInstance(), reduceHooks(getHooks().useOptions, applyDefaults(props)));\n        var _getInstance = getInstance(), data = _getInstance.data, userColumns = _getInstance.columns, initialState = _getInstance.initialState, defaultColumn = _getInstance.defaultColumn, getSubRows = _getInstance.getSubRows, getRowId = _getInstance.getRowId, stateReducer = _getInstance.stateReducer, useControlledState = _getInstance.useControlledState; // Setup user reducer ref\n        var getStateReducer = useGetLatest(stateReducer); // Build the reducer\n        var reducer = React.useCallback(function(state, action) {\n            // Detect invalid actions\n            if (!action.type) {\n                console.info({\n                    action: action\n                });\n                throw new Error(\"Unknown Action \\uD83D\\uDC46\");\n            } // Reduce the state from all plugin reducers\n            return [].concat(getHooks().stateReducers, Array.isArray(getStateReducer()) ? getStateReducer() : [\n                getStateReducer()\n            ]).reduce(function(s, handler) {\n                return handler(s, action, state, getInstance()) || s;\n            }, state);\n        }, [\n            getHooks,\n            getStateReducer,\n            getInstance\n        ]); // Start the reducer\n        var _React$useReducer = React.useReducer(reducer, undefined, function() {\n            return reducer(initialState, {\n                type: actions.init\n            });\n        }), reducerState = _React$useReducer[0], dispatch = _React$useReducer[1]; // Allow the user to control the final state with hooks\n        var state = reduceHooks([].concat(getHooks().useControlledState, [\n            useControlledState\n        ]), reducerState, {\n            instance: getInstance()\n        });\n        Object.assign(getInstance(), {\n            state: state,\n            dispatch: dispatch\n        }); // Decorate All the columns\n        var columns = React.useMemo(function() {\n            return linkColumnStructure(reduceHooks(getHooks().columns, userColumns, {\n                instance: getInstance()\n            }));\n        }, [\n            getHooks,\n            getInstance,\n            userColumns\n        ].concat(reduceHooks(getHooks().columnsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().columns = columns; // Get the flat list of all columns and allow hooks to decorate\n        // those columns (and trigger this memoization via deps)\n        var allColumns = React.useMemo(function() {\n            return reduceHooks(getHooks().allColumns, flattenColumns(columns), {\n                instance: getInstance()\n            }).map(assignColumnAccessor);\n        }, [\n            columns,\n            getHooks,\n            getInstance\n        ].concat(reduceHooks(getHooks().allColumnsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().allColumns = allColumns; // Access the row model using initial columns\n        var _React$useMemo = React.useMemo(function() {\n            var rows = [];\n            var flatRows = [];\n            var rowsById = {};\n            var allColumnsQueue = [].concat(allColumns);\n            while(allColumnsQueue.length){\n                var column = allColumnsQueue.shift();\n                accessRowsForColumn({\n                    data: data,\n                    rows: rows,\n                    flatRows: flatRows,\n                    rowsById: rowsById,\n                    column: column,\n                    getRowId: getRowId,\n                    getSubRows: getSubRows,\n                    accessValueHooks: getHooks().accessValue,\n                    getInstance: getInstance\n                });\n            }\n            return [\n                rows,\n                flatRows,\n                rowsById\n            ];\n        }, [\n            allColumns,\n            data,\n            getRowId,\n            getSubRows,\n            getHooks,\n            getInstance\n        ]), rows = _React$useMemo[0], flatRows = _React$useMemo[1], rowsById = _React$useMemo[2];\n        Object.assign(getInstance(), {\n            rows: rows,\n            initialRows: [].concat(rows),\n            flatRows: flatRows,\n            rowsById: rowsById // materializedColumns,\n        });\n        loopHooks(getHooks().useInstanceAfterData, getInstance()); // Get the flat list of all columns AFTER the rows\n        // have been access, and allow hooks to decorate\n        // those columns (and trigger this memoization via deps)\n        var visibleColumns = React.useMemo(function() {\n            return reduceHooks(getHooks().visibleColumns, allColumns, {\n                instance: getInstance()\n            }).map(function(d) {\n                return decorateColumn(d, defaultColumn);\n            });\n        }, [\n            getHooks,\n            allColumns,\n            getInstance,\n            defaultColumn\n        ].concat(reduceHooks(getHooks().visibleColumnsDeps, [], {\n            instance: getInstance()\n        }))); // Combine new visible columns with all columns\n        allColumns = React.useMemo(function() {\n            var columns = [].concat(visibleColumns);\n            allColumns.forEach(function(column) {\n                if (!columns.find(function(d) {\n                    return d.id === column.id;\n                })) {\n                    columns.push(column);\n                }\n            });\n            return columns;\n        }, [\n            allColumns,\n            visibleColumns\n        ]);\n        getInstance().allColumns = allColumns;\n        {\n            var duplicateColumns = allColumns.filter(function(column, i) {\n                return allColumns.findIndex(function(d) {\n                    return d.id === column.id;\n                }) !== i;\n            });\n            if (duplicateColumns.length) {\n                console.info(allColumns);\n                throw new Error('Duplicate columns were found with ids: \"' + duplicateColumns.map(function(d) {\n                    return d.id;\n                }).join(\", \") + '\" in the columns array above');\n            }\n        }\n        var headerGroups = React.useMemo(function() {\n            return reduceHooks(getHooks().headerGroups, makeHeaderGroups(visibleColumns, defaultColumn), getInstance());\n        }, [\n            getHooks,\n            visibleColumns,\n            defaultColumn,\n            getInstance\n        ].concat(reduceHooks(getHooks().headerGroupsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().headerGroups = headerGroups; // Get the first level of headers\n        var headers = React.useMemo(function() {\n            return headerGroups.length ? headerGroups[0].headers : [];\n        }, [\n            headerGroups\n        ]);\n        getInstance().headers = headers; // Provide a flat header list for utilities\n        getInstance().flatHeaders = headerGroups.reduce(function(all, headerGroup) {\n            return [].concat(all, headerGroup.headers);\n        }, []);\n        loopHooks(getHooks().useInstanceBeforeDimensions, getInstance()); // Filter columns down to visible ones\n        var visibleColumnsDep = visibleColumns.filter(function(d) {\n            return d.isVisible;\n        }).map(function(d) {\n            return d.id;\n        }).sort().join(\"_\");\n        visibleColumns = React.useMemo(function() {\n            return visibleColumns.filter(function(d) {\n                return d.isVisible;\n            });\n        }, [\n            visibleColumns,\n            visibleColumnsDep\n        ]);\n        getInstance().visibleColumns = visibleColumns; // Header Visibility is needed by this point\n        var _calculateHeaderWidth = calculateHeaderWidths(headers), totalColumnsMinWidth = _calculateHeaderWidth[0], totalColumnsWidth = _calculateHeaderWidth[1], totalColumnsMaxWidth = _calculateHeaderWidth[2];\n        getInstance().totalColumnsMinWidth = totalColumnsMinWidth;\n        getInstance().totalColumnsWidth = totalColumnsWidth;\n        getInstance().totalColumnsMaxWidth = totalColumnsMaxWidth;\n        loopHooks(getHooks().useInstance, getInstance()) // Each materialized header needs to be assigned a render function and other\n        ;\n        [].concat(getInstance().flatHeaders, getInstance().allColumns).forEach(function(column) {\n            // Give columns/headers rendering power\n            column.render = makeRenderer(getInstance(), column); // Give columns/headers a default getHeaderProps\n            column.getHeaderProps = makePropGetter(getHooks().getHeaderProps, {\n                instance: getInstance(),\n                column: column\n            }); // Give columns/headers a default getFooterProps\n            column.getFooterProps = makePropGetter(getHooks().getFooterProps, {\n                instance: getInstance(),\n                column: column\n            });\n        });\n        getInstance().headerGroups = React.useMemo(function() {\n            return headerGroups.filter(function(headerGroup, i) {\n                // Filter out any headers and headerGroups that don't have visible columns\n                headerGroup.headers = headerGroup.headers.filter(function(column) {\n                    var recurse = function recurse(headers) {\n                        return headers.filter(function(column) {\n                            if (column.headers) {\n                                return recurse(column.headers);\n                            }\n                            return column.isVisible;\n                        }).length;\n                    };\n                    if (column.headers) {\n                        return recurse(column.headers);\n                    }\n                    return column.isVisible;\n                }); // Give headerGroups getRowProps\n                if (headerGroup.headers.length) {\n                    headerGroup.getHeaderGroupProps = makePropGetter(getHooks().getHeaderGroupProps, {\n                        instance: getInstance(),\n                        headerGroup: headerGroup,\n                        index: i\n                    });\n                    headerGroup.getFooterGroupProps = makePropGetter(getHooks().getFooterGroupProps, {\n                        instance: getInstance(),\n                        headerGroup: headerGroup,\n                        index: i\n                    });\n                    return true;\n                }\n                return false;\n            });\n        }, [\n            headerGroups,\n            getInstance,\n            getHooks\n        ]);\n        getInstance().footerGroups = [].concat(getInstance().headerGroups).reverse(); // The prepareRow function is absolutely necessary and MUST be called on\n        // any rows the user wishes to be displayed.\n        getInstance().prepareRow = React.useCallback(function(row) {\n            row.getRowProps = makePropGetter(getHooks().getRowProps, {\n                instance: getInstance(),\n                row: row\n            }); // Build the visible cells for each row\n            row.allCells = allColumns.map(function(column) {\n                var value = row.values[column.id];\n                var cell = {\n                    column: column,\n                    row: row,\n                    value: value\n                }; // Give each cell a getCellProps base\n                cell.getCellProps = makePropGetter(getHooks().getCellProps, {\n                    instance: getInstance(),\n                    cell: cell\n                }); // Give each cell a renderer function (supports multiple renderers)\n                cell.render = makeRenderer(getInstance(), column, {\n                    row: row,\n                    cell: cell,\n                    value: value\n                });\n                return cell;\n            });\n            row.cells = visibleColumns.map(function(column) {\n                return row.allCells.find(function(cell) {\n                    return cell.column.id === column.id;\n                });\n            }); // need to apply any row specific hooks (useExpanded requires this)\n            loopHooks(getHooks().prepareRow, row, {\n                instance: getInstance()\n            });\n        }, [\n            getHooks,\n            getInstance,\n            allColumns,\n            visibleColumns\n        ]);\n        getInstance().getTableProps = makePropGetter(getHooks().getTableProps, {\n            instance: getInstance()\n        });\n        getInstance().getTableBodyProps = makePropGetter(getHooks().getTableBodyProps, {\n            instance: getInstance()\n        });\n        loopHooks(getHooks().useFinalInstance, getInstance());\n        return getInstance();\n    };\n    function calculateHeaderWidths(headers, left) {\n        if (left === void 0) {\n            left = 0;\n        }\n        var sumTotalMinWidth = 0;\n        var sumTotalWidth = 0;\n        var sumTotalMaxWidth = 0;\n        var sumTotalFlexWidth = 0;\n        headers.forEach(function(header) {\n            var subHeaders = header.headers;\n            header.totalLeft = left;\n            if (subHeaders && subHeaders.length) {\n                var _calculateHeaderWidth2 = calculateHeaderWidths(subHeaders, left), totalMinWidth = _calculateHeaderWidth2[0], totalWidth = _calculateHeaderWidth2[1], totalMaxWidth = _calculateHeaderWidth2[2], totalFlexWidth = _calculateHeaderWidth2[3];\n                header.totalMinWidth = totalMinWidth;\n                header.totalWidth = totalWidth;\n                header.totalMaxWidth = totalMaxWidth;\n                header.totalFlexWidth = totalFlexWidth;\n            } else {\n                header.totalMinWidth = header.minWidth;\n                header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n                header.totalMaxWidth = header.maxWidth;\n                header.totalFlexWidth = header.canResize ? header.totalWidth : 0;\n            }\n            if (header.isVisible) {\n                left += header.totalWidth;\n                sumTotalMinWidth += header.totalMinWidth;\n                sumTotalWidth += header.totalWidth;\n                sumTotalMaxWidth += header.totalMaxWidth;\n                sumTotalFlexWidth += header.totalFlexWidth;\n            }\n        });\n        return [\n            sumTotalMinWidth,\n            sumTotalWidth,\n            sumTotalMaxWidth,\n            sumTotalFlexWidth\n        ];\n    }\n    function accessRowsForColumn(_ref) {\n        var data = _ref.data, rows = _ref.rows, flatRows = _ref.flatRows, rowsById = _ref.rowsById, column = _ref.column, getRowId = _ref.getRowId, getSubRows = _ref.getSubRows, accessValueHooks = _ref.accessValueHooks, getInstance = _ref.getInstance;\n        // Access the row's data column-by-column\n        // We do it this way so we can incrementally add materialized\n        // columns after the first pass and avoid excessive looping\n        var accessRow = function accessRow(originalRow, rowIndex, depth, parent, parentRows) {\n            if (depth === void 0) {\n                depth = 0;\n            }\n            // Keep the original reference around\n            var original = originalRow;\n            var id = getRowId(originalRow, rowIndex, parent);\n            var row = rowsById[id]; // If the row hasn't been created, let's make it\n            if (!row) {\n                row = {\n                    id: id,\n                    original: original,\n                    index: rowIndex,\n                    depth: depth,\n                    cells: [\n                        {}\n                    ] // This is a dummy cell\n                }; // Override common array functions (and the dummy cell's getCellProps function)\n                // to show an error if it is accessed without calling prepareRow\n                row.cells.map = unpreparedAccessWarning;\n                row.cells.filter = unpreparedAccessWarning;\n                row.cells.forEach = unpreparedAccessWarning;\n                row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n                row.values = {}; // Push this row into the parentRows array\n                parentRows.push(row); // Keep track of every row in a flat array\n                flatRows.push(row); // Also keep track of every row by its ID\n                rowsById[id] = row; // Get the original subrows\n                row.originalSubRows = getSubRows(originalRow, rowIndex); // Then recursively access them\n                if (row.originalSubRows) {\n                    var subRows = [];\n                    row.originalSubRows.forEach(function(d, i) {\n                        return accessRow(d, i, depth + 1, row, subRows);\n                    }); // Keep the new subRows array on the row\n                    row.subRows = subRows;\n                }\n            } else if (row.subRows) {\n                // If the row exists, then it's already been accessed\n                // Keep recursing, but don't worry about passing the\n                // accumlator array (those rows already exist)\n                row.originalSubRows.forEach(function(d, i) {\n                    return accessRow(d, i, depth + 1, row);\n                });\n            } // If the column has an accessor, use it to get a value\n            if (column.accessor) {\n                row.values[column.id] = column.accessor(originalRow, rowIndex, row, parentRows, data);\n            } // Allow plugins to manipulate the column value\n            row.values[column.id] = reduceHooks(accessValueHooks, row.values[column.id], {\n                row: row,\n                column: column,\n                instance: getInstance()\n            }, true);\n        };\n        data.forEach(function(originalRow, rowIndex) {\n            return accessRow(originalRow, rowIndex, 0, undefined, rows);\n        });\n    }\n    actions.resetExpanded = \"resetExpanded\";\n    actions.toggleRowExpanded = \"toggleRowExpanded\";\n    actions.toggleAllRowsExpanded = \"toggleAllRowsExpanded\";\n    var useExpanded = function useExpanded(hooks) {\n        hooks.getToggleAllRowsExpandedProps = [\n            defaultGetToggleAllRowsExpandedProps\n        ];\n        hooks.getToggleRowExpandedProps = [\n            defaultGetToggleRowExpandedProps\n        ];\n        hooks.stateReducers.push(reducer$1);\n        hooks.useInstance.push(useInstance$1);\n        hooks.prepareRow.push(prepareRow);\n    };\n    useExpanded.pluginName = \"useExpanded\";\n    var defaultGetToggleAllRowsExpandedProps = function defaultGetToggleAllRowsExpandedProps(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                onClick: function onClick(e) {\n                    instance.toggleAllRowsExpanded();\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                title: \"Toggle All Rows Expanded\"\n            }\n        ];\n    };\n    var defaultGetToggleRowExpandedProps = function defaultGetToggleRowExpandedProps(props, _ref2) {\n        var row = _ref2.row;\n        return [\n            props,\n            {\n                onClick: function onClick() {\n                    row.toggleRowExpanded();\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                title: \"Toggle Row Expanded\"\n            }\n        ];\n    }; // Reducer\n    function reducer$1(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                expanded: {}\n            }, state);\n        }\n        if (action.type === actions.resetExpanded) {\n            return _extends({}, state, {\n                expanded: instance.initialState.expanded || {}\n            });\n        }\n        if (action.type === actions.toggleAllRowsExpanded) {\n            var value = action.value;\n            var rowsById = instance.rowsById;\n            var isAllRowsExpanded = Object.keys(rowsById).length === Object.keys(state.expanded).length;\n            var expandAll = typeof value !== \"undefined\" ? value : !isAllRowsExpanded;\n            if (expandAll) {\n                var expanded = {};\n                Object.keys(rowsById).forEach(function(rowId) {\n                    expanded[rowId] = true;\n                });\n                return _extends({}, state, {\n                    expanded: expanded\n                });\n            }\n            return _extends({}, state, {\n                expanded: {}\n            });\n        }\n        if (action.type === actions.toggleRowExpanded) {\n            var id = action.id, setExpanded = action.value;\n            var exists = state.expanded[id];\n            var shouldExist = typeof setExpanded !== \"undefined\" ? setExpanded : !exists;\n            if (!exists && shouldExist) {\n                var _extends2;\n                return _extends({}, state, {\n                    expanded: _extends({}, state.expanded, (_extends2 = {}, _extends2[id] = true, _extends2))\n                });\n            } else if (exists && !shouldExist) {\n                var _state$expanded = state.expanded, _ = _state$expanded[id], rest = _objectWithoutPropertiesLoose(_state$expanded, [\n                    id\n                ].map(_toPropertyKey));\n                return _extends({}, state, {\n                    expanded: rest\n                });\n            } else {\n                return state;\n            }\n        }\n    }\n    function useInstance$1(instance) {\n        var data = instance.data, rows = instance.rows, rowsById = instance.rowsById, _instance$manualExpan = instance.manualExpandedKey, manualExpandedKey = _instance$manualExpan === void 0 ? \"expanded\" : _instance$manualExpan, _instance$paginateExp = instance.paginateExpandedRows, paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp, _instance$expandSubRo = instance.expandSubRows, expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo, _instance$autoResetEx = instance.autoResetExpanded, autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx, getHooks = instance.getHooks, plugins = instance.plugins, expanded = instance.state.expanded, dispatch = instance.dispatch;\n        ensurePluginOrder(plugins, [\n            \"useSortBy\",\n            \"useGroupBy\",\n            \"usePivotColumns\",\n            \"useGlobalFilter\"\n        ], \"useExpanded\");\n        var getAutoResetExpanded = useGetLatest(autoResetExpanded);\n        var isAllRowsExpanded = Boolean(Object.keys(rowsById).length && Object.keys(expanded).length);\n        if (isAllRowsExpanded) {\n            if (Object.keys(rowsById).some(function(id) {\n                return !expanded[id];\n            })) {\n                isAllRowsExpanded = false;\n            }\n        } // Bypass any effects from firing when this changes\n        useMountedLayoutEffect(function() {\n            if (getAutoResetExpanded()) {\n                dispatch({\n                    type: actions.resetExpanded\n                });\n            }\n        }, [\n            dispatch,\n            data\n        ]);\n        var toggleRowExpanded = React.useCallback(function(id, value) {\n            dispatch({\n                type: actions.toggleRowExpanded,\n                id: id,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleAllRowsExpanded = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllRowsExpanded,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var expandedRows = React.useMemo(function() {\n            if (paginateExpandedRows) {\n                return expandRows(rows, {\n                    manualExpandedKey: manualExpandedKey,\n                    expanded: expanded,\n                    expandSubRows: expandSubRows\n                });\n            }\n            return rows;\n        }, [\n            paginateExpandedRows,\n            rows,\n            manualExpandedKey,\n            expanded,\n            expandSubRows\n        ]);\n        var expandedDepth = React.useMemo(function() {\n            return findExpandedDepth(expanded);\n        }, [\n            expanded\n        ]);\n        var getInstance = useGetLatest(instance);\n        var getToggleAllRowsExpandedProps = makePropGetter(getHooks().getToggleAllRowsExpandedProps, {\n            instance: getInstance()\n        });\n        Object.assign(instance, {\n            preExpandedRows: rows,\n            expandedRows: expandedRows,\n            rows: expandedRows,\n            expandedDepth: expandedDepth,\n            isAllRowsExpanded: isAllRowsExpanded,\n            toggleRowExpanded: toggleRowExpanded,\n            toggleAllRowsExpanded: toggleAllRowsExpanded,\n            getToggleAllRowsExpandedProps: getToggleAllRowsExpandedProps\n        });\n    }\n    function prepareRow(row, _ref3) {\n        var getHooks = _ref3.instance.getHooks, instance = _ref3.instance;\n        row.toggleRowExpanded = function(set) {\n            return instance.toggleRowExpanded(row.id, set);\n        };\n        row.getToggleRowExpandedProps = makePropGetter(getHooks().getToggleRowExpandedProps, {\n            instance: instance,\n            row: row\n        });\n    }\n    function findExpandedDepth(expanded) {\n        var maxDepth = 0;\n        Object.keys(expanded).forEach(function(id) {\n            var splitId = id.split(\".\");\n            maxDepth = Math.max(maxDepth, splitId.length);\n        });\n        return maxDepth;\n    }\n    var text = function text(rows, ids, filterValue) {\n        rows = rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n            });\n        });\n        return rows;\n    };\n    text.autoRemove = function(val) {\n        return !val;\n    };\n    var exactText = function exactText(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n            });\n        });\n    };\n    exactText.autoRemove = function(val) {\n        return !val;\n    };\n    var exactTextCase = function exactTextCase(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n            });\n        });\n    };\n    exactTextCase.autoRemove = function(val) {\n        return !val;\n    };\n    var includes = function includes(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue.includes(filterValue);\n            });\n        });\n    };\n    includes.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesAll = function includesAll(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue && rowValue.length && filterValue.every(function(val) {\n                    return rowValue.includes(val);\n                });\n            });\n        });\n    };\n    includesAll.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesSome = function includesSome(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue && rowValue.length && filterValue.some(function(val) {\n                    return rowValue.includes(val);\n                });\n            });\n        });\n    };\n    includesSome.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesValue = function includesValue(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return filterValue.includes(rowValue);\n            });\n        });\n    };\n    includesValue.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var exact = function exact(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue === filterValue;\n            });\n        });\n    };\n    exact.autoRemove = function(val) {\n        return typeof val === \"undefined\";\n    };\n    var equals = function equals(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n                return rowValue == filterValue;\n            });\n        });\n    };\n    equals.autoRemove = function(val) {\n        return val == null;\n    };\n    var between = function between(rows, ids, filterValue) {\n        var _ref = filterValue || [], min = _ref[0], max = _ref[1];\n        min = typeof min === \"number\" ? min : -Infinity;\n        max = typeof max === \"number\" ? max : Infinity;\n        if (min > max) {\n            var temp = min;\n            min = max;\n            max = temp;\n        }\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue >= min && rowValue <= max;\n            });\n        });\n    };\n    between.autoRemove = function(val) {\n        return !val || typeof val[0] !== \"number\" && typeof val[1] !== \"number\";\n    };\n    var filterTypes = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        text: text,\n        exactText: exactText,\n        exactTextCase: exactTextCase,\n        includes: includes,\n        includesAll: includesAll,\n        includesSome: includesSome,\n        includesValue: includesValue,\n        exact: exact,\n        equals: equals,\n        between: between\n    });\n    actions.resetFilters = \"resetFilters\";\n    actions.setFilter = \"setFilter\";\n    actions.setAllFilters = \"setAllFilters\";\n    var useFilters = function useFilters(hooks) {\n        hooks.stateReducers.push(reducer$2);\n        hooks.useInstance.push(useInstance$2);\n    };\n    useFilters.pluginName = \"useFilters\";\n    function reducer$2(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                filters: []\n            }, state);\n        }\n        if (action.type === actions.resetFilters) {\n            return _extends({}, state, {\n                filters: instance.initialState.filters || []\n            });\n        }\n        if (action.type === actions.setFilter) {\n            var columnId = action.columnId, filterValue = action.filterValue;\n            var allColumns = instance.allColumns, userFilterTypes = instance.filterTypes;\n            var column = allColumns.find(function(d) {\n                return d.id === columnId;\n            });\n            if (!column) {\n                throw new Error(\"React-Table: Could not find a column with id: \" + columnId);\n            }\n            var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n            var previousfilter = state.filters.find(function(d) {\n                return d.id === columnId;\n            });\n            var newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //\n            if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n                return _extends({}, state, {\n                    filters: state.filters.filter(function(d) {\n                        return d.id !== columnId;\n                    })\n                });\n            }\n            if (previousfilter) {\n                return _extends({}, state, {\n                    filters: state.filters.map(function(d) {\n                        if (d.id === columnId) {\n                            return {\n                                id: columnId,\n                                value: newFilter\n                            };\n                        }\n                        return d;\n                    })\n                });\n            }\n            return _extends({}, state, {\n                filters: [].concat(state.filters, [\n                    {\n                        id: columnId,\n                        value: newFilter\n                    }\n                ])\n            });\n        }\n        if (action.type === actions.setAllFilters) {\n            var filters = action.filters;\n            var _allColumns = instance.allColumns, _userFilterTypes = instance.filterTypes;\n            return _extends({}, state, {\n                // Filter out undefined values\n                filters: functionalUpdate(filters, state.filters).filter(function(filter) {\n                    var column = _allColumns.find(function(d) {\n                        return d.id === filter.id;\n                    });\n                    var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);\n                    if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {\n                        return false;\n                    }\n                    return true;\n                })\n            });\n        }\n    }\n    function useInstance$2(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, userFilterTypes = instance.filterTypes, manualFilters = instance.manualFilters, _instance$defaultCanF = instance.defaultCanFilter, defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF, disableFilters = instance.disableFilters, filters = instance.state.filters, dispatch = instance.dispatch, _instance$autoResetFi = instance.autoResetFilters, autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;\n        var setFilter = React.useCallback(function(columnId, filterValue) {\n            dispatch({\n                type: actions.setFilter,\n                columnId: columnId,\n                filterValue: filterValue\n            });\n        }, [\n            dispatch\n        ]);\n        var setAllFilters = React.useCallback(function(filters) {\n            dispatch({\n                type: actions.setAllFilters,\n                filters: filters\n            });\n        }, [\n            dispatch\n        ]);\n        allColumns.forEach(function(column) {\n            var id = column.id, accessor = column.accessor, columnDefaultCanFilter = column.defaultCanFilter, columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n            column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n            column.setFilter = function(val) {\n                return setFilter(column.id, val);\n            }; // Provide the current filter value to the column for\n            // convenience\n            var found = filters.find(function(d) {\n                return d.id === id;\n            });\n            column.filterValue = found && found.value;\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualFilters || !filters.length) {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById\n                ];\n            }\n            var filteredFlatRows = [];\n            var filteredRowsById = {}; // Filters top level and nested rows\n            var filterRows = function filterRows(rows, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                var filteredRows = rows;\n                filteredRows = filters.reduce(function(filteredSoFar, _ref) {\n                    var columnId = _ref.id, filterValue = _ref.value;\n                    // Find the filters column\n                    var column = allColumns.find(function(d) {\n                        return d.id === columnId;\n                    });\n                    if (!column) {\n                        return filteredSoFar;\n                    }\n                    if (depth === 0) {\n                        column.preFilteredRows = filteredSoFar;\n                    }\n                    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n                    if (!filterMethod) {\n                        console.warn(\"Could not find a valid 'column.filter' for column with the ID: \" + column.id + \".\");\n                        return filteredSoFar;\n                    } // Pass the rows, id, filterValue and column to the filterMethod\n                    // to get the filtered rows back\n                    column.filteredRows = filterMethod(filteredSoFar, [\n                        columnId\n                    ], filterValue);\n                    return column.filteredRows;\n                }, rows); // Apply the filter to any subRows\n                // We technically could do this recursively in the above loop,\n                // but that would severely hinder the API for the user, since they\n                // would be required to do that recursion in some scenarios\n                filteredRows.forEach(function(row) {\n                    filteredFlatRows.push(row);\n                    filteredRowsById[row.id] = row;\n                    if (!row.subRows) {\n                        return;\n                    }\n                    row.subRows = row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows;\n                });\n                return filteredRows;\n            };\n            return [\n                filterRows(rows),\n                filteredFlatRows,\n                filteredRowsById\n            ];\n        }, [\n            manualFilters,\n            filters,\n            rows,\n            flatRows,\n            rowsById,\n            allColumns,\n            userFilterTypes\n        ]), filteredRows = _React$useMemo[0], filteredFlatRows = _React$useMemo[1], filteredRowsById = _React$useMemo[2];\n        React.useMemo(function() {\n            // Now that each filtered column has it's partially filtered rows,\n            // lets assign the final filtered rows to all of the other columns\n            var nonFilteredColumns = allColumns.filter(function(column) {\n                return !filters.find(function(d) {\n                    return d.id === column.id;\n                });\n            }); // This essentially enables faceted filter options to be built easily\n            // using every column's preFilteredRows value\n            nonFilteredColumns.forEach(function(column) {\n                column.preFilteredRows = filteredRows;\n                column.filteredRows = filteredRows;\n            });\n        }, [\n            filteredRows,\n            filters,\n            allColumns\n        ]);\n        var getAutoResetFilters = useGetLatest(autoResetFilters);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetFilters()) {\n                dispatch({\n                    type: actions.resetFilters\n                });\n            }\n        }, [\n            dispatch,\n            manualFilters ? null : data\n        ]);\n        Object.assign(instance, {\n            preFilteredRows: rows,\n            preFilteredFlatRows: flatRows,\n            preFilteredRowsById: rowsById,\n            filteredRows: filteredRows,\n            filteredFlatRows: filteredFlatRows,\n            filteredRowsById: filteredRowsById,\n            rows: filteredRows,\n            flatRows: filteredFlatRows,\n            rowsById: filteredRowsById,\n            setFilter: setFilter,\n            setAllFilters: setAllFilters\n        });\n    }\n    actions.resetGlobalFilter = \"resetGlobalFilter\";\n    actions.setGlobalFilter = \"setGlobalFilter\";\n    var useGlobalFilter = function useGlobalFilter(hooks) {\n        hooks.stateReducers.push(reducer$3);\n        hooks.useInstance.push(useInstance$3);\n    };\n    useGlobalFilter.pluginName = \"useGlobalFilter\";\n    function reducer$3(state, action, previousState, instance) {\n        if (action.type === actions.resetGlobalFilter) {\n            return _extends({}, state, {\n                globalFilter: instance.initialState.globalFilter || undefined\n            });\n        }\n        if (action.type === actions.setGlobalFilter) {\n            var filterValue = action.filterValue;\n            var userFilterTypes = instance.userFilterTypes;\n            var filterMethod = getFilterMethod(instance.globalFilter, userFilterTypes || {}, filterTypes);\n            var newFilter = functionalUpdate(filterValue, state.globalFilter); //\n            if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter)) {\n                var globalFilter = state.globalFilter, stateWithoutGlobalFilter = _objectWithoutPropertiesLoose(state, [\n                    \"globalFilter\"\n                ]);\n                return stateWithoutGlobalFilter;\n            }\n            return _extends({}, state, {\n                globalFilter: newFilter\n            });\n        }\n    }\n    function useInstance$3(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, userFilterTypes = instance.filterTypes, globalFilter = instance.globalFilter, manualGlobalFilter = instance.manualGlobalFilter, globalFilterValue = instance.state.globalFilter, dispatch = instance.dispatch, _instance$autoResetGl = instance.autoResetGlobalFilter, autoResetGlobalFilter = _instance$autoResetGl === void 0 ? true : _instance$autoResetGl, disableGlobalFilter = instance.disableGlobalFilter;\n        var setGlobalFilter = React.useCallback(function(filterValue) {\n            dispatch({\n                type: actions.setGlobalFilter,\n                filterValue: filterValue\n            });\n        }, [\n            dispatch\n        ]); // TODO: Create a filter cache for incremental high speed multi-filtering\n        // This gets pretty complicated pretty fast, since you have to maintain a\n        // cache for each row group (top-level rows, and each row's recursive subrows)\n        // This would make multi-filtering a lot faster though. Too far?\n        var _React$useMemo = React.useMemo(function() {\n            if (manualGlobalFilter || typeof globalFilterValue === \"undefined\") {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById\n                ];\n            }\n            var filteredFlatRows = [];\n            var filteredRowsById = {};\n            var filterMethod = getFilterMethod(globalFilter, userFilterTypes || {}, filterTypes);\n            if (!filterMethod) {\n                console.warn(\"Could not find a valid 'globalFilter' option.\");\n                return rows;\n            }\n            allColumns.forEach(function(column) {\n                var columnDisableGlobalFilter = column.disableGlobalFilter;\n                column.canFilter = getFirstDefined(columnDisableGlobalFilter === true ? false : undefined, disableGlobalFilter === true ? false : undefined, true);\n            });\n            var filterableColumns = allColumns.filter(function(c) {\n                return c.canFilter === true;\n            }); // Filters top level and nested rows\n            var filterRows = function filterRows(filteredRows) {\n                filteredRows = filterMethod(filteredRows, filterableColumns.map(function(d) {\n                    return d.id;\n                }), globalFilterValue);\n                filteredRows.forEach(function(row) {\n                    filteredFlatRows.push(row);\n                    filteredRowsById[row.id] = row;\n                    row.subRows = row.subRows && row.subRows.length ? filterRows(row.subRows) : row.subRows;\n                });\n                return filteredRows;\n            };\n            return [\n                filterRows(rows),\n                filteredFlatRows,\n                filteredRowsById\n            ];\n        }, [\n            manualGlobalFilter,\n            globalFilterValue,\n            globalFilter,\n            userFilterTypes,\n            allColumns,\n            rows,\n            flatRows,\n            rowsById,\n            disableGlobalFilter\n        ]), globalFilteredRows = _React$useMemo[0], globalFilteredFlatRows = _React$useMemo[1], globalFilteredRowsById = _React$useMemo[2];\n        var getAutoResetGlobalFilter = useGetLatest(autoResetGlobalFilter);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetGlobalFilter()) {\n                dispatch({\n                    type: actions.resetGlobalFilter\n                });\n            }\n        }, [\n            dispatch,\n            manualGlobalFilter ? null : data\n        ]);\n        Object.assign(instance, {\n            preGlobalFilteredRows: rows,\n            preGlobalFilteredFlatRows: flatRows,\n            preGlobalFilteredRowsById: rowsById,\n            globalFilteredRows: globalFilteredRows,\n            globalFilteredFlatRows: globalFilteredFlatRows,\n            globalFilteredRowsById: globalFilteredRowsById,\n            rows: globalFilteredRows,\n            flatRows: globalFilteredFlatRows,\n            rowsById: globalFilteredRowsById,\n            setGlobalFilter: setGlobalFilter,\n            disableGlobalFilter: disableGlobalFilter\n        });\n    }\n    function sum(values, aggregatedValues) {\n        // It's faster to just add the aggregations together instead of\n        // process leaf nodes individually\n        return aggregatedValues.reduce(function(sum, next) {\n            return sum + (typeof next === \"number\" ? next : 0);\n        }, 0);\n    }\n    function min(values) {\n        var min = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                min = Math.min(min, value);\n            }\n        });\n        return min;\n    }\n    function max(values) {\n        var max = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                max = Math.max(max, value);\n            }\n        });\n        return max;\n    }\n    function minMax(values) {\n        var min = values[0] || 0;\n        var max = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n            }\n        });\n        return min + \"..\" + max;\n    }\n    function average(values) {\n        return sum(null, values) / values.length;\n    }\n    function median(values) {\n        if (!values.length) {\n            return null;\n        }\n        var mid = Math.floor(values.length / 2);\n        var nums = [].concat(values).sort(function(a, b) {\n            return a - b;\n        });\n        return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n    }\n    function unique(values) {\n        return Array.from(new Set(values).values());\n    }\n    function uniqueCount(values) {\n        return new Set(values).size;\n    }\n    function count(values) {\n        return values.length;\n    }\n    var aggregations = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        sum: sum,\n        min: min,\n        max: max,\n        minMax: minMax,\n        average: average,\n        median: median,\n        unique: unique,\n        uniqueCount: uniqueCount,\n        count: count\n    });\n    var emptyArray = [];\n    var emptyObject = {}; // Actions\n    actions.resetGroupBy = \"resetGroupBy\";\n    actions.setGroupBy = \"setGroupBy\";\n    actions.toggleGroupBy = \"toggleGroupBy\";\n    var useGroupBy = function useGroupBy(hooks) {\n        hooks.getGroupByToggleProps = [\n            defaultGetGroupByToggleProps\n        ];\n        hooks.stateReducers.push(reducer$4);\n        hooks.visibleColumnsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.groupBy\n            ]);\n        });\n        hooks.visibleColumns.push(visibleColumns);\n        hooks.useInstance.push(useInstance$4);\n        hooks.prepareRow.push(prepareRow$1);\n    };\n    useGroupBy.pluginName = \"useGroupBy\";\n    var defaultGetGroupByToggleProps = function defaultGetGroupByToggleProps(props, _ref2) {\n        var header = _ref2.header;\n        return [\n            props,\n            {\n                onClick: header.canGroupBy ? function(e) {\n                    e.persist();\n                    header.toggleGroupBy();\n                } : undefined,\n                style: {\n                    cursor: header.canGroupBy ? \"pointer\" : undefined\n                },\n                title: \"Toggle GroupBy\"\n            }\n        ];\n    }; // Reducer\n    function reducer$4(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                groupBy: []\n            }, state);\n        }\n        if (action.type === actions.resetGroupBy) {\n            return _extends({}, state, {\n                groupBy: instance.initialState.groupBy || []\n            });\n        }\n        if (action.type === actions.setGroupBy) {\n            var value = action.value;\n            return _extends({}, state, {\n                groupBy: value\n            });\n        }\n        if (action.type === actions.toggleGroupBy) {\n            var columnId = action.columnId, setGroupBy = action.value;\n            var resolvedGroupBy = typeof setGroupBy !== \"undefined\" ? setGroupBy : !state.groupBy.includes(columnId);\n            if (resolvedGroupBy) {\n                return _extends({}, state, {\n                    groupBy: [].concat(state.groupBy, [\n                        columnId\n                    ])\n                });\n            }\n            return _extends({}, state, {\n                groupBy: state.groupBy.filter(function(d) {\n                    return d !== columnId;\n                })\n            });\n        }\n    }\n    function visibleColumns(columns, _ref3) {\n        var groupBy = _ref3.instance.state.groupBy;\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        var groupByColumns = groupBy.map(function(g) {\n            return columns.find(function(col) {\n                return col.id === g;\n            });\n        }).filter(Boolean);\n        var nonGroupByColumns = columns.filter(function(col) {\n            return !groupBy.includes(col.id);\n        });\n        columns = [].concat(groupByColumns, nonGroupByColumns);\n        columns.forEach(function(column) {\n            column.isGrouped = groupBy.includes(column.id);\n            column.groupedIndex = groupBy.indexOf(column.id);\n        });\n        return columns;\n    }\n    var defaultUserAggregations = {};\n    function useInstance$4(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, flatHeaders = instance.flatHeaders, _instance$groupByFn = instance.groupByFn, groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn, manualGroupBy = instance.manualGroupBy, _instance$aggregation = instance.aggregations, userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation, plugins = instance.plugins, groupBy = instance.state.groupBy, dispatch = instance.dispatch, _instance$autoResetGr = instance.autoResetGroupBy, autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr, disableGroupBy = instance.disableGroupBy, defaultCanGroupBy = instance.defaultCanGroupBy, getHooks = instance.getHooks;\n        ensurePluginOrder(plugins, [\n            \"useColumnOrder\",\n            \"useFilters\"\n        ], \"useGroupBy\");\n        var getInstance = useGetLatest(instance);\n        allColumns.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnGroupBy = column.defaultGroupBy, columnDisableGroupBy = column.disableGroupBy;\n            column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);\n            if (column.canGroupBy) {\n                column.toggleGroupBy = function() {\n                    return instance.toggleGroupBy(column.id);\n                };\n            }\n            column.Aggregated = column.Aggregated || column.Cell;\n        });\n        var toggleGroupBy = React.useCallback(function(columnId, value) {\n            dispatch({\n                type: actions.toggleGroupBy,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setGroupBy = React.useCallback(function(value) {\n            dispatch({\n                type: actions.setGroupBy,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        flatHeaders.forEach(function(header) {\n            header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {\n                instance: getInstance(),\n                header: header\n            });\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualGroupBy || !groupBy.length) {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById,\n                    emptyArray,\n                    emptyObject,\n                    flatRows,\n                    rowsById\n                ];\n            } // Ensure that the list of filtered columns exist\n            var existingGroupBy = groupBy.filter(function(g) {\n                return allColumns.find(function(col) {\n                    return col.id === g;\n                });\n            }); // Find the columns that can or are aggregating\n            // Uses each column to aggregate rows into a single value\n            var aggregateRowsToValues = function aggregateRowsToValues(leafRows, groupedRows, depth) {\n                var values = {};\n                allColumns.forEach(function(column) {\n                    // Don't aggregate columns that are in the groupBy\n                    if (existingGroupBy.includes(column.id)) {\n                        values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;\n                        return;\n                    } // Aggregate the values\n                    var aggregateFn = typeof column.aggregate === \"function\" ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];\n                    if (aggregateFn) {\n                        // Get the columnValues to aggregate\n                        var groupedValues = groupedRows.map(function(row) {\n                            return row.values[column.id];\n                        }); // Get the columnValues to aggregate\n                        var leafValues = leafRows.map(function(row) {\n                            var columnValue = row.values[column.id];\n                            if (!depth && column.aggregateValue) {\n                                var aggregateValueFn = typeof column.aggregateValue === \"function\" ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];\n                                if (!aggregateValueFn) {\n                                    console.info({\n                                        column: column\n                                    });\n                                    throw new Error(\"React Table: Invalid column.aggregateValue option for column listed above\");\n                                }\n                                columnValue = aggregateValueFn(columnValue, row, column);\n                            }\n                            return columnValue;\n                        });\n                        values[column.id] = aggregateFn(leafValues, groupedValues);\n                    } else if (column.aggregate) {\n                        console.info({\n                            column: column\n                        });\n                        throw new Error(\"React Table: Invalid column.aggregate option for column listed above\");\n                    } else {\n                        values[column.id] = null;\n                    }\n                });\n                return values;\n            };\n            var groupedFlatRows = [];\n            var groupedRowsById = {};\n            var onlyGroupedFlatRows = [];\n            var onlyGroupedRowsById = {};\n            var nonGroupedFlatRows = [];\n            var nonGroupedRowsById = {}; // Recursively group the data\n            var groupUpRecursively = function groupUpRecursively(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // This is the last level, just return the rows\n                if (depth === existingGroupBy.length) {\n                    return rows.map(function(row) {\n                        return _extends({}, row, {\n                            depth: depth\n                        });\n                    });\n                }\n                var columnId = existingGroupBy[depth]; // Group the rows together for this level\n                var rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group\n                var aggregatedGroupedRows = Object.entries(rowGroupsMap).map(function(_ref4, index) {\n                    var groupByVal = _ref4[0], groupedRows = _ref4[1];\n                    var id = columnId + \":\" + groupByVal;\n                    id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n                    var subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n                    var leafRows = depth ? flattenBy(groupedRows, \"leafRows\") : groupedRows;\n                    var values = aggregateRowsToValues(leafRows, groupedRows, depth);\n                    var row = {\n                        id: id,\n                        isGrouped: true,\n                        groupByID: columnId,\n                        groupByVal: groupByVal,\n                        values: values,\n                        subRows: subRows,\n                        leafRows: leafRows,\n                        depth: depth,\n                        index: index\n                    };\n                    subRows.forEach(function(subRow) {\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                        if (subRow.isGrouped) {\n                            onlyGroupedFlatRows.push(subRow);\n                            onlyGroupedRowsById[subRow.id] = subRow;\n                        } else {\n                            nonGroupedFlatRows.push(subRow);\n                            nonGroupedRowsById[subRow.id] = subRow;\n                        }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            var groupedRows = groupUpRecursively(rows);\n            groupedRows.forEach(function(subRow) {\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n                if (subRow.isGrouped) {\n                    onlyGroupedFlatRows.push(subRow);\n                    onlyGroupedRowsById[subRow.id] = subRow;\n                } else {\n                    nonGroupedFlatRows.push(subRow);\n                    nonGroupedRowsById[subRow.id] = subRow;\n                }\n            }); // Assign the new data\n            return [\n                groupedRows,\n                groupedFlatRows,\n                groupedRowsById,\n                onlyGroupedFlatRows,\n                onlyGroupedRowsById,\n                nonGroupedFlatRows,\n                nonGroupedRowsById\n            ];\n        }, [\n            manualGroupBy,\n            groupBy,\n            rows,\n            flatRows,\n            rowsById,\n            allColumns,\n            userAggregations,\n            groupByFn\n        ]), groupedRows = _React$useMemo[0], groupedFlatRows = _React$useMemo[1], groupedRowsById = _React$useMemo[2], onlyGroupedFlatRows = _React$useMemo[3], onlyGroupedRowsById = _React$useMemo[4], nonGroupedFlatRows = _React$useMemo[5], nonGroupedRowsById = _React$useMemo[6];\n        var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetGroupBy()) {\n                dispatch({\n                    type: actions.resetGroupBy\n                });\n            }\n        }, [\n            dispatch,\n            manualGroupBy ? null : data\n        ]);\n        Object.assign(instance, {\n            preGroupedRows: rows,\n            preGroupedFlatRow: flatRows,\n            preGroupedRowsById: rowsById,\n            groupedRows: groupedRows,\n            groupedFlatRows: groupedFlatRows,\n            groupedRowsById: groupedRowsById,\n            onlyGroupedFlatRows: onlyGroupedFlatRows,\n            onlyGroupedRowsById: onlyGroupedRowsById,\n            nonGroupedFlatRows: nonGroupedFlatRows,\n            nonGroupedRowsById: nonGroupedRowsById,\n            rows: groupedRows,\n            flatRows: groupedFlatRows,\n            rowsById: groupedRowsById,\n            toggleGroupBy: toggleGroupBy,\n            setGroupBy: setGroupBy\n        });\n    }\n    function prepareRow$1(row) {\n        row.allCells.forEach(function(cell) {\n            var _row$subRows;\n            // Grouped cells are in the groupBy and the pivot cell for the row\n            cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped\n            cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n            cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length);\n        });\n    }\n    function defaultGroupByFn(rows, columnId) {\n        return rows.reduce(function(prev, row, i) {\n            // TODO: Might want to implement a key serializer here so\n            // irregular column values can still be grouped if needed?\n            var resKey = \"\" + row.values[columnId];\n            prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n            prev[resKey].push(row);\n            return prev;\n        }, {});\n    }\n    var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n    // It handles numbers, mixed alphanumeric combinations, and even\n    // null, undefined, and Infinity\n    var alphanumeric = function alphanumeric(rowA, rowB, columnId) {\n        var _getRowValuesByColumn = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn[0], b = _getRowValuesByColumn[1]; // Force to strings (or \"\" for unsupported types)\n        a = toString(a);\n        b = toString(b); // Split on number groups, but keep the delimiter\n        // Then remove falsey split values\n        a = a.split(reSplitAlphaNumeric).filter(Boolean);\n        b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n        while(a.length && b.length){\n            var aa = a.shift();\n            var bb = b.shift();\n            var an = parseInt(aa, 10);\n            var bn = parseInt(bb, 10);\n            var combo = [\n                an,\n                bn\n            ].sort(); // Both are string\n            if (isNaN(combo[0])) {\n                if (aa > bb) {\n                    return 1;\n                }\n                if (bb > aa) {\n                    return -1;\n                }\n                continue;\n            } // One is a string, one is a number\n            if (isNaN(combo[1])) {\n                return isNaN(an) ? -1 : 1;\n            } // Both are numbers\n            if (an > bn) {\n                return 1;\n            }\n            if (bn > an) {\n                return -1;\n            }\n        }\n        return a.length - b.length;\n    };\n    function datetime(rowA, rowB, columnId) {\n        var _getRowValuesByColumn2 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn2[0], b = _getRowValuesByColumn2[1];\n        a = a.getTime();\n        b = b.getTime();\n        return compareBasic(a, b);\n    }\n    function basic(rowA, rowB, columnId) {\n        var _getRowValuesByColumn3 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn3[0], b = _getRowValuesByColumn3[1];\n        return compareBasic(a, b);\n    }\n    function string(rowA, rowB, columnId) {\n        var _getRowValuesByColumn4 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn4[0], b = _getRowValuesByColumn4[1];\n        a = a.split(\"\").filter(Boolean);\n        b = b.split(\"\").filter(Boolean);\n        while(a.length && b.length){\n            var aa = a.shift();\n            var bb = b.shift();\n            var alower = aa.toLowerCase();\n            var blower = bb.toLowerCase(); // Case insensitive comparison until characters match\n            if (alower > blower) {\n                return 1;\n            }\n            if (blower > alower) {\n                return -1;\n            } // If lowercase characters are identical\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        return a.length - b.length;\n    }\n    function number(rowA, rowB, columnId) {\n        var _getRowValuesByColumn5 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn5[0], b = _getRowValuesByColumn5[1];\n        var replaceNonNumeric = /[^0-9.]/gi;\n        a = Number(String(a).replace(replaceNonNumeric, \"\"));\n        b = Number(String(b).replace(replaceNonNumeric, \"\"));\n        return compareBasic(a, b);\n    } // Utils\n    function compareBasic(a, b) {\n        return a === b ? 0 : a > b ? 1 : -1;\n    }\n    function getRowValuesByColumnID(row1, row2, columnId) {\n        return [\n            row1.values[columnId],\n            row2.values[columnId]\n        ];\n    }\n    function toString(a) {\n        if (typeof a === \"number\") {\n            if (isNaN(a) || a === Infinity || a === -Infinity) {\n                return \"\";\n            }\n            return String(a);\n        }\n        if (typeof a === \"string\") {\n            return a;\n        }\n        return \"\";\n    }\n    var sortTypes = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        alphanumeric: alphanumeric,\n        datetime: datetime,\n        basic: basic,\n        string: string,\n        number: number\n    });\n    actions.resetSortBy = \"resetSortBy\";\n    actions.setSortBy = \"setSortBy\";\n    actions.toggleSortBy = \"toggleSortBy\";\n    actions.clearSortBy = \"clearSortBy\";\n    defaultColumn.sortType = \"alphanumeric\";\n    defaultColumn.sortDescFirst = false;\n    var useSortBy = function useSortBy(hooks) {\n        hooks.getSortByToggleProps = [\n            defaultGetSortByToggleProps\n        ];\n        hooks.stateReducers.push(reducer$5);\n        hooks.useInstance.push(useInstance$5);\n    };\n    useSortBy.pluginName = \"useSortBy\";\n    var defaultGetSortByToggleProps = function defaultGetSortByToggleProps(props, _ref) {\n        var instance = _ref.instance, column = _ref.column;\n        var _instance$isMultiSort = instance.isMultiSortEvent, isMultiSortEvent = _instance$isMultiSort === void 0 ? function(e) {\n            return e.shiftKey;\n        } : _instance$isMultiSort;\n        return [\n            props,\n            {\n                onClick: column.canSort ? function(e) {\n                    e.persist();\n                    column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n                } : undefined,\n                style: {\n                    cursor: column.canSort ? \"pointer\" : undefined\n                },\n                title: column.canSort ? \"Toggle SortBy\" : undefined\n            }\n        ];\n    }; // Reducer\n    function reducer$5(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                sortBy: []\n            }, state);\n        }\n        if (action.type === actions.resetSortBy) {\n            return _extends({}, state, {\n                sortBy: instance.initialState.sortBy || []\n            });\n        }\n        if (action.type === actions.clearSortBy) {\n            var sortBy = state.sortBy;\n            var newSortBy = sortBy.filter(function(d) {\n                return d.id !== action.columnId;\n            });\n            return _extends({}, state, {\n                sortBy: newSortBy\n            });\n        }\n        if (action.type === actions.setSortBy) {\n            var _sortBy = action.sortBy;\n            return _extends({}, state, {\n                sortBy: _sortBy\n            });\n        }\n        if (action.type === actions.toggleSortBy) {\n            var columnId = action.columnId, desc = action.desc, multi = action.multi;\n            var allColumns = instance.allColumns, disableMultiSort = instance.disableMultiSort, disableSortRemove = instance.disableSortRemove, disableMultiRemove = instance.disableMultiRemove, _instance$maxMultiSor = instance.maxMultiSortColCount, maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor;\n            var _sortBy2 = state.sortBy; // Find the column for this columnId\n            var column = allColumns.find(function(d) {\n                return d.id === columnId;\n            });\n            var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n            var existingSortBy = _sortBy2.find(function(d) {\n                return d.id === columnId;\n            });\n            var existingIndex = _sortBy2.findIndex(function(d) {\n                return d.id === columnId;\n            });\n            var hasDescDefined = typeof desc !== \"undefined\" && desc !== null;\n            var _newSortBy = []; // What should we do with this sort action?\n            var sortAction;\n            if (!disableMultiSort && multi) {\n                if (existingSortBy) {\n                    sortAction = \"toggle\";\n                } else {\n                    sortAction = \"add\";\n                }\n            } else {\n                // Normal mode\n                if (existingIndex !== _sortBy2.length - 1 || _sortBy2.length !== 1) {\n                    sortAction = \"replace\";\n                } else if (existingSortBy) {\n                    sortAction = \"toggle\";\n                } else {\n                    sortAction = \"replace\";\n                }\n            } // Handle toggle states that will remove the sortBy\n            if (sortAction === \"toggle\" && // Must be toggling\n            !disableSortRemove && // If disableSortRemove, disable in general\n            !hasDescDefined && (multi ? !disableMultiRemove : true) && (existingSortBy && // Finally, detect if it should indeed be removed\n            existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n                sortAction = \"remove\";\n            }\n            if (sortAction === \"replace\") {\n                _newSortBy = [\n                    {\n                        id: columnId,\n                        desc: hasDescDefined ? desc : sortDescFirst\n                    }\n                ];\n            } else if (sortAction === \"add\") {\n                _newSortBy = [].concat(_sortBy2, [\n                    {\n                        id: columnId,\n                        desc: hasDescDefined ? desc : sortDescFirst\n                    }\n                ]); // Take latest n columns\n                _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);\n            } else if (sortAction === \"toggle\") {\n                // This flips (or sets) the\n                _newSortBy = _sortBy2.map(function(d) {\n                    if (d.id === columnId) {\n                        return _extends({}, d, {\n                            desc: hasDescDefined ? desc : !existingSortBy.desc\n                        });\n                    }\n                    return d;\n                });\n            } else if (sortAction === \"remove\") {\n                _newSortBy = _sortBy2.filter(function(d) {\n                    return d.id !== columnId;\n                });\n            }\n            return _extends({}, state, {\n                sortBy: _newSortBy\n            });\n        }\n    }\n    function useInstance$5(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, allColumns = instance.allColumns, _instance$orderByFn = instance.orderByFn, orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn, userSortTypes = instance.sortTypes, manualSortBy = instance.manualSortBy, defaultCanSort = instance.defaultCanSort, disableSortBy = instance.disableSortBy, flatHeaders = instance.flatHeaders, sortBy = instance.state.sortBy, dispatch = instance.dispatch, plugins = instance.plugins, getHooks = instance.getHooks, _instance$autoResetSo = instance.autoResetSortBy, autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;\n        ensurePluginOrder(plugins, [\n            \"useFilters\",\n            \"useGlobalFilter\",\n            \"useGroupBy\",\n            \"usePivotColumns\"\n        ], \"useSortBy\");\n        var setSortBy = React.useCallback(function(sortBy) {\n            dispatch({\n                type: actions.setSortBy,\n                sortBy: sortBy\n            });\n        }, [\n            dispatch\n        ]); // Updates sorting based on a columnId, desc flag and multi flag\n        var toggleSortBy = React.useCallback(function(columnId, desc, multi) {\n            dispatch({\n                type: actions.toggleSortBy,\n                columnId: columnId,\n                desc: desc,\n                multi: multi\n            });\n        }, [\n            dispatch\n        ]); // use reference to avoid memory leak in #1608\n        var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers\n        flatHeaders.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnCanSort = column.canSort, columnDisableSortBy = column.disableSortBy, id = column.id;\n            var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);\n            column.canSort = canSort;\n            if (column.canSort) {\n                column.toggleSortBy = function(desc, multi) {\n                    return toggleSortBy(column.id, desc, multi);\n                };\n                column.clearSortBy = function() {\n                    dispatch({\n                        type: actions.clearSortBy,\n                        columnId: column.id\n                    });\n                };\n            }\n            column.getSortByToggleProps = makePropGetter(getHooks().getSortByToggleProps, {\n                instance: getInstance(),\n                column: column\n            });\n            var columnSort = sortBy.find(function(d) {\n                return d.id === id;\n            });\n            column.isSorted = !!columnSort;\n            column.sortedIndex = sortBy.findIndex(function(d) {\n                return d.id === id;\n            });\n            column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualSortBy || !sortBy.length) {\n                return [\n                    rows,\n                    flatRows\n                ];\n            }\n            var sortedFlatRows = []; // Filter out sortBys that correspond to non existing columns\n            var availableSortBy = sortBy.filter(function(sort) {\n                return allColumns.find(function(col) {\n                    return col.id === sort.id;\n                });\n            });\n            var sortData = function sortData(rows) {\n                // Use the orderByFn to compose multiple sortBy's together.\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                var sortedData = orderByFn(rows, availableSortBy.map(function(sort) {\n                    // Support custom sorting methods for each column\n                    var column = allColumns.find(function(d) {\n                        return d.id === sort.id;\n                    });\n                    if (!column) {\n                        throw new Error(\"React-Table: Could not find a column with id: \" + sort.id + \" while sorting\");\n                    }\n                    var sortType = column.sortType; // Look up sortBy functions in this order:\n                    // column function\n                    // column string lookup on user sortType\n                    // column string lookup on built-in sortType\n                    // default function\n                    // default string lookup on user sortType\n                    // default string lookup on built-in sortType\n                    var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n                    if (!sortMethod) {\n                        throw new Error(\"React-Table: Could not find a valid sortType of '\" + sortType + \"' for column '\" + sort.id + \"'.\");\n                    } // Return the correct sortFn.\n                    // This function should always return in ascending order\n                    return function(a, b) {\n                        return sortMethod(a, b, sort.id, sort.desc);\n                    };\n                }), availableSortBy.map(function(sort) {\n                    // Detect and use the sortInverted option\n                    var column = allColumns.find(function(d) {\n                        return d.id === sort.id;\n                    });\n                    if (column && column.sortInverted) {\n                        return sort.desc;\n                    }\n                    return !sort.desc;\n                })); // If there are sub-rows, sort them\n                sortedData.forEach(function(row) {\n                    sortedFlatRows.push(row);\n                    if (!row.subRows || row.subRows.length === 0) {\n                        return;\n                    }\n                    row.subRows = sortData(row.subRows);\n                });\n                return sortedData;\n            };\n            return [\n                sortData(rows),\n                sortedFlatRows\n            ];\n        }, [\n            manualSortBy,\n            sortBy,\n            rows,\n            flatRows,\n            allColumns,\n            orderByFn,\n            userSortTypes\n        ]), sortedRows = _React$useMemo[0], sortedFlatRows = _React$useMemo[1];\n        var getAutoResetSortBy = useGetLatest(autoResetSortBy);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetSortBy()) {\n                dispatch({\n                    type: actions.resetSortBy\n                });\n            }\n        }, [\n            manualSortBy ? null : data\n        ]);\n        Object.assign(instance, {\n            preSortedRows: rows,\n            preSortedFlatRows: flatRows,\n            sortedRows: sortedRows,\n            sortedFlatRows: sortedFlatRows,\n            rows: sortedRows,\n            flatRows: sortedFlatRows,\n            setSortBy: setSortBy,\n            toggleSortBy: toggleSortBy\n        });\n    }\n    function defaultOrderByFn(arr, funcs, dirs) {\n        return [].concat(arr).sort(function(rowA, rowB) {\n            for(var i = 0; i < funcs.length; i += 1){\n                var sortFn = funcs[i];\n                var desc = dirs[i] === false || dirs[i] === \"desc\";\n                var sortInt = sortFn(rowA, rowB);\n                if (sortInt !== 0) {\n                    return desc ? -sortInt : sortInt;\n                }\n            }\n            return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n        });\n    }\n    var pluginName = \"usePagination\"; // Actions\n    actions.resetPage = \"resetPage\";\n    actions.gotoPage = \"gotoPage\";\n    actions.setPageSize = \"setPageSize\";\n    var usePagination = function usePagination(hooks) {\n        hooks.stateReducers.push(reducer$6);\n        hooks.useInstance.push(useInstance$6);\n    };\n    usePagination.pluginName = pluginName;\n    function reducer$6(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                pageSize: 10,\n                pageIndex: 0\n            }, state);\n        }\n        if (action.type === actions.resetPage) {\n            return _extends({}, state, {\n                pageIndex: instance.initialState.pageIndex || 0\n            });\n        }\n        if (action.type === actions.gotoPage) {\n            var pageCount = instance.pageCount, page = instance.page;\n            var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);\n            var canNavigate = false;\n            if (newPageIndex > state.pageIndex) {\n                // next page\n                canNavigate = pageCount === -1 ? page.length >= state.pageSize : newPageIndex < pageCount;\n            } else if (newPageIndex < state.pageIndex) {\n                // prev page\n                canNavigate = newPageIndex > -1;\n            }\n            if (!canNavigate) {\n                return state;\n            }\n            return _extends({}, state, {\n                pageIndex: newPageIndex\n            });\n        }\n        if (action.type === actions.setPageSize) {\n            var pageSize = action.pageSize;\n            var topRowIndex = state.pageSize * state.pageIndex;\n            var pageIndex = Math.floor(topRowIndex / pageSize);\n            return _extends({}, state, {\n                pageIndex: pageIndex,\n                pageSize: pageSize\n            });\n        }\n    }\n    function useInstance$6(instance) {\n        var rows = instance.rows, _instance$autoResetPa = instance.autoResetPage, autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa, _instance$manualExpan = instance.manualExpandedKey, manualExpandedKey = _instance$manualExpan === void 0 ? \"expanded\" : _instance$manualExpan, plugins = instance.plugins, userPageCount = instance.pageCount, _instance$paginateExp = instance.paginateExpandedRows, paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp, _instance$expandSubRo = instance.expandSubRows, expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo, _instance$state = instance.state, pageSize = _instance$state.pageSize, pageIndex = _instance$state.pageIndex, expanded = _instance$state.expanded, globalFilter = _instance$state.globalFilter, filters = _instance$state.filters, groupBy = _instance$state.groupBy, sortBy = _instance$state.sortBy, dispatch = instance.dispatch, data = instance.data, manualPagination = instance.manualPagination;\n        ensurePluginOrder(plugins, [\n            \"useGlobalFilter\",\n            \"useFilters\",\n            \"useGroupBy\",\n            \"useSortBy\",\n            \"useExpanded\"\n        ], \"usePagination\");\n        var getAutoResetPage = useGetLatest(autoResetPage);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetPage()) {\n                dispatch({\n                    type: actions.resetPage\n                });\n            }\n        }, [\n            dispatch,\n            manualPagination ? null : data,\n            globalFilter,\n            filters,\n            groupBy,\n            sortBy\n        ]);\n        var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n        var pageOptions = React.useMemo(function() {\n            return pageCount > 0 ? [].concat(new Array(pageCount)).fill(null).map(function(d, i) {\n                return i;\n            }) : [];\n        }, [\n            pageCount\n        ]);\n        var page = React.useMemo(function() {\n            var page;\n            if (manualPagination) {\n                page = rows;\n            } else {\n                var pageStart = pageSize * pageIndex;\n                var pageEnd = pageStart + pageSize;\n                page = rows.slice(pageStart, pageEnd);\n            }\n            if (paginateExpandedRows) {\n                return page;\n            }\n            return expandRows(page, {\n                manualExpandedKey: manualExpandedKey,\n                expanded: expanded,\n                expandSubRows: expandSubRows\n            });\n        }, [\n            expandSubRows,\n            expanded,\n            manualExpandedKey,\n            manualPagination,\n            pageIndex,\n            pageSize,\n            paginateExpandedRows,\n            rows\n        ]);\n        var canPreviousPage = pageIndex > 0;\n        var canNextPage = pageCount === -1 ? page.length >= pageSize : pageIndex < pageCount - 1;\n        var gotoPage = React.useCallback(function(pageIndex) {\n            dispatch({\n                type: actions.gotoPage,\n                pageIndex: pageIndex\n            });\n        }, [\n            dispatch\n        ]);\n        var previousPage = React.useCallback(function() {\n            return gotoPage(function(old) {\n                return old - 1;\n            });\n        }, [\n            gotoPage\n        ]);\n        var nextPage = React.useCallback(function() {\n            return gotoPage(function(old) {\n                return old + 1;\n            });\n        }, [\n            gotoPage\n        ]);\n        var setPageSize = React.useCallback(function(pageSize) {\n            dispatch({\n                type: actions.setPageSize,\n                pageSize: pageSize\n            });\n        }, [\n            dispatch\n        ]);\n        Object.assign(instance, {\n            pageOptions: pageOptions,\n            pageCount: pageCount,\n            page: page,\n            canPreviousPage: canPreviousPage,\n            canNextPage: canNextPage,\n            gotoPage: gotoPage,\n            previousPage: previousPage,\n            nextPage: nextPage,\n            setPageSize: setPageSize\n        });\n    }\n    actions.resetPivot = \"resetPivot\";\n    actions.togglePivot = \"togglePivot\";\n    var _UNSTABLE_usePivotColumns = function _UNSTABLE_usePivotColumns(hooks) {\n        hooks.getPivotToggleProps = [\n            defaultGetPivotToggleProps\n        ];\n        hooks.stateReducers.push(reducer$7);\n        hooks.useInstanceAfterData.push(useInstanceAfterData);\n        hooks.allColumns.push(allColumns);\n        hooks.accessValue.push(accessValue);\n        hooks.materializedColumns.push(materializedColumns);\n        hooks.materializedColumnsDeps.push(materializedColumnsDeps);\n        hooks.visibleColumns.push(visibleColumns$1);\n        hooks.visibleColumnsDeps.push(visibleColumnsDeps);\n        hooks.useInstance.push(useInstance$7);\n        hooks.prepareRow.push(prepareRow$2);\n    };\n    _UNSTABLE_usePivotColumns.pluginName = \"usePivotColumns\";\n    var defaultPivotColumns = [];\n    var defaultGetPivotToggleProps = function defaultGetPivotToggleProps(props, _ref) {\n        var header = _ref.header;\n        return [\n            props,\n            {\n                onClick: header.canPivot ? function(e) {\n                    e.persist();\n                    header.togglePivot();\n                } : undefined,\n                style: {\n                    cursor: header.canPivot ? \"pointer\" : undefined\n                },\n                title: \"Toggle Pivot\"\n            }\n        ];\n    }; // Reducer\n    function reducer$7(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                pivotColumns: defaultPivotColumns\n            }, state);\n        }\n        if (action.type === actions.resetPivot) {\n            return _extends({}, state, {\n                pivotColumns: instance.initialState.pivotColumns || defaultPivotColumns\n            });\n        }\n        if (action.type === actions.togglePivot) {\n            var columnId = action.columnId, setPivot = action.value;\n            var resolvedPivot = typeof setPivot !== \"undefined\" ? setPivot : !state.pivotColumns.includes(columnId);\n            if (resolvedPivot) {\n                return _extends({}, state, {\n                    pivotColumns: [].concat(state.pivotColumns, [\n                        columnId\n                    ])\n                });\n            }\n            return _extends({}, state, {\n                pivotColumns: state.pivotColumns.filter(function(d) {\n                    return d !== columnId;\n                })\n            });\n        }\n    }\n    function useInstanceAfterData(instance) {\n        instance.allColumns.forEach(function(column) {\n            column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n        });\n    }\n    function allColumns(columns, _ref2) {\n        var instance = _ref2.instance;\n        columns.forEach(function(column) {\n            column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n            column.uniqueValues = new Set();\n        });\n        return columns;\n    }\n    function accessValue(value, _ref3) {\n        var column = _ref3.column;\n        if (column.uniqueValues && typeof value !== \"undefined\") {\n            column.uniqueValues.add(value);\n        }\n        return value;\n    }\n    function materializedColumns(materialized, _ref4) {\n        var instance = _ref4.instance;\n        var allColumns = instance.allColumns, state = instance.state;\n        if (!state.pivotColumns.length || !state.groupBy || !state.groupBy.length) {\n            return materialized;\n        }\n        var pivotColumns = state.pivotColumns.map(function(id) {\n            return allColumns.find(function(d) {\n                return d.id === id;\n            });\n        }).filter(Boolean);\n        var sourceColumns = allColumns.filter(function(d) {\n            return !d.isPivotSource && !state.groupBy.includes(d.id) && !state.pivotColumns.includes(d.id);\n        });\n        var buildPivotColumns = function buildPivotColumns(depth, parent, pivotFilters) {\n            if (depth === void 0) {\n                depth = 0;\n            }\n            if (pivotFilters === void 0) {\n                pivotFilters = [];\n            }\n            var pivotColumn = pivotColumns[depth];\n            if (!pivotColumn) {\n                return sourceColumns.map(function(sourceColumn) {\n                    // TODO: We could offer support here for renesting pivoted\n                    // columns inside copies of their header groups. For now,\n                    // that seems like it would be (1) overkill on nesting, considering\n                    // you already get nesting for every pivot level and (2)\n                    // really hard. :)\n                    return _extends({}, sourceColumn, {\n                        canPivot: false,\n                        isPivoted: true,\n                        parent: parent,\n                        depth: depth,\n                        id: \"\" + (parent ? parent.id + \".\" + sourceColumn.id : sourceColumn.id),\n                        accessor: function accessor(originalRow, i, row) {\n                            if (pivotFilters.every(function(filter) {\n                                return filter(row);\n                            })) {\n                                return row.values[sourceColumn.id];\n                            }\n                        }\n                    });\n                });\n            }\n            var uniqueValues = Array.from(pivotColumn.uniqueValues).sort();\n            return uniqueValues.map(function(uniqueValue) {\n                var columnGroup = _extends({}, pivotColumn, {\n                    Header: pivotColumn.PivotHeader || typeof pivotColumn.header === \"string\" ? pivotColumn.Header + \": \" + uniqueValue : uniqueValue,\n                    isPivotGroup: true,\n                    parent: parent,\n                    depth: depth,\n                    id: parent ? parent.id + \".\" + pivotColumn.id + \".\" + uniqueValue : pivotColumn.id + \".\" + uniqueValue,\n                    pivotValue: uniqueValue\n                });\n                columnGroup.columns = buildPivotColumns(depth + 1, columnGroup, [].concat(pivotFilters, [\n                    function(row) {\n                        return row.values[pivotColumn.id] === uniqueValue;\n                    }\n                ]));\n                return columnGroup;\n            });\n        };\n        var newMaterialized = flattenColumns(buildPivotColumns());\n        return [].concat(materialized, newMaterialized);\n    }\n    function materializedColumnsDeps(deps, _ref5) {\n        var _ref5$instance$state = _ref5.instance.state, pivotColumns = _ref5$instance$state.pivotColumns, groupBy = _ref5$instance$state.groupBy;\n        return [].concat(deps, [\n            pivotColumns,\n            groupBy\n        ]);\n    }\n    function visibleColumns$1(visibleColumns, _ref6) {\n        var state = _ref6.instance.state;\n        visibleColumns = visibleColumns.filter(function(d) {\n            return !d.isPivotSource;\n        });\n        if (state.pivotColumns.length && state.groupBy && state.groupBy.length) {\n            visibleColumns = visibleColumns.filter(function(column) {\n                return column.isGrouped || column.isPivoted;\n            });\n        }\n        return visibleColumns;\n    }\n    function visibleColumnsDeps(deps, _ref7) {\n        var instance = _ref7.instance;\n        return [].concat(deps, [\n            instance.state.pivotColumns,\n            instance.state.groupBy\n        ]);\n    }\n    function useInstance$7(instance) {\n        var columns = instance.columns, allColumns = instance.allColumns, flatHeaders = instance.flatHeaders, getHooks = instance.getHooks, plugins = instance.plugins, dispatch = instance.dispatch, _instance$autoResetPi = instance.autoResetPivot, autoResetPivot = _instance$autoResetPi === void 0 ? true : _instance$autoResetPi, manaulPivot = instance.manaulPivot, disablePivot = instance.disablePivot, defaultCanPivot = instance.defaultCanPivot;\n        ensurePluginOrder(plugins, [\n            \"useGroupBy\"\n        ], \"usePivotColumns\");\n        var getInstance = useGetLatest(instance);\n        allColumns.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnPivot = column.defaultPivot, columnDisablePivot = column.disablePivot;\n            column.canPivot = accessor ? getFirstDefined(column.canPivot, columnDisablePivot === true ? false : undefined, disablePivot === true ? false : undefined, true) : getFirstDefined(column.canPivot, defaultColumnPivot, defaultCanPivot, false);\n            if (column.canPivot) {\n                column.togglePivot = function() {\n                    return instance.togglePivot(column.id);\n                };\n            }\n            column.Aggregated = column.Aggregated || column.Cell;\n        });\n        var togglePivot = function togglePivot(columnId, value) {\n            dispatch({\n                type: actions.togglePivot,\n                columnId: columnId,\n                value: value\n            });\n        };\n        flatHeaders.forEach(function(header) {\n            header.getPivotToggleProps = makePropGetter(getHooks().getPivotToggleProps, {\n                instance: getInstance(),\n                header: header\n            });\n        });\n        var getAutoResetPivot = useGetLatest(autoResetPivot);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetPivot()) {\n                dispatch({\n                    type: actions.resetPivot\n                });\n            }\n        }, [\n            dispatch,\n            manaulPivot ? null : columns\n        ]);\n        Object.assign(instance, {\n            togglePivot: togglePivot\n        });\n    }\n    function prepareRow$2(row) {\n        row.allCells.forEach(function(cell) {\n            // Grouped cells are in the pivotColumns and the pivot cell for the row\n            cell.isPivoted = cell.column.isPivoted;\n        });\n    }\n    var pluginName$1 = \"useRowSelect\"; // Actions\n    actions.resetSelectedRows = \"resetSelectedRows\";\n    actions.toggleAllRowsSelected = \"toggleAllRowsSelected\";\n    actions.toggleRowSelected = \"toggleRowSelected\";\n    actions.toggleAllPageRowsSelected = \"toggleAllPageRowsSelected\";\n    var useRowSelect = function useRowSelect(hooks) {\n        hooks.getToggleRowSelectedProps = [\n            defaultGetToggleRowSelectedProps\n        ];\n        hooks.getToggleAllRowsSelectedProps = [\n            defaultGetToggleAllRowsSelectedProps\n        ];\n        hooks.getToggleAllPageRowsSelectedProps = [\n            defaultGetToggleAllPageRowsSelectedProps\n        ];\n        hooks.stateReducers.push(reducer$8);\n        hooks.useInstance.push(useInstance$8);\n        hooks.prepareRow.push(prepareRow$3);\n    };\n    useRowSelect.pluginName = pluginName$1;\n    var defaultGetToggleRowSelectedProps = function defaultGetToggleRowSelectedProps(props, _ref) {\n        var instance = _ref.instance, row = _ref.row;\n        var _instance$manualRowSe = instance.manualRowSelectedKey, manualRowSelectedKey = _instance$manualRowSe === void 0 ? \"isSelected\" : _instance$manualRowSe;\n        var checked = false;\n        if (row.original && row.original[manualRowSelectedKey]) {\n            checked = true;\n        } else {\n            checked = row.isSelected;\n        }\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    row.toggleRowSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: checked,\n                title: \"Toggle Row Selected\",\n                indeterminate: row.isSomeSelected\n            }\n        ];\n    };\n    var defaultGetToggleAllRowsSelectedProps = function defaultGetToggleAllRowsSelectedProps(props, _ref2) {\n        var instance = _ref2.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleAllRowsSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: instance.isAllRowsSelected,\n                title: \"Toggle All Rows Selected\",\n                indeterminate: Boolean(!instance.isAllRowsSelected && Object.keys(instance.state.selectedRowIds).length)\n            }\n        ];\n    };\n    var defaultGetToggleAllPageRowsSelectedProps = function defaultGetToggleAllPageRowsSelectedProps(props, _ref3) {\n        var instance = _ref3.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleAllPageRowsSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: instance.isAllPageRowsSelected,\n                title: \"Toggle All Current Page Rows Selected\",\n                indeterminate: Boolean(!instance.isAllPageRowsSelected && instance.page.some(function(_ref4) {\n                    var id = _ref4.id;\n                    return instance.state.selectedRowIds[id];\n                }))\n            }\n        ];\n    }; // eslint-disable-next-line max-params\n    function reducer$8(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                selectedRowIds: {}\n            }, state);\n        }\n        if (action.type === actions.resetSelectedRows) {\n            return _extends({}, state, {\n                selectedRowIds: instance.initialState.selectedRowIds || {}\n            });\n        }\n        if (action.type === actions.toggleAllRowsSelected) {\n            var setSelected = action.value;\n            var isAllRowsSelected = instance.isAllRowsSelected, rowsById = instance.rowsById, _instance$nonGroupedR = instance.nonGroupedRowsById, nonGroupedRowsById = _instance$nonGroupedR === void 0 ? rowsById : _instance$nonGroupedR;\n            var selectAll = typeof setSelected !== \"undefined\" ? setSelected : !isAllRowsSelected; // Only remove/add the rows that are visible on the screen\n            //  Leave all the other rows that are selected alone.\n            var selectedRowIds = Object.assign({}, state.selectedRowIds);\n            if (selectAll) {\n                Object.keys(nonGroupedRowsById).forEach(function(rowId) {\n                    selectedRowIds[rowId] = true;\n                });\n            } else {\n                Object.keys(nonGroupedRowsById).forEach(function(rowId) {\n                    delete selectedRowIds[rowId];\n                });\n            }\n            return _extends({}, state, {\n                selectedRowIds: selectedRowIds\n            });\n        }\n        if (action.type === actions.toggleRowSelected) {\n            var id = action.id, _setSelected = action.value;\n            var _rowsById = instance.rowsById, _instance$selectSubRo = instance.selectSubRows, selectSubRows = _instance$selectSubRo === void 0 ? true : _instance$selectSubRo, getSubRows = instance.getSubRows;\n            var isSelected = state.selectedRowIds[id];\n            var shouldExist = typeof _setSelected !== \"undefined\" ? _setSelected : !isSelected;\n            if (isSelected === shouldExist) {\n                return state;\n            }\n            var newSelectedRowIds = _extends({}, state.selectedRowIds);\n            var handleRowById = function handleRowById(id) {\n                var row = _rowsById[id];\n                if (row) {\n                    if (!row.isGrouped) {\n                        if (shouldExist) {\n                            newSelectedRowIds[id] = true;\n                        } else {\n                            delete newSelectedRowIds[id];\n                        }\n                    }\n                    if (selectSubRows && getSubRows(row)) {\n                        return getSubRows(row).forEach(function(row) {\n                            return handleRowById(row.id);\n                        });\n                    }\n                }\n            };\n            handleRowById(id);\n            return _extends({}, state, {\n                selectedRowIds: newSelectedRowIds\n            });\n        }\n        if (action.type === actions.toggleAllPageRowsSelected) {\n            var _setSelected2 = action.value;\n            var page = instance.page, _rowsById2 = instance.rowsById, _instance$selectSubRo2 = instance.selectSubRows, _selectSubRows = _instance$selectSubRo2 === void 0 ? true : _instance$selectSubRo2, isAllPageRowsSelected = instance.isAllPageRowsSelected, _getSubRows = instance.getSubRows;\n            var _selectAll = typeof _setSelected2 !== \"undefined\" ? _setSelected2 : !isAllPageRowsSelected;\n            var _newSelectedRowIds = _extends({}, state.selectedRowIds);\n            var _handleRowById = function _handleRowById(id) {\n                var row = _rowsById2[id];\n                if (!row.isGrouped) {\n                    if (_selectAll) {\n                        _newSelectedRowIds[id] = true;\n                    } else {\n                        delete _newSelectedRowIds[id];\n                    }\n                }\n                if (_selectSubRows && _getSubRows(row)) {\n                    return _getSubRows(row).forEach(function(row) {\n                        return _handleRowById(row.id);\n                    });\n                }\n            };\n            page.forEach(function(row) {\n                return _handleRowById(row.id);\n            });\n            return _extends({}, state, {\n                selectedRowIds: _newSelectedRowIds\n            });\n        }\n        return state;\n    }\n    function useInstance$8(instance) {\n        var data = instance.data, rows = instance.rows, getHooks = instance.getHooks, plugins = instance.plugins, rowsById = instance.rowsById, _instance$nonGroupedR2 = instance.nonGroupedRowsById, nonGroupedRowsById = _instance$nonGroupedR2 === void 0 ? rowsById : _instance$nonGroupedR2, _instance$autoResetSe = instance.autoResetSelectedRows, autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe, selectedRowIds = instance.state.selectedRowIds, _instance$selectSubRo3 = instance.selectSubRows, selectSubRows = _instance$selectSubRo3 === void 0 ? true : _instance$selectSubRo3, dispatch = instance.dispatch, page = instance.page, getSubRows = instance.getSubRows;\n        ensurePluginOrder(plugins, [\n            \"useFilters\",\n            \"useGroupBy\",\n            \"useSortBy\",\n            \"useExpanded\",\n            \"usePagination\"\n        ], \"useRowSelect\");\n        var selectedFlatRows = React.useMemo(function() {\n            var selectedFlatRows = [];\n            rows.forEach(function(row) {\n                var isSelected = selectSubRows ? getRowIsSelected(row, selectedRowIds, getSubRows) : !!selectedRowIds[row.id];\n                row.isSelected = !!isSelected;\n                row.isSomeSelected = isSelected === null;\n                if (isSelected) {\n                    selectedFlatRows.push(row);\n                }\n            });\n            return selectedFlatRows;\n        }, [\n            rows,\n            selectSubRows,\n            selectedRowIds,\n            getSubRows\n        ]);\n        var isAllRowsSelected = Boolean(Object.keys(nonGroupedRowsById).length && Object.keys(selectedRowIds).length);\n        var isAllPageRowsSelected = isAllRowsSelected;\n        if (isAllRowsSelected) {\n            if (Object.keys(nonGroupedRowsById).some(function(id) {\n                return !selectedRowIds[id];\n            })) {\n                isAllRowsSelected = false;\n            }\n        }\n        if (!isAllRowsSelected) {\n            if (page && page.length && page.some(function(_ref5) {\n                var id = _ref5.id;\n                return !selectedRowIds[id];\n            })) {\n                isAllPageRowsSelected = false;\n            }\n        }\n        var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetSelectedRows()) {\n                dispatch({\n                    type: actions.resetSelectedRows\n                });\n            }\n        }, [\n            dispatch,\n            data\n        ]);\n        var toggleAllRowsSelected = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllRowsSelected,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleAllPageRowsSelected = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllPageRowsSelected,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleRowSelected = React.useCallback(function(id, value) {\n            return dispatch({\n                type: actions.toggleRowSelected,\n                id: id,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getInstance = useGetLatest(instance);\n        var getToggleAllRowsSelectedProps = makePropGetter(getHooks().getToggleAllRowsSelectedProps, {\n            instance: getInstance()\n        });\n        var getToggleAllPageRowsSelectedProps = makePropGetter(getHooks().getToggleAllPageRowsSelectedProps, {\n            instance: getInstance()\n        });\n        Object.assign(instance, {\n            selectedFlatRows: selectedFlatRows,\n            isAllRowsSelected: isAllRowsSelected,\n            isAllPageRowsSelected: isAllPageRowsSelected,\n            toggleRowSelected: toggleRowSelected,\n            toggleAllRowsSelected: toggleAllRowsSelected,\n            getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,\n            getToggleAllPageRowsSelectedProps: getToggleAllPageRowsSelectedProps,\n            toggleAllPageRowsSelected: toggleAllPageRowsSelected\n        });\n    }\n    function prepareRow$3(row, _ref6) {\n        var instance = _ref6.instance;\n        row.toggleRowSelected = function(set) {\n            return instance.toggleRowSelected(row.id, set);\n        };\n        row.getToggleRowSelectedProps = makePropGetter(instance.getHooks().getToggleRowSelectedProps, {\n            instance: instance,\n            row: row\n        });\n    }\n    function getRowIsSelected(row, selectedRowIds, getSubRows) {\n        if (selectedRowIds[row.id]) {\n            return true;\n        }\n        var subRows = getSubRows(row);\n        if (subRows && subRows.length) {\n            var allChildrenSelected = true;\n            var someSelected = false;\n            subRows.forEach(function(subRow) {\n                // Bail out early if we know both of these\n                if (someSelected && !allChildrenSelected) {\n                    return;\n                }\n                if (getRowIsSelected(subRow, selectedRowIds, getSubRows)) {\n                    someSelected = true;\n                } else {\n                    allChildrenSelected = false;\n                }\n            });\n            return allChildrenSelected ? true : someSelected ? null : false;\n        }\n        return false;\n    }\n    var defaultInitialRowStateAccessor = function defaultInitialRowStateAccessor(row) {\n        return {};\n    };\n    var defaultInitialCellStateAccessor = function defaultInitialCellStateAccessor(cell) {\n        return {};\n    }; // Actions\n    actions.setRowState = \"setRowState\";\n    actions.setCellState = \"setCellState\";\n    actions.resetRowState = \"resetRowState\";\n    var useRowState = function useRowState(hooks) {\n        hooks.stateReducers.push(reducer$9);\n        hooks.useInstance.push(useInstance$9);\n        hooks.prepareRow.push(prepareRow$4);\n    };\n    useRowState.pluginName = \"useRowState\";\n    function reducer$9(state, action, previousState, instance) {\n        var _instance$initialRowS = instance.initialRowStateAccessor, initialRowStateAccessor = _instance$initialRowS === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS, _instance$initialCell = instance.initialCellStateAccessor, initialCellStateAccessor = _instance$initialCell === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell, rowsById = instance.rowsById;\n        if (action.type === actions.init) {\n            return _extends({\n                rowState: {}\n            }, state);\n        }\n        if (action.type === actions.resetRowState) {\n            return _extends({}, state, {\n                rowState: instance.initialState.rowState || {}\n            });\n        }\n        if (action.type === actions.setRowState) {\n            var _extends2;\n            var rowId = action.rowId, value = action.value;\n            var oldRowState = typeof state.rowState[rowId] !== \"undefined\" ? state.rowState[rowId] : initialRowStateAccessor(rowsById[rowId]);\n            return _extends({}, state, {\n                rowState: _extends({}, state.rowState, (_extends2 = {}, _extends2[rowId] = functionalUpdate(value, oldRowState), _extends2))\n            });\n        }\n        if (action.type === actions.setCellState) {\n            var _oldRowState$cellStat, _rowsById$_rowId, _rowsById$_rowId$cell, _extends3, _extends4;\n            var _rowId = action.rowId, columnId = action.columnId, _value = action.value;\n            var _oldRowState = typeof state.rowState[_rowId] !== \"undefined\" ? state.rowState[_rowId] : initialRowStateAccessor(rowsById[_rowId]);\n            var oldCellState = typeof (_oldRowState == null ? void 0 : (_oldRowState$cellStat = _oldRowState.cellState) == null ? void 0 : _oldRowState$cellStat[columnId]) !== \"undefined\" ? _oldRowState.cellState[columnId] : initialCellStateAccessor((_rowsById$_rowId = rowsById[_rowId]) == null ? void 0 : (_rowsById$_rowId$cell = _rowsById$_rowId.cells) == null ? void 0 : _rowsById$_rowId$cell.find(function(cell) {\n                return cell.column.id === columnId;\n            }));\n            return _extends({}, state, {\n                rowState: _extends({}, state.rowState, (_extends4 = {}, _extends4[_rowId] = _extends({}, _oldRowState, {\n                    cellState: _extends({}, _oldRowState.cellState || {}, (_extends3 = {}, _extends3[columnId] = functionalUpdate(_value, oldCellState), _extends3))\n                }), _extends4))\n            });\n        }\n    }\n    function useInstance$9(instance) {\n        var _instance$autoResetRo = instance.autoResetRowState, autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo, data = instance.data, dispatch = instance.dispatch;\n        var setRowState = React.useCallback(function(rowId, value) {\n            return dispatch({\n                type: actions.setRowState,\n                rowId: rowId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setCellState = React.useCallback(function(rowId, columnId, value) {\n            return dispatch({\n                type: actions.setCellState,\n                rowId: rowId,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getAutoResetRowState = useGetLatest(autoResetRowState);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetRowState()) {\n                dispatch({\n                    type: actions.resetRowState\n                });\n            }\n        }, [\n            data\n        ]);\n        Object.assign(instance, {\n            setRowState: setRowState,\n            setCellState: setCellState\n        });\n    }\n    function prepareRow$4(row, _ref) {\n        var instance = _ref.instance;\n        var _instance$initialRowS2 = instance.initialRowStateAccessor, initialRowStateAccessor = _instance$initialRowS2 === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS2, _instance$initialCell2 = instance.initialCellStateAccessor, initialCellStateAccessor = _instance$initialCell2 === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell2, rowState = instance.state.rowState;\n        if (row) {\n            row.state = typeof rowState[row.id] !== \"undefined\" ? rowState[row.id] : initialRowStateAccessor(row);\n            row.setState = function(updater) {\n                return instance.setRowState(row.id, updater);\n            };\n            row.cells.forEach(function(cell) {\n                if (!row.state.cellState) {\n                    row.state.cellState = {};\n                }\n                cell.state = typeof row.state.cellState[cell.column.id] !== \"undefined\" ? row.state.cellState[cell.column.id] : initialCellStateAccessor(cell);\n                cell.setState = function(updater) {\n                    return instance.setCellState(row.id, cell.column.id, updater);\n                };\n            });\n        }\n    }\n    actions.resetColumnOrder = \"resetColumnOrder\";\n    actions.setColumnOrder = \"setColumnOrder\";\n    var useColumnOrder = function useColumnOrder(hooks) {\n        hooks.stateReducers.push(reducer$a);\n        hooks.visibleColumnsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.columnOrder\n            ]);\n        });\n        hooks.visibleColumns.push(visibleColumns$2);\n        hooks.useInstance.push(useInstance$a);\n    };\n    useColumnOrder.pluginName = \"useColumnOrder\";\n    function reducer$a(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                columnOrder: []\n            }, state);\n        }\n        if (action.type === actions.resetColumnOrder) {\n            return _extends({}, state, {\n                columnOrder: instance.initialState.columnOrder || []\n            });\n        }\n        if (action.type === actions.setColumnOrder) {\n            return _extends({}, state, {\n                columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)\n            });\n        }\n    }\n    function visibleColumns$2(columns, _ref2) {\n        var columnOrder = _ref2.instance.state.columnOrder;\n        // If there is no order, return the normal columns\n        if (!columnOrder || !columnOrder.length) {\n            return columns;\n        }\n        var columnOrderCopy = [].concat(columnOrder); // If there is an order, make a copy of the columns\n        var columnsCopy = [].concat(columns); // And make a new ordered array of the columns\n        var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n        var _loop = function _loop() {\n            var targetColumnId = columnOrderCopy.shift();\n            var foundIndex = columnsCopy.findIndex(function(d) {\n                return d.id === targetColumnId;\n            });\n            if (foundIndex > -1) {\n                columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n            }\n        };\n        while(columnsCopy.length && columnOrderCopy.length){\n            _loop();\n        } // If there are any columns left, add them to the end\n        return [].concat(columnsInOrder, columnsCopy);\n    }\n    function useInstance$a(instance) {\n        var dispatch = instance.dispatch;\n        instance.setColumnOrder = React.useCallback(function(columnOrder) {\n            return dispatch({\n                type: actions.setColumnOrder,\n                columnOrder: columnOrder\n            });\n        }, [\n            dispatch\n        ]);\n    }\n    defaultColumn.canResize = true; // Actions\n    actions.columnStartResizing = \"columnStartResizing\";\n    actions.columnResizing = \"columnResizing\";\n    actions.columnDoneResizing = \"columnDoneResizing\";\n    actions.resetResize = \"resetResize\";\n    var useResizeColumns = function useResizeColumns(hooks) {\n        hooks.getResizerProps = [\n            defaultGetResizerProps\n        ];\n        hooks.getHeaderProps.push({\n            style: {\n                position: \"relative\"\n            }\n        });\n        hooks.stateReducers.push(reducer$b);\n        hooks.useInstance.push(useInstance$b);\n        hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);\n    };\n    var defaultGetResizerProps = function defaultGetResizerProps(props, _ref) {\n        var instance = _ref.instance, header = _ref.header;\n        var dispatch = instance.dispatch;\n        var onResizeStart = function onResizeStart(e, header) {\n            var isTouchEvent = false;\n            if (e.type === \"touchstart\") {\n                // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                if (e.touches && e.touches.length > 1) {\n                    return;\n                }\n                isTouchEvent = true;\n            }\n            var headersToResize = getLeafHeaders(header);\n            var headerIdWidths = headersToResize.map(function(d) {\n                return [\n                    d.id,\n                    d.totalWidth\n                ];\n            });\n            var clientX = isTouchEvent ? Math.round(e.touches[0].clientX) : e.clientX;\n            var raf;\n            var mostRecentClientX;\n            var dispatchEnd = function dispatchEnd() {\n                window.cancelAnimationFrame(raf);\n                raf = null;\n                dispatch({\n                    type: actions.columnDoneResizing\n                });\n            };\n            var dispatchMove = function dispatchMove() {\n                window.cancelAnimationFrame(raf);\n                raf = null;\n                dispatch({\n                    type: actions.columnResizing,\n                    clientX: mostRecentClientX\n                });\n            };\n            var scheduleDispatchMoveOnNextAnimationFrame = function scheduleDispatchMoveOnNextAnimationFrame(clientXPos) {\n                mostRecentClientX = clientXPos;\n                if (!raf) {\n                    raf = window.requestAnimationFrame(dispatchMove);\n                }\n            };\n            var handlersAndEvents = {\n                mouse: {\n                    moveEvent: \"mousemove\",\n                    moveHandler: function moveHandler(e) {\n                        return scheduleDispatchMoveOnNextAnimationFrame(e.clientX);\n                    },\n                    upEvent: \"mouseup\",\n                    upHandler: function upHandler(e) {\n                        document.removeEventListener(\"mousemove\", handlersAndEvents.mouse.moveHandler);\n                        document.removeEventListener(\"mouseup\", handlersAndEvents.mouse.upHandler);\n                        dispatchEnd();\n                    }\n                },\n                touch: {\n                    moveEvent: \"touchmove\",\n                    moveHandler: function moveHandler(e) {\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        scheduleDispatchMoveOnNextAnimationFrame(e.touches[0].clientX);\n                        return false;\n                    },\n                    upEvent: \"touchend\",\n                    upHandler: function upHandler(e) {\n                        document.removeEventListener(handlersAndEvents.touch.moveEvent, handlersAndEvents.touch.moveHandler);\n                        document.removeEventListener(handlersAndEvents.touch.upEvent, handlersAndEvents.touch.moveHandler);\n                        dispatchEnd();\n                    }\n                }\n            };\n            var events = isTouchEvent ? handlersAndEvents.touch : handlersAndEvents.mouse;\n            var passiveIfSupported = passiveEventSupported() ? {\n                passive: false\n            } : false;\n            document.addEventListener(events.moveEvent, events.moveHandler, passiveIfSupported);\n            document.addEventListener(events.upEvent, events.upHandler, passiveIfSupported);\n            dispatch({\n                type: actions.columnStartResizing,\n                columnId: header.id,\n                columnWidth: header.totalWidth,\n                headerIdWidths: headerIdWidths,\n                clientX: clientX\n            });\n        };\n        return [\n            props,\n            {\n                onMouseDown: function onMouseDown(e) {\n                    return e.persist() || onResizeStart(e, header);\n                },\n                onTouchStart: function onTouchStart(e) {\n                    return e.persist() || onResizeStart(e, header);\n                },\n                style: {\n                    cursor: \"col-resize\"\n                },\n                draggable: false,\n                role: \"separator\"\n            }\n        ];\n    };\n    useResizeColumns.pluginName = \"useResizeColumns\";\n    function reducer$b(state, action) {\n        if (action.type === actions.init) {\n            return _extends({\n                columnResizing: {\n                    columnWidths: {}\n                }\n            }, state);\n        }\n        if (action.type === actions.resetResize) {\n            return _extends({}, state, {\n                columnResizing: {\n                    columnWidths: {}\n                }\n            });\n        }\n        if (action.type === actions.columnStartResizing) {\n            var clientX = action.clientX, columnId = action.columnId, columnWidth = action.columnWidth, headerIdWidths = action.headerIdWidths;\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    startX: clientX,\n                    headerIdWidths: headerIdWidths,\n                    columnWidth: columnWidth,\n                    isResizingColumn: columnId\n                })\n            });\n        }\n        if (action.type === actions.columnResizing) {\n            var _clientX = action.clientX;\n            var _state$columnResizing = state.columnResizing, startX = _state$columnResizing.startX, _columnWidth = _state$columnResizing.columnWidth, _state$columnResizing2 = _state$columnResizing.headerIdWidths, _headerIdWidths = _state$columnResizing2 === void 0 ? [] : _state$columnResizing2;\n            var deltaX = _clientX - startX;\n            var percentageDeltaX = deltaX / _columnWidth;\n            var newColumnWidths = {};\n            _headerIdWidths.forEach(function(_ref2) {\n                var headerId = _ref2[0], headerWidth = _ref2[1];\n                newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);\n            });\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    columnWidths: _extends({}, state.columnResizing.columnWidths, {}, newColumnWidths)\n                })\n            });\n        }\n        if (action.type === actions.columnDoneResizing) {\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    startX: null,\n                    isResizingColumn: null\n                })\n            });\n        }\n    }\n    var useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {\n        var flatHeaders = instance.flatHeaders, disableResizing = instance.disableResizing, getHooks = instance.getHooks, columnResizing = instance.state.columnResizing;\n        var getInstance = useGetLatest(instance);\n        flatHeaders.forEach(function(header) {\n            var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n            header.canResize = canResize;\n            header.width = columnResizing.columnWidths[header.id] || header.originalWidth || header.width;\n            header.isResizing = columnResizing.isResizingColumn === header.id;\n            if (canResize) {\n                header.getResizerProps = makePropGetter(getHooks().getResizerProps, {\n                    instance: getInstance(),\n                    header: header\n                });\n            }\n        });\n    };\n    function useInstance$b(instance) {\n        var plugins = instance.plugins, dispatch = instance.dispatch, _instance$autoResetRe = instance.autoResetResize, autoResetResize = _instance$autoResetRe === void 0 ? true : _instance$autoResetRe, columns = instance.columns;\n        ensurePluginOrder(plugins, [\n            \"useAbsoluteLayout\"\n        ], \"useResizeColumns\");\n        var getAutoResetResize = useGetLatest(autoResetResize);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetResize()) {\n                dispatch({\n                    type: actions.resetResize\n                });\n            }\n        }, [\n            columns\n        ]);\n        var resetResizing = React.useCallback(function() {\n            return dispatch({\n                type: actions.resetResize\n            });\n        }, [\n            dispatch\n        ]);\n        Object.assign(instance, {\n            resetResizing: resetResizing\n        });\n    }\n    function getLeafHeaders(header) {\n        var leafHeaders = [];\n        var recurseHeader = function recurseHeader(header) {\n            if (header.columns && header.columns.length) {\n                header.columns.map(recurseHeader);\n            }\n            leafHeaders.push(header);\n        };\n        recurseHeader(header);\n        return leafHeaders;\n    }\n    var cellStyles = {\n        position: \"absolute\",\n        top: 0\n    };\n    var useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n        hooks.getTableBodyProps.push(getRowStyles);\n        hooks.getRowProps.push(getRowStyles);\n        hooks.getHeaderGroupProps.push(getRowStyles);\n        hooks.getFooterGroupProps.push(getRowStyles);\n        hooks.getHeaderProps.push(function(props, _ref) {\n            var column = _ref.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: column.totalLeft + \"px\",\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getCellProps.push(function(props, _ref2) {\n            var cell = _ref2.cell;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: cell.column.totalLeft + \"px\",\n                        width: cell.column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getFooterProps.push(function(props, _ref3) {\n            var column = _ref3.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: column.totalLeft + \"px\",\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n    };\n    useAbsoluteLayout.pluginName = \"useAbsoluteLayout\";\n    var getRowStyles = function getRowStyles(props, _ref4) {\n        var instance = _ref4.instance;\n        return [\n            props,\n            {\n                style: {\n                    position: \"relative\",\n                    width: instance.totalColumnsWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var cellStyles$1 = {\n        display: \"inline-block\",\n        boxSizing: \"border-box\"\n    };\n    var getRowStyles$1 = function getRowStyles(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                style: {\n                    display: \"flex\",\n                    width: instance.totalColumnsWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var useBlockLayout = function useBlockLayout(hooks) {\n        hooks.getRowProps.push(getRowStyles$1);\n        hooks.getHeaderGroupProps.push(getRowStyles$1);\n        hooks.getFooterGroupProps.push(getRowStyles$1);\n        hooks.getHeaderProps.push(function(props, _ref2) {\n            var column = _ref2.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getCellProps.push(function(props, _ref3) {\n            var cell = _ref3.cell;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: cell.column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getFooterProps.push(function(props, _ref4) {\n            var column = _ref4.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n    };\n    useBlockLayout.pluginName = \"useBlockLayout\";\n    function useFlexLayout(hooks) {\n        hooks.getTableProps.push(getTableProps);\n        hooks.getRowProps.push(getRowStyles$2);\n        hooks.getHeaderGroupProps.push(getRowStyles$2);\n        hooks.getFooterGroupProps.push(getRowStyles$2);\n        hooks.getHeaderProps.push(getHeaderProps);\n        hooks.getCellProps.push(getCellProps);\n        hooks.getFooterProps.push(getFooterProps);\n    }\n    useFlexLayout.pluginName = \"useFlexLayout\";\n    var getTableProps = function getTableProps(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                style: {\n                    minWidth: instance.totalColumnsMinWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getRowStyles$2 = function getRowStyles(props, _ref2) {\n        var instance = _ref2.instance;\n        return [\n            props,\n            {\n                style: {\n                    display: \"flex\",\n                    flex: \"1 0 auto\",\n                    minWidth: instance.totalColumnsMinWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getHeaderProps = function getHeaderProps(props, _ref3) {\n        var column = _ref3.column;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n                    minWidth: column.totalMinWidth + \"px\",\n                    width: column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getCellProps = function getCellProps(props, _ref4) {\n        var cell = _ref4.cell;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: cell.column.totalFlexWidth + \" 0 auto\",\n                    minWidth: cell.column.totalMinWidth + \"px\",\n                    width: cell.column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getFooterProps = function getFooterProps(props, _ref5) {\n        var column = _ref5.column;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n                    minWidth: column.totalMinWidth + \"px\",\n                    width: column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    actions.columnStartResizing = \"columnStartResizing\";\n    actions.columnResizing = \"columnResizing\";\n    actions.columnDoneResizing = \"columnDoneResizing\";\n    actions.resetResize = \"resetResize\";\n    function useGridLayout(hooks) {\n        hooks.stateReducers.push(reducer$c);\n        hooks.getTableProps.push(getTableProps$1);\n        hooks.getHeaderProps.push(getHeaderProps$1);\n        hooks.getRowProps.push(getRowProps);\n    }\n    useGridLayout.pluginName = \"useGridLayout\";\n    var getTableProps$1 = function getTableProps(props, _ref) {\n        var instance = _ref.instance;\n        var gridTemplateColumns = instance.visibleColumns.map(function(column) {\n            var _instance$state$colum;\n            if (instance.state.gridLayout.columnWidths[column.id]) return instance.state.gridLayout.columnWidths[column.id] + \"px\"; // When resizing, lock the width of all unset columns\n            // instead of using user-provided width or defaultColumn width,\n            // which could potentially be 'auto' or 'fr' units that don't scale linearly\n            if ((_instance$state$colum = instance.state.columnResizing) == null ? void 0 : _instance$state$colum.isResizingColumn) return instance.state.gridLayout.startWidths[column.id] + \"px\";\n            if (typeof column.width === \"number\") return column.width + \"px\";\n            return column.width;\n        });\n        return [\n            props,\n            {\n                style: {\n                    display: \"grid\",\n                    gridTemplateColumns: gridTemplateColumns.join(\" \")\n                }\n            }\n        ];\n    };\n    var getHeaderProps$1 = function getHeaderProps(props, _ref2) {\n        var column = _ref2.column;\n        return [\n            props,\n            {\n                id: \"header-cell-\" + column.id,\n                style: {\n                    position: \"sticky\",\n                    //enables a scroll wrapper to be placed around the table and have sticky headers\n                    gridColumn: \"span \" + column.totalVisibleHeaderCount\n                }\n            }\n        ];\n    };\n    var getRowProps = function getRowProps(props, _ref3) {\n        var row = _ref3.row;\n        if (row.isExpanded) {\n            return [\n                props,\n                {\n                    style: {\n                        gridColumn: \"1 / \" + (row.cells.length + 1)\n                    }\n                }\n            ];\n        }\n        return [\n            props,\n            {}\n        ];\n    };\n    function reducer$c(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                gridLayout: {\n                    columnWidths: {}\n                }\n            }, state);\n        }\n        if (action.type === actions.resetResize) {\n            return _extends({}, state, {\n                gridLayout: {\n                    columnWidths: {}\n                }\n            });\n        }\n        if (action.type === actions.columnStartResizing) {\n            var columnId = action.columnId, headerIdWidths = action.headerIdWidths;\n            var columnWidth = getElementWidth(columnId);\n            if (columnWidth !== undefined) {\n                var startWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends2;\n                    return _extends({}, acc, (_extends2 = {}, _extends2[column.id] = getElementWidth(column.id), _extends2));\n                }, {});\n                var minWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends3;\n                    return _extends({}, acc, (_extends3 = {}, _extends3[column.id] = column.minWidth, _extends3));\n                }, {});\n                var maxWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends4;\n                    return _extends({}, acc, (_extends4 = {}, _extends4[column.id] = column.maxWidth, _extends4));\n                }, {});\n                var headerIdGridWidths = headerIdWidths.map(function(_ref4) {\n                    var headerId = _ref4[0];\n                    return [\n                        headerId,\n                        getElementWidth(headerId)\n                    ];\n                });\n                return _extends({}, state, {\n                    gridLayout: _extends({}, state.gridLayout, {\n                        startWidths: startWidths,\n                        minWidths: minWidths,\n                        maxWidths: maxWidths,\n                        headerIdGridWidths: headerIdGridWidths,\n                        columnWidth: columnWidth\n                    })\n                });\n            } else {\n                return state;\n            }\n        }\n        if (action.type === actions.columnResizing) {\n            var clientX = action.clientX;\n            var startX = state.columnResizing.startX;\n            var _state$gridLayout = state.gridLayout, _columnWidth = _state$gridLayout.columnWidth, _minWidths = _state$gridLayout.minWidths, _maxWidths = _state$gridLayout.maxWidths, _state$gridLayout$hea = _state$gridLayout.headerIdGridWidths, _headerIdGridWidths = _state$gridLayout$hea === void 0 ? [] : _state$gridLayout$hea;\n            var deltaX = clientX - startX;\n            var percentageDeltaX = deltaX / _columnWidth;\n            var newColumnWidths = {};\n            _headerIdGridWidths.forEach(function(_ref5) {\n                var headerId = _ref5[0], headerWidth = _ref5[1];\n                newColumnWidths[headerId] = Math.min(Math.max(_minWidths[headerId], headerWidth + headerWidth * percentageDeltaX), _maxWidths[headerId]);\n            });\n            return _extends({}, state, {\n                gridLayout: _extends({}, state.gridLayout, {\n                    columnWidths: _extends({}, state.gridLayout.columnWidths, {}, newColumnWidths)\n                })\n            });\n        }\n        if (action.type === actions.columnDoneResizing) {\n            return _extends({}, state, {\n                gridLayout: _extends({}, state.gridLayout, {\n                    startWidths: {},\n                    minWidths: {},\n                    maxWidths: {}\n                })\n            });\n        }\n    }\n    function getElementWidth(columnId) {\n        var _document$getElementB;\n        var width = (_document$getElementB = document.getElementById(\"header-cell-\" + columnId)) == null ? void 0 : _document$getElementB.offsetWidth;\n        if (width !== undefined) {\n            return width;\n        }\n    }\n    exports1._UNSTABLE_usePivotColumns = _UNSTABLE_usePivotColumns;\n    exports1.actions = actions;\n    exports1.defaultColumn = defaultColumn;\n    exports1.defaultGroupByFn = defaultGroupByFn;\n    exports1.defaultOrderByFn = defaultOrderByFn;\n    exports1.defaultRenderer = defaultRenderer;\n    exports1.emptyRenderer = emptyRenderer;\n    exports1.ensurePluginOrder = ensurePluginOrder;\n    exports1.flexRender = flexRender;\n    exports1.functionalUpdate = functionalUpdate;\n    exports1.loopHooks = loopHooks;\n    exports1.makePropGetter = makePropGetter;\n    exports1.makeRenderer = makeRenderer;\n    exports1.reduceHooks = reduceHooks;\n    exports1.safeUseLayoutEffect = safeUseLayoutEffect;\n    exports1.useAbsoluteLayout = useAbsoluteLayout;\n    exports1.useAsyncDebounce = useAsyncDebounce;\n    exports1.useBlockLayout = useBlockLayout;\n    exports1.useColumnOrder = useColumnOrder;\n    exports1.useExpanded = useExpanded;\n    exports1.useFilters = useFilters;\n    exports1.useFlexLayout = useFlexLayout;\n    exports1.useGetLatest = useGetLatest;\n    exports1.useGlobalFilter = useGlobalFilter;\n    exports1.useGridLayout = useGridLayout;\n    exports1.useGroupBy = useGroupBy;\n    exports1.useMountedLayoutEffect = useMountedLayoutEffect;\n    exports1.usePagination = usePagination;\n    exports1.useResizeColumns = useResizeColumns;\n    exports1.useRowSelect = useRowSelect;\n    exports1.useRowState = useRowState;\n    exports1.useSortBy = useSortBy;\n    exports1.useTable = useTable;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=react-table.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0EsUUFBUUMsU0FBU0UsbUJBQU9BLENBQUMsNkdBQ3hGLENBQ3VFO0FBQ3pFLEdBQUUsSUFBSSxFQUFHLFNBQVVGLFFBQU8sRUFBRU8sS0FBSztJQUFJO0lBRW5DQSxRQUFRQSxTQUFTQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixPQUFPLGFBQWFBLEtBQUssQ0FBQyxVQUFVLEdBQUdBO0lBRTdGLFNBQVNLLG1CQUFtQkMsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUN2RSxJQUFJO1lBQ0YsSUFBSUMsT0FBT1AsR0FBRyxDQUFDSyxJQUFJLENBQUNDO1lBQ3BCLElBQUlFLFFBQVFELEtBQUtDLEtBQUs7UUFDeEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2RQLE9BQU9PO1lBQ1A7UUFDRjtRQUVBLElBQUlGLEtBQUtHLElBQUksRUFBRTtZQUNiVCxRQUFRTztRQUNWLE9BQU87WUFDTEcsUUFBUVYsT0FBTyxDQUFDTyxPQUFPSSxJQUFJLENBQUNULE9BQU9DO1FBQ3JDO0lBQ0Y7SUFFQSxTQUFTUyxrQkFBa0JDLEVBQUU7UUFDM0IsT0FBTztZQUNMLElBQUl0QixRQUFPLElBQUksRUFDWHVCLE9BQU9DO1lBQ1gsT0FBTyxJQUFJTCxRQUFRLFNBQVVWLE9BQU8sRUFBRUMsTUFBTTtnQkFDMUMsSUFBSUYsTUFBTWMsR0FBR0csS0FBSyxDQUFDekIsT0FBTXVCO2dCQUV6QixTQUFTWixNQUFNSyxLQUFLO29CQUNsQlQsbUJBQW1CQyxLQUFLQyxTQUFTQyxRQUFRQyxPQUFPQyxRQUFRLFFBQVFJO2dCQUNsRTtnQkFFQSxTQUFTSixPQUFPYyxHQUFHO29CQUNqQm5CLG1CQUFtQkMsS0FBS0MsU0FBU0MsUUFBUUMsT0FBT0MsUUFBUSxTQUFTYztnQkFDbkU7Z0JBRUFmLE1BQU1nQjtZQUNSO1FBQ0Y7SUFDRjtJQUVBLFNBQVNDO1FBQ1BBLFdBQVd6QixPQUFPMEIsTUFBTSxJQUFJLFNBQVVDLE1BQU07WUFDMUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlQLFVBQVVRLE1BQU0sRUFBRUQsSUFBSztnQkFDekMsSUFBSUUsU0FBU1QsU0FBUyxDQUFDTyxFQUFFO2dCQUV6QixJQUFLLElBQUlsQixPQUFPb0IsT0FBUTtvQkFDdEIsSUFBSTlCLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUMyQixRQUFRcEIsTUFBTTt3QkFDckRpQixNQUFNLENBQUNqQixJQUFJLEdBQUdvQixNQUFNLENBQUNwQixJQUFJO29CQUMzQjtnQkFDRjtZQUNGO1lBRUEsT0FBT2lCO1FBQ1Q7UUFFQSxPQUFPRixTQUFTSCxLQUFLLENBQUMsSUFBSSxFQUFFRDtJQUM5QjtJQUVBLFNBQVNVLDhCQUE4QkQsTUFBTSxFQUFFRSxRQUFRO1FBQ3JELElBQUlGLFVBQVUsTUFBTSxPQUFPLENBQUM7UUFDNUIsSUFBSUgsU0FBUyxDQUFDO1FBQ2QsSUFBSU0sYUFBYWpDLE9BQU9rQyxJQUFJLENBQUNKO1FBQzdCLElBQUlwQixLQUFLa0I7UUFFVCxJQUFLQSxJQUFJLEdBQUdBLElBQUlLLFdBQVdKLE1BQU0sRUFBRUQsSUFBSztZQUN0Q2xCLE1BQU11QixVQUFVLENBQUNMLEVBQUU7WUFDbkIsSUFBSUksU0FBU0csT0FBTyxDQUFDekIsUUFBUSxHQUFHO1lBQ2hDaUIsTUFBTSxDQUFDakIsSUFBSSxHQUFHb0IsTUFBTSxDQUFDcEIsSUFBSTtRQUMzQjtRQUVBLE9BQU9pQjtJQUNUO0lBRUEsU0FBU1MsYUFBYUMsS0FBSyxFQUFFQyxJQUFJO1FBQy9CLElBQUksT0FBT0QsVUFBVSxZQUFZQSxVQUFVLE1BQU0sT0FBT0E7UUFDeEQsSUFBSUUsT0FBT0YsS0FBSyxDQUFDRyxPQUFPQyxXQUFXLENBQUM7UUFFcEMsSUFBSUYsU0FBU2YsV0FBVztZQUN0QixJQUFJa0IsTUFBTUgsS0FBS3BDLElBQUksQ0FBQ2tDLE9BQU9DLFFBQVE7WUFDbkMsSUFBSSxPQUFPSSxRQUFRLFVBQVUsT0FBT0E7WUFDcEMsTUFBTSxJQUFJQyxVQUFVO1FBQ3RCO1FBRUEsT0FBTyxDQUFDTCxTQUFTLFdBQVdNLFNBQVNDLE1BQUssRUFBR1I7SUFDL0M7SUFFQSxTQUFTUyxlQUFlbkMsR0FBRztRQUN6QixJQUFJRCxNQUFNMEIsYUFBYXpCLEtBQUs7UUFFNUIsT0FBTyxPQUFPRCxRQUFRLFdBQVdBLE1BQU1rQyxPQUFPbEM7SUFDaEQ7SUFFQSxJQUFJcUMsWUFBWTtJQUNoQixJQUFJQyxVQUFVO1FBQ1pDLE1BQU07SUFDUjtJQUNBLElBQUlDLGtCQUFrQixTQUFTQSxnQkFBZ0JDLElBQUk7UUFDakQsSUFBSUMsYUFBYUQsS0FBS3RDLEtBQUssRUFDdkJBLFFBQVF1QyxlQUFlLEtBQUssSUFBSSxLQUFLQTtRQUN6QyxPQUFPdkM7SUFDVDtJQUNBLElBQUl3QyxnQkFBZ0IsU0FBU0E7UUFDM0IsT0FBT3RELE1BQU11RCxhQUFhLENBQUN2RCxNQUFNd0QsUUFBUSxFQUFFLE1BQU07SUFDbkQ7SUFDQSxJQUFJQyxnQkFBZ0I7UUFDbEJDLE1BQU1QO1FBQ05RLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxVQUFVZixPQUFPZ0IsZ0JBQWdCO0lBQ25DO0lBRUEsU0FBU0M7UUFDUCxJQUFLLElBQUlDLE9BQU8xQyxVQUFVUSxNQUFNLEVBQUVtQyxXQUFXLElBQUlDLE1BQU1GLE9BQU9HLE9BQU8sR0FBR0EsT0FBT0gsTUFBTUcsT0FBUTtZQUMzRkYsUUFBUSxDQUFDRSxLQUFLLEdBQUc3QyxTQUFTLENBQUM2QyxLQUFLO1FBQ2xDO1FBRUEsT0FBT0YsU0FBU0csTUFBTSxDQUFDLFNBQVVDLEtBQUssRUFBRUMsSUFBSTtZQUMxQyxJQUFJQyxRQUFRRCxLQUFLQyxLQUFLLEVBQ2xCQyxZQUFZRixLQUFLRSxTQUFTLEVBQzFCQyxPQUFPekMsOEJBQThCc0MsTUFBTTtnQkFBQztnQkFBUzthQUFZO1lBRXJFRCxRQUFRM0MsU0FBUyxDQUFDLEdBQUcyQyxPQUFPLENBQUMsR0FBR0k7WUFFaEMsSUFBSUYsT0FBTztnQkFDVEYsTUFBTUUsS0FBSyxHQUFHRixNQUFNRSxLQUFLLEdBQUc3QyxTQUFTLENBQUMsR0FBRzJDLE1BQU1FLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHQSxTQUFTLENBQUMsS0FBS0E7WUFDakY7WUFFQSxJQUFJQyxXQUFXO2dCQUNiSCxNQUFNRyxTQUFTLEdBQUdILE1BQU1HLFNBQVMsR0FBR0gsTUFBTUcsU0FBUyxHQUFHLE1BQU1BLFlBQVlBO1lBQzFFO1lBRUEsSUFBSUgsTUFBTUcsU0FBUyxLQUFLLElBQUk7Z0JBQzFCLE9BQU9ILE1BQU1HLFNBQVM7WUFDeEI7WUFFQSxPQUFPSDtRQUNULEdBQUcsQ0FBQztJQUNOO0lBRUEsU0FBU0ssaUJBQWlCQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsSUFBSTtRQUNsRCw4Q0FBOEM7UUFDOUMsSUFBSSxPQUFPRCxjQUFjLFlBQVk7WUFDbkMsT0FBT0YsaUJBQWlCLENBQUMsR0FBR0UsVUFBVUQsV0FBV0U7UUFDbkQsRUFBRSxxREFBcUQ7UUFHdkQsSUFBSVgsTUFBTVksT0FBTyxDQUFDRixZQUFZO1lBQzVCLE9BQU9iLFdBQVd4QyxLQUFLLENBQUMsS0FBSyxHQUFHO2dCQUFDb0Q7YUFBVSxDQUFDSSxNQUFNLENBQUNIO1FBQ3JELEVBQUUscURBQXFEO1FBR3ZELE9BQU9iLFdBQVdZLFdBQVdDO0lBQy9CO0lBRUEsSUFBSUksaUJBQWlCLFNBQVNBLGVBQWVDLEtBQUssRUFBRUosSUFBSTtRQUN0RCxJQUFJQSxTQUFTLEtBQUssR0FBRztZQUNuQkEsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxPQUFPLFNBQVVELFNBQVM7WUFDeEIsSUFBSUEsY0FBYyxLQUFLLEdBQUc7Z0JBQ3hCQSxZQUFZLENBQUM7WUFDZjtZQUVBLE9BQU8sRUFBRSxDQUFDRyxNQUFNLENBQUNFLE9BQU87Z0JBQUNMO2FBQVUsRUFBRVIsTUFBTSxDQUFDLFNBQVVjLElBQUksRUFBRVosSUFBSTtnQkFDOUQsT0FBT0ksaUJBQWlCUSxNQUFNWixNQUFNNUMsU0FBUyxDQUFDLEdBQUdtRCxNQUFNO29CQUNyREQsV0FBV0E7Z0JBQ2I7WUFDRixHQUFHLENBQUM7UUFDTjtJQUNGO0lBQ0EsSUFBSU8sY0FBYyxTQUFTQSxZQUFZRixLQUFLLEVBQUVHLE9BQU8sRUFBRVAsSUFBSSxFQUFFUSxjQUFjO1FBQ3pFLElBQUlSLFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPLENBQUM7UUFDVjtRQUVBLE9BQU9JLE1BQU1iLE1BQU0sQ0FBQyxTQUFVYyxJQUFJLEVBQUVaLElBQUk7WUFDdEMsSUFBSWdCLFlBQVloQixLQUFLWSxNQUFNTDtZQUUzQjtnQkFDRSxJQUFJLENBQUNRLGtCQUFrQixPQUFPQyxjQUFjLGFBQWE7b0JBQ3ZEQyxRQUFRMUUsSUFBSSxDQUFDeUQ7b0JBQ2IsTUFBTSxJQUFJa0IsTUFBTTtnQkFDbEI7WUFDRjtZQUVBLE9BQU9GO1FBQ1QsR0FBR0Y7SUFDTDtJQUNBLElBQUlLLFlBQVksU0FBU0EsVUFBVVIsS0FBSyxFQUFFUyxPQUFPLEVBQUViLElBQUk7UUFDckQsSUFBSUEsU0FBUyxLQUFLLEdBQUc7WUFDbkJBLE9BQU8sQ0FBQztRQUNWO1FBRUEsT0FBT0ksTUFBTVUsT0FBTyxDQUFDLFNBQVVDLElBQUk7WUFDakMsSUFBSU4sWUFBWU0sS0FBS0YsU0FBU2I7WUFFOUI7Z0JBQ0UsSUFBSSxPQUFPUyxjQUFjLGFBQWE7b0JBQ3BDQyxRQUFRMUUsSUFBSSxDQUFDK0UsTUFBTU47b0JBQ25CLE1BQU0sSUFBSUUsTUFBTTtnQkFDbEI7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTSyxrQkFBa0JDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE1BQU07UUFDN0QsSUFBS0EsUUFBUTtZQUNYLE1BQU0sSUFBSVQsTUFBTSxxR0FBdUdRLGFBQWE7UUFDdEk7UUFFQSxJQUFJRSxjQUFjSixRQUFRSyxTQUFTLENBQUMsU0FBVUMsTUFBTTtZQUNsRCxPQUFPQSxPQUFPSixVQUFVLEtBQUtBO1FBQy9CO1FBRUEsSUFBSUUsZ0JBQWdCLENBQUMsR0FBRztZQUN0QjtnQkFDRSxNQUFNLElBQUlWLE1BQU0saUJBQWtCUSxhQUFhLDRLQUE0S0EsYUFBYSxvQkFBb0JBLGFBQWE7WUFDM1E7UUFDRjtRQUVBRCxRQUFRSixPQUFPLENBQUMsU0FBVVUsTUFBTTtZQUM5QixJQUFJQyxjQUFjUixRQUFRSyxTQUFTLENBQUMsU0FBVUMsTUFBTTtnQkFDbEQsT0FBT0EsT0FBT0osVUFBVSxLQUFLSztZQUMvQjtZQUVBLElBQUlDLGNBQWMsQ0FBQyxLQUFLQSxjQUFjSixhQUFhO2dCQUNqRDtvQkFDRSxNQUFNLElBQUlWLE1BQU0sc0JBQXNCUSxhQUFhLDJDQUEyQ0ssU0FBUztnQkFDekc7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTRSxpQkFBaUJDLE9BQU8sRUFBRUMsR0FBRztRQUNwQyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsT0FBT0Q7SUFDeEQ7SUFDQSxTQUFTRSxhQUFhQyxHQUFHO1FBQ3ZCLElBQUlDLE1BQU01RyxNQUFNNkcsTUFBTTtRQUN0QkQsSUFBSUUsT0FBTyxHQUFHSDtRQUNkLE9BQU8zRyxNQUFNK0csV0FBVyxDQUFDO1lBQ3ZCLE9BQU9ILElBQUlFLE9BQU87UUFDcEIsR0FBRyxFQUFFO0lBQ1AsRUFBRSx5RUFBeUU7SUFFM0UsSUFBSUUsc0JBQXNCLE9BQU9DLGFBQWEsY0FBY2pILE1BQU1rSCxlQUFlLEdBQUdsSCxNQUFNbUgsU0FBUztJQUNuRyxTQUFTQyx1QkFBdUJoRyxFQUFFLEVBQUVpRyxJQUFJO1FBQ3RDLElBQUlDLGFBQWF0SCxNQUFNNkcsTUFBTSxDQUFDO1FBQzlCRyxvQkFBb0I7WUFDbEIsSUFBSU0sV0FBV1IsT0FBTyxFQUFFO2dCQUN0QjFGO1lBQ0Y7WUFFQWtHLFdBQVdSLE9BQU8sR0FBRyxNQUFNLDJCQUEyQjtRQUN4RCxHQUFHTztJQUNMO0lBQ0EsU0FBU0UsaUJBQWlCQyxTQUFTLEVBQUVDLFdBQVc7UUFDOUMsSUFBSUEsZ0JBQWdCLEtBQUssR0FBRztZQUMxQkEsY0FBYztRQUNoQjtRQUVBLElBQUlDLGNBQWMxSCxNQUFNNkcsTUFBTSxDQUFDLENBQUM7UUFDaEMsSUFBSWMsZUFBZWpCLGFBQWFjO1FBQ2hDLElBQUlJLGlCQUFpQmxCLGFBQWFlO1FBQ2xDLE9BQU96SCxNQUFNK0csV0FBVyxDQUN4QixXQUFXLEdBQ1g7WUFDRSxJQUFJYyxRQUFRMUcsa0JBQ1osV0FBVyxHQUNYMkcsbUJBQW1CQyxJQUFJLENBQUMsU0FBU0M7Z0JBQy9CLElBQUlDLE9BQ0E1RyxNQUNBNkcsT0FDQUMsU0FBUzdHO2dCQUViLE9BQU93RyxtQkFBbUJNLElBQUksQ0FBQyxTQUFTQyxVQUFVQyxTQUFTO29CQUN6RCxNQUFPLEVBQUc7d0JBQ1IsT0FBUUEsVUFBVXBELElBQUksR0FBR29ELFVBQVVoRSxJQUFJOzRCQUNyQyxLQUFLO2dDQUNILElBQUsyRCxRQUFRRSxPQUFPckcsTUFBTSxFQUFFVCxPQUFPLElBQUk2QyxNQUFNK0QsUUFBUUMsUUFBUSxHQUFHQSxRQUFRRCxPQUFPQyxRQUFTO29DQUN0RjdHLElBQUksQ0FBQzZHLE1BQU0sR0FBR0MsTUFBTSxDQUFDRCxNQUFNO2dDQUM3QjtnQ0FFQSxJQUFJLENBQUNSLFlBQVlaLE9BQU8sQ0FBQ3lCLE9BQU8sRUFBRTtvQ0FDaENiLFlBQVlaLE9BQU8sQ0FBQ3lCLE9BQU8sR0FBRyxJQUFJdEgsUUFBUSxTQUFVVixPQUFPLEVBQUVDLE1BQU07d0NBQ2pFa0gsWUFBWVosT0FBTyxDQUFDdkcsT0FBTyxHQUFHQTt3Q0FDOUJtSCxZQUFZWixPQUFPLENBQUN0RyxNQUFNLEdBQUdBO29DQUMvQjtnQ0FDRjtnQ0FFQSxJQUFJa0gsWUFBWVosT0FBTyxDQUFDMEIsT0FBTyxFQUFFO29DQUMvQkMsYUFBYWYsWUFBWVosT0FBTyxDQUFDMEIsT0FBTztnQ0FDMUM7Z0NBRUFkLFlBQVlaLE9BQU8sQ0FBQzBCLE9BQU8sR0FBR0UsV0FDOUIsV0FBVyxHQUNYdkgsa0JBQ0EsV0FBVyxHQUNYMkcsbUJBQW1CQyxJQUFJLENBQUMsU0FBU1k7b0NBQy9CLE9BQU9iLG1CQUFtQk0sSUFBSSxDQUFDLFNBQVNRLFNBQVNDLFFBQVE7d0NBQ3ZELE1BQU8sRUFBRzs0Q0FDUixPQUFRQSxTQUFTM0QsSUFBSSxHQUFHMkQsU0FBU3ZFLElBQUk7Z0RBQ25DLEtBQUs7b0RBQ0gsT0FBT29ELFlBQVlaLE9BQU8sQ0FBQzBCLE9BQU87b0RBQ2xDSyxTQUFTM0QsSUFBSSxHQUFHO29EQUNoQjJELFNBQVNDLEVBQUUsR0FBR3BCLFlBQVlaLE9BQU87b0RBQ2pDK0IsU0FBU3ZFLElBQUksR0FBRztvREFDaEIsT0FBT3FELGVBQWVwRyxLQUFLLENBQUMsS0FBSyxHQUFHRjtnREFFdEMsS0FBSztvREFDSHdILFNBQVNFLEVBQUUsR0FBR0YsU0FBU0csSUFBSTtvREFFM0JILFNBQVNDLEVBQUUsQ0FBQ3ZJLE9BQU8sQ0FBQ0gsSUFBSSxDQUFDeUksU0FBU0MsRUFBRSxFQUFFRCxTQUFTRSxFQUFFO29EQUVqREYsU0FBU3ZFLElBQUksR0FBRztvREFDaEI7Z0RBRUYsS0FBSztvREFDSHVFLFNBQVMzRCxJQUFJLEdBQUc7b0RBQ2hCMkQsU0FBU0ksRUFBRSxHQUFHSixRQUFRLENBQUMsUUFBUSxDQUFDO29EQUNoQ25CLFlBQVlaLE9BQU8sQ0FBQ3RHLE1BQU0sQ0FBQ3FJLFNBQVNJLEVBQUU7Z0RBRXhDLEtBQUs7b0RBQ0hKLFNBQVMzRCxJQUFJLEdBQUc7b0RBQ2hCLE9BQU93QyxZQUFZWixPQUFPLENBQUN5QixPQUFPO29EQUNsQyxPQUFPTSxTQUFTSyxNQUFNLENBQUM7Z0RBRXpCLEtBQUs7Z0RBQ0wsS0FBSztvREFDSCxPQUFPTCxTQUFTTSxJQUFJOzRDQUN4Qjt3Q0FDRjtvQ0FDRixHQUFHUixTQUFTLE1BQU07d0NBQUM7NENBQUM7NENBQUc7NENBQUc7NENBQUk7eUNBQUc7cUNBQUM7Z0NBQ3BDLEtBQUtmO2dDQUNMLE9BQU9VLFVBQVVjLE1BQU0sQ0FBQyxVQUFVMUIsWUFBWVosT0FBTyxDQUFDeUIsT0FBTzs0QkFFL0QsS0FBSzs0QkFDTCxLQUFLO2dDQUNILE9BQU9ELFVBQVVhLElBQUk7d0JBQ3pCO29CQUNGO2dCQUNGLEdBQUduQjtZQUNMO1lBRUEsT0FBTztnQkFDTCxPQUFPSCxNQUFNdEcsS0FBSyxDQUFDLElBQUksRUFBRUQ7WUFDM0I7UUFDRixLQUFLO1lBQUNxRztZQUFjQztTQUFlO0lBQ3JDO0lBQ0EsU0FBU3lCLGFBQWFDLFFBQVEsRUFBRUMsTUFBTSxFQUFFMUUsSUFBSTtRQUMxQyxJQUFJQSxTQUFTLEtBQUssR0FBRztZQUNuQkEsT0FBTyxDQUFDO1FBQ1Y7UUFFQSxPQUFPLFNBQVUyRSxJQUFJLEVBQUU1RSxTQUFTO1lBQzlCLElBQUlBLGNBQWMsS0FBSyxHQUFHO2dCQUN4QkEsWUFBWSxDQUFDO1lBQ2Y7WUFFQSxJQUFJNkUsT0FBTyxPQUFPRCxTQUFTLFdBQVdELE1BQU0sQ0FBQ0MsS0FBSyxHQUFHQTtZQUVyRCxJQUFJLE9BQU9DLFNBQVMsYUFBYTtnQkFDL0JsRSxRQUFRMUUsSUFBSSxDQUFDMEk7Z0JBQ2IsTUFBTSxJQUFJL0QsTUFBTXhDO1lBQ2xCO1lBRUEsT0FBTzBHLFdBQVdELE1BQU0vSCxTQUFTLENBQUMsR0FBRzRILFVBQVU7Z0JBQzdDQyxRQUFRQTtZQUNWLEdBQUcxRSxNQUFNLENBQUMsR0FBR0Q7UUFDZjtJQUNGO0lBQ0EsU0FBUzhFLFdBQVdELElBQUksRUFBRXBGLEtBQUs7UUFDN0IsT0FBT3NGLGlCQUFpQkYsUUFBUXpKLE1BQU11RCxhQUFhLENBQUNrRyxNQUFNcEYsU0FBU29GO0lBQ3JFO0lBRUEsU0FBU0UsaUJBQWlCQyxTQUFTO1FBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7SUFDN0Y7SUFFQSxTQUFTQyxpQkFBaUJELFNBQVM7UUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWM7WUFDeEMsSUFBSUcsUUFBUTlKLE9BQU8rSixjQUFjLENBQUNKO1lBQ2xDLE9BQU9HLE1BQU03SixTQUFTLElBQUk2SixNQUFNN0osU0FBUyxDQUFDeUosZ0JBQWdCO1FBQzVEO0lBQ0Y7SUFFQSxTQUFTRyxrQkFBa0JGLFNBQVM7UUFDbEMsT0FBTyxPQUFPQSxjQUFjLFlBQVksT0FBT0EsVUFBVUssUUFBUSxLQUFLLFlBQVk7WUFBQztZQUFjO1NBQW9CLENBQUNDLFFBQVEsQ0FBQ04sVUFBVUssUUFBUSxDQUFDRSxXQUFXO0lBQy9KO0lBRUEsU0FBU0Msb0JBQW9CQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztRQUNqRCxJQUFJQSxVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUTtRQUNWO1FBRUEsT0FBT0YsUUFBUUcsR0FBRyxDQUFDLFNBQVVqQixNQUFNO1lBQ2pDQSxTQUFTN0gsU0FBUyxDQUFDLEdBQUc2SCxRQUFRO2dCQUM1QmUsUUFBUUE7Z0JBQ1JDLE9BQU9BO1lBQ1Q7WUFDQUUscUJBQXFCbEI7WUFFckIsSUFBSUEsT0FBT2MsT0FBTyxFQUFFO2dCQUNsQmQsT0FBT2MsT0FBTyxHQUFHRCxvQkFBb0JiLE9BQU9jLE9BQU8sRUFBRWQsUUFBUWdCLFFBQVE7WUFDdkU7WUFFQSxPQUFPaEI7UUFDVDtJQUNGO0lBQ0EsU0FBU21CLGVBQWVMLE9BQU87UUFDN0IsT0FBT00sVUFBVU4sU0FBUztJQUM1QjtJQUNBLFNBQVNJLHFCQUFxQmxCLE1BQU07UUFDbEMsa0NBQWtDO1FBQ2xDLElBQUlxQixLQUFLckIsT0FBT3FCLEVBQUUsRUFDZEMsV0FBV3RCLE9BQU9zQixRQUFRLEVBQzFCQyxTQUFTdkIsT0FBT3VCLE1BQU07UUFFMUIsSUFBSSxPQUFPRCxhQUFhLFVBQVU7WUFDaENELEtBQUtBLE1BQU1DO1lBQ1gsSUFBSUUsZUFBZUYsU0FBU0csS0FBSyxDQUFDO1lBRWxDSCxXQUFXLFNBQVNBLFNBQVNJLEdBQUc7Z0JBQzlCLE9BQU9DLE1BQU1ELEtBQUtGO1lBQ3BCO1FBQ0Y7UUFFQSxJQUFJLENBQUNILE1BQU0sT0FBT0UsV0FBVyxZQUFZQSxRQUFRO1lBQy9DRixLQUFLRTtRQUNQO1FBRUEsSUFBSSxDQUFDRixNQUFNckIsT0FBT2MsT0FBTyxFQUFFO1lBQ3pCOUUsUUFBUXhFLEtBQUssQ0FBQ3dJO1lBQ2QsTUFBTSxJQUFJL0QsTUFBTTtRQUNsQjtRQUVBLElBQUksQ0FBQ29GLElBQUk7WUFDUHJGLFFBQVF4RSxLQUFLLENBQUN3STtZQUNkLE1BQU0sSUFBSS9ELE1BQU07UUFDbEI7UUFFQXZGLE9BQU8wQixNQUFNLENBQUM0SCxRQUFRO1lBQ3BCcUIsSUFBSUE7WUFDSkMsVUFBVUE7UUFDWjtRQUNBLE9BQU90QjtJQUNUO0lBQ0EsU0FBUzRCLGVBQWU1QixNQUFNLEVBQUU2QixpQkFBaUI7UUFDL0MsSUFBSSxDQUFDQSxtQkFBbUI7WUFDdEIsTUFBTSxJQUFJNUY7UUFDWjtRQUVBdkYsT0FBTzBCLE1BQU0sQ0FBQzRILFFBQVE3SCxTQUFTO1lBQzdCLHFEQUFxRDtZQUNyRG9KLFFBQVF4SDtZQUNSK0gsUUFBUS9IO1FBQ1YsR0FBR0csZUFBZSxDQUFDLEdBQUcySCxtQkFBbUIsQ0FBQyxHQUFHN0I7UUFDN0N0SixPQUFPMEIsTUFBTSxDQUFDNEgsUUFBUTtZQUNwQitCLGVBQWUvQixPQUFPNUYsS0FBSztRQUM3QjtRQUNBLE9BQU80RjtJQUNULEVBQUUsNkNBQTZDO0lBRS9DLFNBQVNnQyxpQkFBaUJDLFVBQVUsRUFBRS9ILGFBQWEsRUFBRWdJLDBCQUEwQjtRQUM3RSxJQUFJQSwrQkFBK0IsS0FBSyxHQUFHO1lBQ3pDQSw2QkFBNkIsU0FBU0E7Z0JBQ3BDLE9BQU8sQ0FBQztZQUNWO1FBQ0Y7UUFFQSxJQUFJQyxlQUFlLEVBQUU7UUFDckIsSUFBSUMsY0FBY0g7UUFDbEIsSUFBSUksTUFBTTtRQUVWLElBQUlDLFNBQVMsU0FBU0E7WUFDcEIsT0FBT0Q7UUFDVDtRQUVBLElBQUlFLFFBQVEsU0FBU0E7WUFDbkIsbUNBQW1DO1lBQ25DLElBQUlDLGNBQWM7Z0JBQ2hCQyxTQUFTLEVBQUU7WUFDYixHQUFHLDhDQUE4QztZQUVqRCxJQUFJQyxnQkFBZ0IsRUFBRTtZQUN0QixJQUFJQyxhQUFhUCxZQUFZUSxJQUFJLENBQUMsU0FBVUMsQ0FBQztnQkFDM0MsT0FBT0EsRUFBRTlCLE1BQU07WUFDakIsSUFBSSwrQkFBK0I7WUFFbkNxQixZQUFZaEcsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO2dCQUNsQywyQ0FBMkM7Z0JBQzNDLElBQUk4QyxxQkFBcUIsRUFBRSxDQUFDdEgsTUFBTSxDQUFDa0gsZUFBZUssT0FBTyxFQUFFLENBQUMsRUFBRTtnQkFDOUQsSUFBSUM7Z0JBRUosSUFBSUwsWUFBWTtvQkFDZCxrREFBa0Q7b0JBQ2xELElBQUkzQyxPQUFPZSxNQUFNLEVBQUU7d0JBQ2pCaUMsWUFBWTdLLFNBQVMsQ0FBQyxHQUFHNkgsT0FBT2UsTUFBTSxFQUFFOzRCQUN0Q2tDLFlBQVlqRCxPQUFPZSxNQUFNLENBQUNNLEVBQUU7NEJBQzVCQSxJQUFJckIsT0FBT2UsTUFBTSxDQUFDTSxFQUFFLEdBQUcsTUFBTWlCOzRCQUM3QkcsU0FBUztnQ0FBQ3pDOzZCQUFPO3dCQUNuQixHQUFHa0MsMkJBQTJCbEM7b0JBQ2hDLE9BQU87d0JBQ0wsK0VBQStFO3dCQUMvRSxJQUFJaUQsYUFBYWpELE9BQU9xQixFQUFFLEdBQUc7d0JBQzdCMkIsWUFBWXBCLGVBQWV6SixTQUFTOzRCQUNsQzhLLFlBQVlBOzRCQUNaNUIsSUFBSXJCLE9BQU9xQixFQUFFLEdBQUcsa0JBQWtCaUI7NEJBQ2xDWSxlQUFlbEQ7NEJBQ2Z5QyxTQUFTO2dDQUFDekM7NkJBQU87d0JBQ25CLEdBQUdrQywyQkFBMkJsQyxVQUFVOUY7b0JBQzFDLEVBQUUseURBQXlEO29CQUMzRCwyQ0FBMkM7b0JBRzNDLElBQUk0SSxzQkFBc0JBLG1CQUFtQkcsVUFBVSxLQUFLRCxVQUFVQyxVQUFVLEVBQUU7d0JBQ2hGSCxtQkFBbUJMLE9BQU8sQ0FBQ1UsSUFBSSxDQUFDbkQ7b0JBQ2xDLE9BQU87d0JBQ0wwQyxjQUFjUyxJQUFJLENBQUNIO29CQUNyQjtnQkFDRjtnQkFFQVIsWUFBWUMsT0FBTyxDQUFDVSxJQUFJLENBQUNuRDtZQUMzQjtZQUNBbUMsYUFBYWdCLElBQUksQ0FBQ1gsY0FBYyxvQ0FBb0M7WUFFcEVKLGNBQWNNO1FBQ2hCO1FBRUEsTUFBT04sWUFBWTdKLE1BQU0sQ0FBRTtZQUN6QmdLO1FBQ0Y7UUFFQSxPQUFPSixhQUFhWSxPQUFPO0lBQzdCO0lBQ0EsSUFBSUssZUFBZSxJQUFJQztJQUN2QixTQUFTMUIsTUFBTXZFLEdBQUcsRUFBRWtHLElBQUksRUFBRUMsR0FBRztRQUMzQixJQUFJLENBQUNELE1BQU07WUFDVCxPQUFPbEc7UUFDVDtRQUVBLElBQUlvRyxXQUFXLE9BQU9GLFNBQVMsYUFBYUEsT0FBT0csS0FBS0MsU0FBUyxDQUFDSjtRQUVsRSxJQUFJSyxVQUFVUCxhQUFhUSxHQUFHLENBQUNKLGFBQWE7WUFDMUMsSUFBSUcsVUFBVUUsY0FBY1A7WUFDNUJGLGFBQWFVLEdBQUcsQ0FBQ04sVUFBVUc7WUFDM0IsT0FBT0E7UUFDVDtRQUVBLElBQUlJO1FBRUosSUFBSTtZQUNGQSxNQUFNSixRQUFROUksTUFBTSxDQUFDLFNBQVVtSixNQUFNLEVBQUVDLFFBQVE7Z0JBQzdDLE9BQU9ELE1BQU0sQ0FBQ0MsU0FBUztZQUN6QixHQUFHN0c7UUFDTCxFQUFFLE9BQU84RyxHQUFHLENBQ1o7UUFFQSxPQUFPLE9BQU9ILFFBQVEsY0FBY0EsTUFBTVI7SUFDNUM7SUFDQSxTQUFTWTtRQUNQLElBQUssSUFBSTFKLE9BQU8xQyxVQUFVUSxNQUFNLEVBQUVULE9BQU8sSUFBSTZDLE1BQU1GLE9BQU9HLE9BQU8sR0FBR0EsT0FBT0gsTUFBTUcsT0FBUTtZQUN2RjlDLElBQUksQ0FBQzhDLEtBQUssR0FBRzdDLFNBQVMsQ0FBQzZDLEtBQUs7UUFDOUI7UUFFQSxJQUFLLElBQUl0QyxJQUFJLEdBQUdBLElBQUlSLEtBQUtTLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1lBQ3ZDLElBQUksT0FBT1IsSUFBSSxDQUFDUSxFQUFFLEtBQUssYUFBYTtnQkFDbEMsT0FBT1IsSUFBSSxDQUFDUSxFQUFFO1lBQ2hCO1FBQ0Y7SUFDRjtJQUNBLFNBQVM4TCxXQUFXQyxDQUFDO1FBQ25CLElBQUksT0FBT0EsTUFBTSxZQUFZO1lBQzNCLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLFNBQVNqRCxVQUFVa0QsR0FBRyxFQUFFbE4sR0FBRztRQUN6QixJQUFJbU4sT0FBTyxFQUFFO1FBRWIsSUFBSUMsVUFBVSxTQUFTQSxRQUFRRixHQUFHO1lBQ2hDQSxJQUFJbEksT0FBTyxDQUFDLFNBQVV5RyxDQUFDO2dCQUNyQixJQUFJLENBQUNBLENBQUMsQ0FBQ3pMLElBQUksRUFBRTtvQkFDWG1OLEtBQUtwQixJQUFJLENBQUNOO2dCQUNaLE9BQU87b0JBQ0wyQixRQUFRM0IsQ0FBQyxDQUFDekwsSUFBSTtnQkFDaEI7WUFDRjtRQUNGO1FBRUFvTixRQUFRRjtRQUNSLE9BQU9DO0lBQ1Q7SUFDQSxTQUFTRSxXQUFXQyxJQUFJLEVBQUU3SyxJQUFJO1FBQzVCLElBQUk4SyxvQkFBb0I5SyxLQUFLOEssaUJBQWlCLEVBQzFDQyxXQUFXL0ssS0FBSytLLFFBQVEsRUFDeEJDLHFCQUFxQmhMLEtBQUtpTCxhQUFhLEVBQ3ZDQSxnQkFBZ0JELHVCQUF1QixLQUFLLElBQUksT0FBT0E7UUFDM0QsSUFBSUUsZUFBZSxFQUFFO1FBRXJCLElBQUlDLFlBQVksU0FBU0EsVUFBVXRELEdBQUcsRUFBRXVELGlCQUFpQjtZQUN2RCxJQUFJQSxzQkFBc0IsS0FBSyxHQUFHO2dCQUNoQ0Esb0JBQW9CO1lBQ3RCO1lBRUF2RCxJQUFJd0QsVUFBVSxHQUFHeEQsSUFBSXlELFFBQVEsSUFBSXpELElBQUl5RCxRQUFRLENBQUNSLGtCQUFrQixJQUFJQyxRQUFRLENBQUNsRCxJQUFJTCxFQUFFLENBQUM7WUFDcEZLLElBQUkwRCxTQUFTLEdBQUcxRCxJQUFJMkQsT0FBTyxJQUFJLENBQUMsQ0FBQzNELElBQUkyRCxPQUFPLENBQUM5TSxNQUFNO1lBRW5ELElBQUkwTSxtQkFBbUI7Z0JBQ3JCRixhQUFhNUIsSUFBSSxDQUFDekI7WUFDcEI7WUFFQSxJQUFJQSxJQUFJMkQsT0FBTyxJQUFJM0QsSUFBSTJELE9BQU8sQ0FBQzlNLE1BQU0sSUFBSW1KLElBQUl3RCxVQUFVLEVBQUU7Z0JBQ3ZEeEQsSUFBSTJELE9BQU8sQ0FBQ2pKLE9BQU8sQ0FBQyxTQUFVc0YsR0FBRztvQkFDL0IsT0FBT3NELFVBQVV0RCxLQUFLb0Q7Z0JBQ3hCO1lBQ0Y7UUFDRjtRQUVBSixLQUFLdEksT0FBTyxDQUFDLFNBQVVzRixHQUFHO1lBQ3hCLE9BQU9zRCxVQUFVdEQ7UUFDbkI7UUFDQSxPQUFPcUQ7SUFDVDtJQUNBLFNBQVNPLGdCQUFnQkMsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFdBQVc7UUFDM0QsT0FBT3JCLFdBQVdtQixXQUFXQyxlQUFlLENBQUNELE9BQU8sSUFBSUUsV0FBVyxDQUFDRixPQUFPLElBQUlFLFlBQVlDLElBQUk7SUFDakc7SUFDQSxTQUFTQyx1QkFBdUJDLFVBQVUsRUFBRXJPLEtBQUssRUFBRXlJLE1BQU07UUFDdkQsT0FBTzRGLGFBQWFBLFdBQVdyTyxPQUFPeUksVUFBVSxPQUFPekksVUFBVTtJQUNuRTtJQUNBLFNBQVNzTztRQUNQLE1BQU0sSUFBSTVKLE1BQU07SUFDbEI7SUFDQSxJQUFJNkosbUJBQW1CO0lBQ3ZCLFNBQVNDO1FBQ1AsdURBQXVEO1FBQ3ZELElBQUksT0FBT0QscUJBQXFCLFdBQVcsT0FBT0E7UUFDbEQsSUFBSUUsWUFBWTtRQUVoQixJQUFJO1lBQ0YsSUFBSUMsVUFBVTtnQkFDWixJQUFJQyxXQUFVO29CQUNaRixZQUFZO29CQUNaLE9BQU87Z0JBQ1Q7WUFFRjtZQUNBRyxPQUFPQyxnQkFBZ0IsQ0FBQyxRQUFRLE1BQU1IO1lBQ3RDRSxPQUFPRSxtQkFBbUIsQ0FBQyxRQUFRLE1BQU1KO1FBQzNDLEVBQUUsT0FBT2hPLEtBQUs7WUFDWitOLFlBQVk7UUFDZDtRQUVBRixtQkFBbUJFO1FBQ25CLE9BQU9GO0lBQ1QsRUFBRSxFQUFFO0lBRUosSUFBSVEsZ0JBQWdCO0lBQ3BCLElBQUlDLGlCQUFpQjtJQUVyQixTQUFTMUMsY0FBY3pHLEdBQUc7UUFDeEIsT0FBT29KLFlBQVlwSixLQUFLLDhCQUE4QjtTQUNyRDZELEdBQUcsQ0FBQyxTQUFVNEIsQ0FBQztZQUNkLE9BQU92SixPQUFPdUosR0FBRzRELE9BQU8sQ0FBQyxLQUFLO1FBQ2hDLEdBQUcsMEJBQTBCO1NBQzVCQyxJQUFJLENBQUMsS0FBSyxnQ0FBZ0M7U0FDMUNELE9BQU8sQ0FBQ0gsZUFBZSxLQUFLRyxPQUFPLENBQUNGLGdCQUFnQixJQUFJLCtCQUErQjtTQUN2RjlFLEtBQUssQ0FBQztJQUNUO0lBRUEsU0FBUytFLFlBQVlsQyxHQUFHLEVBQUVxQyxNQUFNO1FBQzlCLElBQUlBLFdBQVcsS0FBSyxHQUFHO1lBQ3JCQSxTQUFTLEVBQUU7UUFDYjtRQUVBLElBQUksQ0FBQ2hNLE1BQU1ZLE9BQU8sQ0FBQytJLE1BQU07WUFDdkJxQyxPQUFPeEQsSUFBSSxDQUFDbUI7UUFDZCxPQUFPO1lBQ0wsSUFBSyxJQUFJaE0sSUFBSSxHQUFHQSxJQUFJZ00sSUFBSS9MLE1BQU0sRUFBRUQsS0FBSyxFQUFHO2dCQUN0Q2tPLFlBQVlsQyxHQUFHLENBQUNoTSxFQUFFLEVBQUVxTztZQUN0QjtRQUNGO1FBRUEsT0FBT0E7SUFDVDtJQUVBLElBQUlDLHVCQUF1QixTQUFTQSxxQkFBcUI5TCxLQUFLO1FBQzVELE9BQU8zQyxTQUFTO1lBQ2QwTyxNQUFNO1FBQ1IsR0FBRy9MO0lBQ0w7SUFFQSxJQUFJZ00sMkJBQTJCLFNBQVNBLHlCQUF5QmhNLEtBQUs7UUFDcEUsT0FBTzNDLFNBQVM7WUFDZDBPLE1BQU07UUFDUixHQUFHL0w7SUFDTDtJQUVBLElBQUlpTSx3QkFBd0IsU0FBU0Esc0JBQXNCak0sS0FBSyxFQUFFakIsSUFBSTtRQUNwRSxJQUFJbUcsU0FBU25HLEtBQUttRyxNQUFNO1FBQ3hCLE9BQU83SCxTQUFTO1lBQ2RmLEtBQUssWUFBWTRJLE9BQU9xQixFQUFFO1lBQzFCMkYsU0FBU2hILE9BQU9pSCx1QkFBdUI7WUFDdkNKLE1BQU07UUFDUixHQUFHL0w7SUFDTDtJQUVBLElBQUlvTSx3QkFBd0IsU0FBU0Esc0JBQXNCcE0sS0FBSyxFQUFFd0QsS0FBSztRQUNyRSxJQUFJMEIsU0FBUzFCLE1BQU0wQixNQUFNO1FBQ3pCLE9BQU83SCxTQUFTO1lBQ2RmLEtBQUssWUFBWTRJLE9BQU9xQixFQUFFO1lBQzFCMkYsU0FBU2hILE9BQU9pSCx1QkFBdUI7UUFDekMsR0FBR25NO0lBQ0w7SUFFQSxJQUFJcU0sNkJBQTZCLFNBQVNBLDJCQUEyQnJNLEtBQUssRUFBRXNNLEtBQUs7UUFDL0UsSUFBSUMsUUFBUUQsTUFBTUMsS0FBSztRQUN2QixPQUFPbFAsU0FBUztZQUNkZixLQUFLLGlCQUFpQmlRO1lBQ3RCUixNQUFNO1FBQ1IsR0FBRy9MO0lBQ0w7SUFFQSxJQUFJd00sNkJBQTZCLFNBQVNBLDJCQUEyQnhNLEtBQUssRUFBRXlNLEtBQUs7UUFDL0UsSUFBSUYsUUFBUUUsTUFBTUYsS0FBSztRQUN2QixPQUFPbFAsU0FBUztZQUNkZixLQUFLLGlCQUFpQmlRO1FBQ3hCLEdBQUd2TTtJQUNMO0lBRUEsSUFBSTBNLHFCQUFxQixTQUFTQSxtQkFBbUIxTSxLQUFLLEVBQUUyTSxLQUFLO1FBQy9ELElBQUkvRixNQUFNK0YsTUFBTS9GLEdBQUc7UUFDbkIsT0FBT3ZKLFNBQVM7WUFDZGYsS0FBSyxTQUFTc0ssSUFBSUwsRUFBRTtZQUNwQndGLE1BQU07UUFDUixHQUFHL0w7SUFDTDtJQUVBLElBQUk0TSxzQkFBc0IsU0FBU0Esb0JBQW9CNU0sS0FBSyxFQUFFNk0sS0FBSztRQUNqRSxJQUFJQyxPQUFPRCxNQUFNQyxJQUFJO1FBQ3JCLE9BQU96UCxTQUFTO1lBQ2RmLEtBQUssVUFBVXdRLEtBQUtsRyxHQUFHLENBQUNMLEVBQUUsR0FBRyxNQUFNdUcsS0FBSzVILE1BQU0sQ0FBQ3FCLEVBQUU7WUFDakR3RixNQUFNO1FBQ1IsR0FBRy9MO0lBQ0w7SUFFQSxTQUFTK007UUFDUCxPQUFPO1lBQ0xDLFlBQVksRUFBRTtZQUNkQyxlQUFlLEVBQUU7WUFDakJDLG9CQUFvQixFQUFFO1lBQ3RCbEgsU0FBUyxFQUFFO1lBQ1htSCxhQUFhLEVBQUU7WUFDZmhHLFlBQVksRUFBRTtZQUNkaUcsZ0JBQWdCLEVBQUU7WUFDbEJDLGFBQWEsRUFBRTtZQUNmQyxxQkFBcUIsRUFBRTtZQUN2QkMseUJBQXlCLEVBQUU7WUFDM0JDLHNCQUFzQixFQUFFO1lBQ3hCQyxnQkFBZ0IsRUFBRTtZQUNsQkMsb0JBQW9CLEVBQUU7WUFDdEJyRyxjQUFjLEVBQUU7WUFDaEJzRyxrQkFBa0IsRUFBRTtZQUNwQkMsNkJBQTZCLEVBQUU7WUFDL0JDLGFBQWEsRUFBRTtZQUNmQyxZQUFZLEVBQUU7WUFDZEMsZUFBZTtnQkFBQ2pDO2FBQXFCO1lBQ3JDa0MsbUJBQW1CO2dCQUFDaEM7YUFBeUI7WUFDN0NpQyxxQkFBcUI7Z0JBQUM1QjthQUEyQjtZQUNqRDZCLHFCQUFxQjtnQkFBQzFCO2FBQTJCO1lBQ2pEMkIsZ0JBQWdCO2dCQUFDbEM7YUFBc0I7WUFDdkNtQyxnQkFBZ0I7Z0JBQUNoQzthQUFzQjtZQUN2Q2lDLGFBQWE7Z0JBQUMzQjthQUFtQjtZQUNqQzRCLGNBQWM7Z0JBQUMxQjthQUFvQjtZQUNuQzJCLGtCQUFrQixFQUFFO1FBQ3RCO0lBQ0Y7SUFFQTNQLFFBQVE0UCxrQkFBa0IsR0FBRztJQUM3QjVQLFFBQVE2UCxnQkFBZ0IsR0FBRztJQUMzQjdQLFFBQVE4UCxnQkFBZ0IsR0FBRztJQUMzQjlQLFFBQVErUCxvQkFBb0IsR0FBRztJQUMvQixJQUFJQyxzQkFBc0IsU0FBU0Esb0JBQW9CaE8sS0FBSztRQUMxREEsTUFBTWlPLG9CQUFvQixHQUFHO1lBQUNDO1NBQTRCO1FBQzFEbE8sTUFBTW1PLDRCQUE0QixHQUFHO1lBQUNDO1NBQW9DO1FBQzFFcE8sTUFBTXFNLGFBQWEsQ0FBQzVFLElBQUksQ0FBQzRHO1FBQ3pCck8sTUFBTWdOLDJCQUEyQixDQUFDdkYsSUFBSSxDQUFDdUY7UUFDdkNoTixNQUFNK00sZ0JBQWdCLENBQUN0RixJQUFJLENBQUMsU0FBVXJGLElBQUksRUFBRWpFLElBQUk7WUFDOUMsSUFBSWtHLFdBQVdsRyxLQUFLa0csUUFBUTtZQUM1QixPQUFPLEVBQUUsQ0FBQ3ZFLE1BQU0sQ0FBQ3NDLE1BQU07Z0JBQUNpQyxTQUFTaUssS0FBSyxDQUFDQyxhQUFhO2FBQUM7UUFDdkQ7UUFDQXZPLE1BQU1pTixXQUFXLENBQUN4RixJQUFJLENBQUN3RjtJQUN6QjtJQUNBZSxvQkFBb0JqTixVQUFVLEdBQUc7SUFFakMsSUFBSW1OLDhCQUE4QixTQUFTQSw0QkFBNEI5TyxLQUFLLEVBQUV3RCxLQUFLO1FBQ2pGLElBQUkwQixTQUFTMUIsTUFBTTBCLE1BQU07UUFDekIsT0FBTztZQUFDbEY7WUFBTztnQkFDYm9QLFVBQVUsU0FBU0EsU0FBU2hHLENBQUM7b0JBQzNCbEUsT0FBT21LLFlBQVksQ0FBQyxDQUFDakcsRUFBRTdMLE1BQU0sQ0FBQytSLE9BQU87Z0JBQ3ZDO2dCQUNBcFAsT0FBTztvQkFDTGdKLFFBQVE7Z0JBQ1Y7Z0JBQ0FvRyxTQUFTcEssT0FBT3FLLFNBQVM7Z0JBQ3pCQyxPQUFPO1lBQ1Q7U0FBRTtJQUNKO0lBRUEsSUFBSVIsc0NBQXNDLFNBQVNBLG9DQUFvQ2hQLEtBQUssRUFBRXNNLEtBQUs7UUFDakcsSUFBSXJILFdBQVdxSCxNQUFNckgsUUFBUTtRQUM3QixPQUFPO1lBQUNqRjtZQUFPO2dCQUNib1AsVUFBVSxTQUFTQSxTQUFTaEcsQ0FBQztvQkFDM0JuRSxTQUFTMEosb0JBQW9CLENBQUMsQ0FBQ3ZGLEVBQUU3TCxNQUFNLENBQUMrUixPQUFPO2dCQUNqRDtnQkFDQXBQLE9BQU87b0JBQ0xnSixRQUFRO2dCQUNWO2dCQUNBb0csU0FBUyxDQUFDckssU0FBU3dLLGdCQUFnQixJQUFJLENBQUN4SyxTQUFTaUssS0FBSyxDQUFDQyxhQUFhLENBQUMxUixNQUFNO2dCQUMzRStSLE9BQU87Z0JBQ1BFLGVBQWUsQ0FBQ3pLLFNBQVN3SyxnQkFBZ0IsSUFBSXhLLFNBQVNpSyxLQUFLLENBQUNDLGFBQWEsQ0FBQzFSLE1BQU07WUFDbEY7U0FBRTtJQUNKO0lBRUEsU0FBU3dSLFFBQVFDLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3JELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkOFIsZUFBZSxFQUFFO1lBQ25CLEdBQUdEO1FBQ0w7UUFFQSxJQUFJUyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUTRQLGtCQUFrQixFQUFFO1lBQzlDLE9BQU9uUixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCQyxlQUFlbEssU0FBUzRLLFlBQVksQ0FBQ1YsYUFBYSxJQUFJLEVBQUU7WUFDMUQ7UUFDRjtRQUVBLElBQUlRLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRNlAsZ0JBQWdCLEVBQUU7WUFDNUMsSUFBSXFCLFNBQVMsT0FBT0gsT0FBT2xULEtBQUssS0FBSyxjQUFja1QsT0FBT2xULEtBQUssR0FBRyxDQUFDeVMsTUFBTUMsYUFBYSxDQUFDdEosUUFBUSxDQUFDOEosT0FBT0ksUUFBUTtZQUMvRyxJQUFJWixnQkFBZ0JXLFNBQVMsRUFBRSxDQUFDcFAsTUFBTSxDQUFDd08sTUFBTUMsYUFBYSxFQUFFO2dCQUFDUSxPQUFPSSxRQUFRO2FBQUMsSUFBSWIsTUFBTUMsYUFBYSxDQUFDMUUsTUFBTSxDQUFDLFNBQVUxQyxDQUFDO2dCQUNySCxPQUFPQSxNQUFNNEgsT0FBT0ksUUFBUTtZQUM5QjtZQUNBLE9BQU8xUyxTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCQyxlQUFlQTtZQUNqQjtRQUNGO1FBRUEsSUFBSVEsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVE4UCxnQkFBZ0IsRUFBRTtZQUM1QyxPQUFPclIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QkMsZUFBZWpOLGlCQUFpQnlOLE9BQU9sVCxLQUFLLEVBQUV5UyxNQUFNQyxhQUFhO1lBQ25FO1FBQ0Y7UUFFQSxJQUFJUSxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUStQLG9CQUFvQixFQUFFO1lBQ2hELElBQUlxQixZQUFZLE9BQU9MLE9BQU9sVCxLQUFLLEtBQUssY0FBY2tULE9BQU9sVCxLQUFLLEdBQUcsQ0FBQ3lTLE1BQU1DLGFBQWEsQ0FBQzFSLE1BQU07WUFDaEcsT0FBT0osU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QkMsZUFBZWEsWUFBWS9LLFNBQVNrQyxVQUFVLENBQUNoQixHQUFHLENBQUMsU0FBVTRCLENBQUM7b0JBQzVELE9BQU9BLEVBQUV4QixFQUFFO2dCQUNiLEtBQUssRUFBRTtZQUNUO1FBQ0Y7SUFDRjtJQUVBLFNBQVNxSCw0QkFBNEIzSSxRQUFRO1FBQzNDLElBQUkwQyxVQUFVMUMsU0FBUzBDLE9BQU8sRUFDMUJ3SCxnQkFBZ0JsSyxTQUFTaUssS0FBSyxDQUFDQyxhQUFhO1FBQ2hELElBQUljLGVBQWV0VSxNQUFNNkcsTUFBTSxDQUFDO1FBRWhDLElBQUksQ0FBQ3lOLGFBQWF4TixPQUFPO1FBRXpCLElBQUl5TixlQUFlLFNBQVNBLGFBQWFoTCxNQUFNLEVBQUVpTCxhQUFhO1lBQzVEakwsT0FBT3FLLFNBQVMsR0FBR1ksaUJBQWlCLENBQUNoQixjQUFjdEosUUFBUSxDQUFDWCxPQUFPcUIsRUFBRTtZQUNyRSxJQUFJNEYsMEJBQTBCO1lBRTlCLElBQUlqSCxPQUFPeUMsT0FBTyxJQUFJekMsT0FBT3lDLE9BQU8sQ0FBQ2xLLE1BQU0sRUFBRTtnQkFDM0N5SCxPQUFPeUMsT0FBTyxDQUFDckcsT0FBTyxDQUFDLFNBQVU4TyxTQUFTO29CQUN4QyxPQUFPakUsMkJBQTJCK0QsYUFBYUUsV0FBV2xMLE9BQU9xSyxTQUFTO2dCQUM1RTtZQUNGLE9BQU87Z0JBQ0xwRCwwQkFBMEJqSCxPQUFPcUssU0FBUyxHQUFHLElBQUk7WUFDbkQ7WUFFQXJLLE9BQU9pSCx1QkFBdUIsR0FBR0E7WUFDakMsT0FBT0E7UUFDVDtRQUVBLElBQUlBLDBCQUEwQjtRQUM5QnhFLFFBQVFyRyxPQUFPLENBQUMsU0FBVStPLFNBQVM7WUFDakMsT0FBT2xFLDJCQUEyQitELGFBQWFHLFdBQVc7UUFDNUQ7SUFDRjtJQUVBLFNBQVN4QyxZQUFZNUksUUFBUTtRQUMzQixJQUFJZSxVQUFVZixTQUFTZSxPQUFPLEVBQzFCc0ssY0FBY3JMLFNBQVNxTCxXQUFXLEVBQ2xDQyxXQUFXdEwsU0FBU3NMLFFBQVEsRUFDNUJwSixhQUFhbEMsU0FBU2tDLFVBQVUsRUFDaENxSixXQUFXdkwsU0FBU3VMLFFBQVEsRUFDNUJyQixnQkFBZ0JsSyxTQUFTaUssS0FBSyxDQUFDQyxhQUFhLEVBQzVDc0Isd0JBQXdCeEwsU0FBU3lMLHNCQUFzQixFQUN2REEseUJBQXlCRCwwQkFBMEIsS0FBSyxJQUFJLE9BQU9BO1FBQ3ZFLElBQUlFLGNBQWN0TyxhQUFhNEM7UUFDL0IsSUFBSXdLLG1CQUFtQnRJLFdBQVcxSixNQUFNLEtBQUswUixjQUFjMVIsTUFBTTtRQUNqRSxJQUFJZ1IsbUJBQW1COVMsTUFBTStHLFdBQVcsQ0FBQyxTQUFVcU4sUUFBUSxFQUFFdFQsS0FBSztZQUNoRSxPQUFPOFQsU0FBUztnQkFDZHBMLE1BQU12RyxRQUFRNlAsZ0JBQWdCO2dCQUM5QnNCLFVBQVVBO2dCQUNWdFQsT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJN0IsbUJBQW1CL1MsTUFBTStHLFdBQVcsQ0FBQyxTQUFVakcsS0FBSztZQUN0RCxPQUFPOFQsU0FBUztnQkFDZHBMLE1BQU12RyxRQUFROFAsZ0JBQWdCO2dCQUM5QmpTLE9BQU9BO1lBQ1Q7UUFDRixHQUFHO1lBQUM4VDtTQUFTO1FBQ2IsSUFBSTVCLHVCQUF1QmhULE1BQU0rRyxXQUFXLENBQUMsU0FBVWpHLEtBQUs7WUFDMUQsT0FBTzhULFNBQVM7Z0JBQ2RwTCxNQUFNdkcsUUFBUStQLG9CQUFvQjtnQkFDbENsUyxPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDOFQ7U0FBUztRQUNiLElBQUl4QiwrQkFBK0JwTyxlQUFlNlAsV0FBV3pCLDRCQUE0QixFQUFFO1lBQ3pGOUosVUFBVTBMO1FBQ1o7UUFDQUwsWUFBWWhQLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtZQUNsQ0EsT0FBT21LLFlBQVksR0FBRyxTQUFVNVMsS0FBSztnQkFDbkM4VCxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVE2UCxnQkFBZ0I7b0JBQzlCc0IsVUFBVTdLLE9BQU9xQixFQUFFO29CQUNuQjlKLE9BQU9BO2dCQUNUO1lBQ0Y7WUFFQXlJLE9BQU8ySixvQkFBb0IsR0FBR2xPLGVBQWU2UCxXQUFXM0Isb0JBQW9CLEVBQUU7Z0JBQzVFNUosVUFBVTBMO2dCQUNWekwsUUFBUUE7WUFDVjtRQUNGO1FBQ0EsSUFBSTBMLDRCQUE0QnZPLGFBQWFxTztRQUM3QzNOLHVCQUF1QjtZQUNyQixJQUFJNk4sNkJBQTZCO2dCQUMvQkwsU0FBUztvQkFDUHBMLE1BQU12RyxRQUFRNFAsa0JBQWtCO2dCQUNsQztZQUNGO1FBQ0YsR0FBRztZQUFDK0I7WUFBVXZLO1NBQVE7UUFDdEJwSyxPQUFPMEIsTUFBTSxDQUFDMkgsVUFBVTtZQUN0QndLLGtCQUFrQkE7WUFDbEJoQixrQkFBa0JBO1lBQ2xCQyxrQkFBa0JBO1lBQ2xCQyxzQkFBc0JBO1lBQ3RCSSw4QkFBOEJBO1FBQ2hDO0lBQ0Y7SUFFQSxJQUFJOEIsc0JBQXNCLENBQUM7SUFDM0IsSUFBSUMsd0JBQXdCLENBQUM7SUFFN0IsSUFBSUMsaUJBQWlCLFNBQVNBLGVBQWU3QixLQUFLLEVBQUVTLE1BQU0sRUFBRXFCLFNBQVM7UUFDbkUsT0FBTzlCO0lBQ1Q7SUFFQSxJQUFJK0Isb0JBQW9CLFNBQVNBLGtCQUFrQnJLLEdBQUcsRUFBRTJGLEtBQUs7UUFDM0QsT0FBTzNGLElBQUkyRCxPQUFPLElBQUksRUFBRTtJQUMxQjtJQUVBLElBQUkyRyxrQkFBa0IsU0FBU0EsZ0JBQWdCdEssR0FBRyxFQUFFMkYsS0FBSyxFQUFFdEcsTUFBTTtRQUMvRCxPQUFPLEtBQU1BLENBQUFBLFNBQVM7WUFBQ0EsT0FBT00sRUFBRTtZQUFFZ0c7U0FBTSxDQUFDWCxJQUFJLENBQUMsT0FBT1csS0FBSTtJQUMzRDtJQUVBLElBQUk0RSw0QkFBNEIsU0FBU0EsMEJBQTBCcEosQ0FBQztRQUNsRSxPQUFPQTtJQUNUO0lBRUEsU0FBU3FKLGNBQWNwUixLQUFLO1FBQzFCLElBQUlxUixzQkFBc0JyUixNQUFNNlAsWUFBWSxFQUN4Q0EsZUFBZXdCLHdCQUF3QixLQUFLLElBQUlSLHNCQUFzQlEscUJBQ3RFQyx1QkFBdUJ0UixNQUFNWixhQUFhLEVBQzFDQSxnQkFBZ0JrUyx5QkFBeUIsS0FBSyxJQUFJUix3QkFBd0JRLHNCQUMxRUMsb0JBQW9CdlIsTUFBTXdSLFVBQVUsRUFDcENBLGFBQWFELHNCQUFzQixLQUFLLElBQUlOLG9CQUFvQk0sbUJBQ2hFRSxrQkFBa0J6UixNQUFNMFIsUUFBUSxFQUNoQ0EsV0FBV0Qsb0JBQW9CLEtBQUssSUFBSVAsa0JBQWtCTyxpQkFDMURFLHNCQUFzQjNSLE1BQU00UixZQUFZLEVBQ3hDQSxlQUFlRCx3QkFBd0IsS0FBSyxJQUFJWixpQkFBaUJZLHFCQUNqRUUsd0JBQXdCN1IsTUFBTWtOLGtCQUFrQixFQUNoREEscUJBQXFCMkUsMEJBQTBCLEtBQUssSUFBSVYsNEJBQTRCVSx1QkFDcEZ6UixPQUFPekMsOEJBQThCcUMsT0FBTztZQUFDO1lBQWdCO1lBQWlCO1lBQWM7WUFBWTtZQUFnQjtTQUFxQjtRQUVqSixPQUFPM0MsU0FBUyxDQUFDLEdBQUcrQyxNQUFNO1lBQ3hCeVAsY0FBY0E7WUFDZHpRLGVBQWVBO1lBQ2ZvUyxZQUFZQTtZQUNaRSxVQUFVQTtZQUNWRSxjQUFjQTtZQUNkMUUsb0JBQW9CQTtRQUN0QjtJQUNGO0lBRUEsSUFBSTRFLFdBQVcsU0FBU0EsU0FBUzlSLEtBQUs7UUFDcEMsSUFBSyxJQUFJTCxPQUFPMUMsVUFBVVEsTUFBTSxFQUFFZ0UsVUFBVSxJQUFJNUIsTUFBTUYsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUcsT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1lBQzdHMkIsT0FBTyxDQUFDM0IsT0FBTyxFQUFFLEdBQUc3QyxTQUFTLENBQUM2QyxLQUFLO1FBQ3JDO1FBRUEsc0JBQXNCO1FBQ3RCRSxRQUFRb1IsY0FBY3BSLFFBQVEsbUJBQW1CO1FBRWpEeUIsVUFBVTtZQUFDbU47U0FBb0IsQ0FBQ2xPLE1BQU0sQ0FBQ2UsVUFBVSw0QkFBNEI7UUFFN0UsSUFBSXNRLGNBQWNwVyxNQUFNNkcsTUFBTSxDQUFDLENBQUMsSUFBSSxpRkFBaUY7UUFFckgsSUFBSW1PLGNBQWN0TyxhQUFhMFAsWUFBWXRQLE9BQU8sR0FBRyxzREFBc0Q7UUFFM0c3RyxPQUFPMEIsTUFBTSxDQUFDcVQsZUFBZXRULFNBQVMsQ0FBQyxHQUFHMkMsT0FBTztZQUMvQ3lCLFNBQVNBO1lBQ1RiLE9BQU9tTTtRQUNULEtBQUssdURBQXVEO1FBRTVEdEwsUUFBUWdKLE1BQU0sQ0FBQ3VILFNBQVMxUSxPQUFPLENBQUMsU0FBVVMsTUFBTTtZQUM5Q0EsT0FBTzRPLGNBQWMvUCxLQUFLO1FBQzVCLElBQUksK0NBQStDO1FBRW5ELElBQUk0UCxXQUFXbk8sYUFBYXNPLGNBQWMvUCxLQUFLO1FBQy9DK1AsY0FBY0gsUUFBUSxHQUFHQTtRQUN6QixPQUFPRyxjQUFjL1AsS0FBSyxFQUFFLHFFQUFxRTtRQUVqR2hGLE9BQU8wQixNQUFNLENBQUNxVCxlQUFlN1AsWUFBWTBQLFdBQVd4RCxVQUFVLEVBQUVvRSxjQUFjcFI7UUFFOUUsSUFBSWlTLGVBQWV0QixlQUNmdUIsT0FBT0QsYUFBYUMsSUFBSSxFQUN4QkMsY0FBY0YsYUFBYWpNLE9BQU8sRUFDbEM2SixlQUFlb0MsYUFBYXBDLFlBQVksRUFDeEN6USxnQkFBZ0I2UyxhQUFhN1MsYUFBYSxFQUMxQ29TLGFBQWFTLGFBQWFULFVBQVUsRUFDcENFLFdBQVdPLGFBQWFQLFFBQVEsRUFDaENFLGVBQWVLLGFBQWFMLFlBQVksRUFDeEMxRSxxQkFBcUIrRSxhQUFhL0Usa0JBQWtCLEVBQUUseUJBQXlCO1FBR25GLElBQUlrRixrQkFBa0IvUCxhQUFhdVAsZUFBZSxvQkFBb0I7UUFFdEUsSUFBSTNDLFVBQVV0VCxNQUFNK0csV0FBVyxDQUFDLFNBQVV3TSxLQUFLLEVBQUVTLE1BQU07WUFDckQseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ0EsT0FBT3hLLElBQUksRUFBRTtnQkFDaEJqRSxRQUFRMUUsSUFBSSxDQUFDO29CQUNYbVQsUUFBUUE7Z0JBQ1Y7Z0JBQ0EsTUFBTSxJQUFJeE8sTUFBTTtZQUNsQixFQUFFLDRDQUE0QztZQUc5QyxPQUFPLEVBQUUsQ0FBQ1QsTUFBTSxDQUFDOFAsV0FBV3ZELGFBQWEsRUFBRXBOLE1BQU1ZLE9BQU8sQ0FBQzJSLHFCQUFxQkEsb0JBQW9CO2dCQUFDQTthQUFrQixFQUFFclMsTUFBTSxDQUFDLFNBQVVzUyxDQUFDLEVBQUVDLE9BQU87Z0JBQ2hKLE9BQU9BLFFBQVFELEdBQUcxQyxRQUFRVCxPQUFPeUIsa0JBQWtCMEI7WUFDckQsR0FBR25EO1FBQ0wsR0FBRztZQUFDc0I7WUFBVTRCO1lBQWlCekI7U0FBWSxHQUFHLG9CQUFvQjtRQUVsRSxJQUFJNEIsb0JBQW9CNVcsTUFBTTZXLFVBQVUsQ0FBQ3ZELFNBQVM3UixXQUFXO1lBQzNELE9BQU82UixRQUFRWSxjQUFjO2dCQUMzQjFLLE1BQU12RyxRQUFRQyxJQUFJO1lBQ3BCO1FBQ0YsSUFDSTRULGVBQWVGLGlCQUFpQixDQUFDLEVBQUUsRUFDbkNoQyxXQUFXZ0MsaUJBQWlCLENBQUMsRUFBRSxFQUFFLHVEQUF1RDtRQUc1RixJQUFJckQsUUFBUXBPLFlBQVksRUFBRSxDQUFDSixNQUFNLENBQUM4UCxXQUFXdEQsa0JBQWtCLEVBQUU7WUFBQ0E7U0FBbUIsR0FBR3VGLGNBQWM7WUFDcEd4TixVQUFVMEw7UUFDWjtRQUNBL1UsT0FBTzBCLE1BQU0sQ0FBQ3FULGVBQWU7WUFDM0J6QixPQUFPQTtZQUNQcUIsVUFBVUE7UUFDWixJQUFJLDJCQUEyQjtRQUUvQixJQUFJdkssVUFBVXJLLE1BQU0rVyxPQUFPLENBQUM7WUFDMUIsT0FBTzNNLG9CQUFvQmpGLFlBQVkwUCxXQUFXeEssT0FBTyxFQUFFbU0sYUFBYTtnQkFDdEVsTixVQUFVMEw7WUFDWjtRQUNGLEdBQUc7WUFBQ0g7WUFBVUc7WUFBYXdCO1NBQVksQ0FBQ3pSLE1BQU0sQ0FBQ0ksWUFBWTBQLFdBQVdyRCxXQUFXLEVBQUUsRUFBRSxFQUFFO1lBQ3JGbEksVUFBVTBMO1FBQ1o7UUFDQUEsY0FBYzNLLE9BQU8sR0FBR0EsU0FBUywrREFBK0Q7UUFDaEcsd0RBQXdEO1FBRXhELElBQUltQixhQUFheEwsTUFBTStXLE9BQU8sQ0FBQztZQUM3QixPQUFPNVIsWUFBWTBQLFdBQVdySixVQUFVLEVBQUVkLGVBQWVMLFVBQVU7Z0JBQ2pFZixVQUFVMEw7WUFDWixHQUFHeEssR0FBRyxDQUFDQztRQUNULEdBQUc7WUFBQ0o7WUFBU3dLO1lBQVVHO1NBQVksQ0FBQ2pRLE1BQU0sQ0FBQ0ksWUFBWTBQLFdBQVdwRCxjQUFjLEVBQUUsRUFBRSxFQUFFO1lBQ3BGbkksVUFBVTBMO1FBQ1o7UUFDQUEsY0FBY3hKLFVBQVUsR0FBR0EsWUFBWSw2Q0FBNkM7UUFFcEYsSUFBSXdMLGlCQUFpQmhYLE1BQU0rVyxPQUFPLENBQUM7WUFDakMsSUFBSTlJLE9BQU8sRUFBRTtZQUNiLElBQUlnSixXQUFXLEVBQUU7WUFDakIsSUFBSUMsV0FBVyxDQUFDO1lBQ2hCLElBQUlDLGtCQUFrQixFQUFFLENBQUNwUyxNQUFNLENBQUN5RztZQUVoQyxNQUFPMkwsZ0JBQWdCclYsTUFBTSxDQUFFO2dCQUM3QixJQUFJeUgsU0FBUzROLGdCQUFnQkMsS0FBSztnQkFDbENDLG9CQUFvQjtvQkFDbEJkLE1BQU1BO29CQUNOdEksTUFBTUE7b0JBQ05nSixVQUFVQTtvQkFDVkMsVUFBVUE7b0JBQ1YzTixRQUFRQTtvQkFDUndNLFVBQVVBO29CQUNWRixZQUFZQTtvQkFDWnlCLGtCQUFrQnpDLFdBQVduRCxXQUFXO29CQUN4Q3NELGFBQWFBO2dCQUNmO1lBQ0Y7WUFFQSxPQUFPO2dCQUFDL0c7Z0JBQU1nSjtnQkFBVUM7YUFBUztRQUNuQyxHQUFHO1lBQUMxTDtZQUFZK0s7WUFBTVI7WUFBVUY7WUFBWWhCO1lBQVVHO1NBQVksR0FDOUQvRyxPQUFPK0ksY0FBYyxDQUFDLEVBQUUsRUFDeEJDLFdBQVdELGNBQWMsQ0FBQyxFQUFFLEVBQzVCRSxXQUFXRixjQUFjLENBQUMsRUFBRTtRQUVoQy9XLE9BQU8wQixNQUFNLENBQUNxVCxlQUFlO1lBQzNCL0csTUFBTUE7WUFDTnNKLGFBQWEsRUFBRSxDQUFDeFMsTUFBTSxDQUFDa0o7WUFDdkJnSixVQUFVQTtZQUNWQyxVQUFVQSxTQUFTLHVCQUF1QjtRQUU1QztRQUNBelIsVUFBVW9QLFdBQVdoRCxvQkFBb0IsRUFBRW1ELGdCQUFnQixrREFBa0Q7UUFDN0csZ0RBQWdEO1FBQ2hELHdEQUF3RDtRQUV4RCxJQUFJbEQsaUJBQWlCOVIsTUFBTStXLE9BQU8sQ0FBQztZQUNqQyxPQUFPNVIsWUFBWTBQLFdBQVcvQyxjQUFjLEVBQUV0RyxZQUFZO2dCQUN4RGxDLFVBQVUwTDtZQUNaLEdBQUd4SyxHQUFHLENBQUMsU0FBVTRCLENBQUM7Z0JBQ2hCLE9BQU9qQixlQUFlaUIsR0FBRzNJO1lBQzNCO1FBQ0YsR0FBRztZQUFDb1I7WUFBVXJKO1lBQVl3SjtZQUFhdlI7U0FBYyxDQUFDc0IsTUFBTSxDQUFDSSxZQUFZMFAsV0FBVzlDLGtCQUFrQixFQUFFLEVBQUUsRUFBRTtZQUMxR3pJLFVBQVUwTDtRQUNaLE1BQU0sK0NBQStDO1FBRXJEeEosYUFBYXhMLE1BQU0rVyxPQUFPLENBQUM7WUFDekIsSUFBSTFNLFVBQVUsRUFBRSxDQUFDdEYsTUFBTSxDQUFDK007WUFDeEJ0RyxXQUFXN0YsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO2dCQUNqQyxJQUFJLENBQUNjLFFBQVFtTixJQUFJLENBQUMsU0FBVXBMLENBQUM7b0JBQzNCLE9BQU9BLEVBQUV4QixFQUFFLEtBQUtyQixPQUFPcUIsRUFBRTtnQkFDM0IsSUFBSTtvQkFDRlAsUUFBUXFDLElBQUksQ0FBQ25EO2dCQUNmO1lBQ0Y7WUFDQSxPQUFPYztRQUNULEdBQUc7WUFBQ21CO1lBQVlzRztTQUFlO1FBQy9Ca0QsY0FBY3hKLFVBQVUsR0FBR0E7UUFFM0I7WUFDRSxJQUFJaU0sbUJBQW1Cak0sV0FBV3NELE1BQU0sQ0FBQyxTQUFVdkYsTUFBTSxFQUFFMUgsQ0FBQztnQkFDMUQsT0FBTzJKLFdBQVdyRixTQUFTLENBQUMsU0FBVWlHLENBQUM7b0JBQ3JDLE9BQU9BLEVBQUV4QixFQUFFLEtBQUtyQixPQUFPcUIsRUFBRTtnQkFDM0IsT0FBTy9JO1lBQ1Q7WUFFQSxJQUFJNFYsaUJBQWlCM1YsTUFBTSxFQUFFO2dCQUMzQnlELFFBQVExRSxJQUFJLENBQUMySztnQkFDYixNQUFNLElBQUloRyxNQUFNLDZDQUE4Q2lTLGlCQUFpQmpOLEdBQUcsQ0FBQyxTQUFVNEIsQ0FBQztvQkFDNUYsT0FBT0EsRUFBRXhCLEVBQUU7Z0JBQ2IsR0FBR3FGLElBQUksQ0FBQyxRQUFRO1lBQ2xCO1FBQ0Y7UUFHQSxJQUFJdkUsZUFBZTFMLE1BQU0rVyxPQUFPLENBQUM7WUFDL0IsT0FBTzVSLFlBQVkwUCxXQUFXbkosWUFBWSxFQUFFSCxpQkFBaUJ1RyxnQkFBZ0JyTyxnQkFBZ0J1UjtRQUMvRixHQUFHO1lBQUNIO1lBQVUvQztZQUFnQnJPO1lBQWV1UjtTQUFZLENBQUNqUSxNQUFNLENBQUNJLFlBQVkwUCxXQUFXN0MsZ0JBQWdCLEVBQUUsRUFBRSxFQUFFO1lBQzVHMUksVUFBVTBMO1FBQ1o7UUFDQUEsY0FBY3RKLFlBQVksR0FBR0EsY0FBYyxpQ0FBaUM7UUFFNUUsSUFBSU0sVUFBVWhNLE1BQU0rVyxPQUFPLENBQUM7WUFDMUIsT0FBT3JMLGFBQWE1SixNQUFNLEdBQUc0SixZQUFZLENBQUMsRUFBRSxDQUFDTSxPQUFPLEdBQUcsRUFBRTtRQUMzRCxHQUFHO1lBQUNOO1NBQWE7UUFDakJzSixjQUFjaEosT0FBTyxHQUFHQSxTQUFTLDJDQUEyQztRQUU1RWdKLGNBQWNMLFdBQVcsR0FBR2pKLGFBQWF0SCxNQUFNLENBQUMsU0FBVXNULEdBQUcsRUFBRTNMLFdBQVc7WUFDeEUsT0FBTyxFQUFFLENBQUNoSCxNQUFNLENBQUMyUyxLQUFLM0wsWUFBWUMsT0FBTztRQUMzQyxHQUFHLEVBQUU7UUFDTHZHLFVBQVVvUCxXQUFXNUMsMkJBQTJCLEVBQUUrQyxnQkFBZ0Isc0NBQXNDO1FBRXhHLElBQUkyQyxvQkFBb0I3RixlQUFlaEQsTUFBTSxDQUFDLFNBQVUxQyxDQUFDO1lBQ3ZELE9BQU9BLEVBQUV3SCxTQUFTO1FBQ3BCLEdBQUdwSixHQUFHLENBQUMsU0FBVTRCLENBQUM7WUFDaEIsT0FBT0EsRUFBRXhCLEVBQUU7UUFDYixHQUFHZ04sSUFBSSxHQUFHM0gsSUFBSSxDQUFDO1FBQ2Y2QixpQkFBaUI5UixNQUFNK1csT0FBTyxDQUFDO1lBQzdCLE9BQU9qRixlQUFlaEQsTUFBTSxDQUFDLFNBQVUxQyxDQUFDO2dCQUN0QyxPQUFPQSxFQUFFd0gsU0FBUztZQUNwQjtRQUNGLEdBQ0E7WUFBQzlCO1lBQWdCNkY7U0FBa0I7UUFDbkMzQyxjQUFjbEQsY0FBYyxHQUFHQSxnQkFBZ0IsNENBQTRDO1FBRTNGLElBQUkrRix3QkFBd0JDLHNCQUFzQjlMLFVBQzlDK0wsdUJBQXVCRixxQkFBcUIsQ0FBQyxFQUFFLEVBQy9DRyxvQkFBb0JILHFCQUFxQixDQUFDLEVBQUUsRUFDNUNJLHVCQUF1QkoscUJBQXFCLENBQUMsRUFBRTtRQUVuRDdDLGNBQWMrQyxvQkFBb0IsR0FBR0E7UUFDckMvQyxjQUFjZ0QsaUJBQWlCLEdBQUdBO1FBQ2xDaEQsY0FBY2lELG9CQUFvQixHQUFHQTtRQUNyQ3hTLFVBQVVvUCxXQUFXM0MsV0FBVyxFQUFFOEMsZUFBZSw0RUFBNEU7O1FBRzdILEVBQUUsQ0FBQ2pRLE1BQU0sQ0FBQ2lRLGNBQWNMLFdBQVcsRUFBRUssY0FBY3hKLFVBQVUsRUFBRTdGLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtZQUNyRix1Q0FBdUM7WUFDdkNBLE9BQU8yTyxNQUFNLEdBQUc3TyxhQUFhMkwsZUFBZXpMLFNBQVMsZ0RBQWdEO1lBRXJHQSxPQUFPaUosY0FBYyxHQUFHeE4sZUFBZTZQLFdBQVdyQyxjQUFjLEVBQUU7Z0JBQ2hFbEosVUFBVTBMO2dCQUNWekwsUUFBUUE7WUFDVixJQUFJLGdEQUFnRDtZQUVwREEsT0FBT2tKLGNBQWMsR0FBR3pOLGVBQWU2UCxXQUFXcEMsY0FBYyxFQUFFO2dCQUNoRW5KLFVBQVUwTDtnQkFDVnpMLFFBQVFBO1lBQ1Y7UUFDRjtRQUNBeUwsY0FBY3RKLFlBQVksR0FBRzFMLE1BQU0rVyxPQUFPLENBQUM7WUFDekMsT0FBT3JMLGFBQWFvRCxNQUFNLENBQUMsU0FBVS9DLFdBQVcsRUFBRWxLLENBQUM7Z0JBQ2pELDBFQUEwRTtnQkFDMUVrSyxZQUFZQyxPQUFPLEdBQUdELFlBQVlDLE9BQU8sQ0FBQzhDLE1BQU0sQ0FBQyxTQUFVdkYsTUFBTTtvQkFDL0QsSUFBSXdFLFVBQVUsU0FBU0EsUUFBUS9CLE9BQU87d0JBQ3BDLE9BQU9BLFFBQVE4QyxNQUFNLENBQUMsU0FBVXZGLE1BQU07NEJBQ3BDLElBQUlBLE9BQU95QyxPQUFPLEVBQUU7Z0NBQ2xCLE9BQU8rQixRQUFReEUsT0FBT3lDLE9BQU87NEJBQy9COzRCQUVBLE9BQU96QyxPQUFPcUssU0FBUzt3QkFDekIsR0FBRzlSLE1BQU07b0JBQ1g7b0JBRUEsSUFBSXlILE9BQU95QyxPQUFPLEVBQUU7d0JBQ2xCLE9BQU8rQixRQUFReEUsT0FBT3lDLE9BQU87b0JBQy9CO29CQUVBLE9BQU96QyxPQUFPcUssU0FBUztnQkFDekIsSUFBSSxnQ0FBZ0M7Z0JBRXBDLElBQUk3SCxZQUFZQyxPQUFPLENBQUNsSyxNQUFNLEVBQUU7b0JBQzlCaUssWUFBWXVHLG1CQUFtQixHQUFHdE4sZUFBZTZQLFdBQVd2QyxtQkFBbUIsRUFBRTt3QkFDL0VoSixVQUFVMEw7d0JBQ1ZqSixhQUFhQTt3QkFDYjZFLE9BQU8vTztvQkFDVDtvQkFDQWtLLFlBQVl3RyxtQkFBbUIsR0FBR3ZOLGVBQWU2UCxXQUFXdEMsbUJBQW1CLEVBQUU7d0JBQy9FakosVUFBVTBMO3dCQUNWakosYUFBYUE7d0JBQ2I2RSxPQUFPL087b0JBQ1Q7b0JBQ0EsT0FBTztnQkFDVDtnQkFFQSxPQUFPO1lBQ1Q7UUFDRixHQUFHO1lBQUM2SjtZQUFjc0o7WUFBYUg7U0FBUztRQUN4Q0csY0FBY21ELFlBQVksR0FBRyxFQUFFLENBQUNwVCxNQUFNLENBQUNpUSxjQUFjdEosWUFBWSxFQUFFWSxPQUFPLElBQUksd0VBQXdFO1FBQ3RKLDRDQUE0QztRQUU1QzBJLGNBQWM3QyxVQUFVLEdBQUduUyxNQUFNK0csV0FBVyxDQUFDLFNBQVVrRSxHQUFHO1lBQ3hEQSxJQUFJeUgsV0FBVyxHQUFHMU4sZUFBZTZQLFdBQVduQyxXQUFXLEVBQUU7Z0JBQ3ZEcEosVUFBVTBMO2dCQUNWL0osS0FBS0E7WUFDUCxJQUFJLHVDQUF1QztZQUUzQ0EsSUFBSW1OLFFBQVEsR0FBRzVNLFdBQVdoQixHQUFHLENBQUMsU0FBVWpCLE1BQU07Z0JBQzVDLElBQUl6SSxRQUFRbUssSUFBSW9OLE1BQU0sQ0FBQzlPLE9BQU9xQixFQUFFLENBQUM7Z0JBQ2pDLElBQUl1RyxPQUFPO29CQUNUNUgsUUFBUUE7b0JBQ1IwQixLQUFLQTtvQkFDTG5LLE9BQU9BO2dCQUNULEdBQUcscUNBQXFDO2dCQUV4Q3FRLEtBQUt3QixZQUFZLEdBQUczTixlQUFlNlAsV0FBV2xDLFlBQVksRUFBRTtvQkFDMURySixVQUFVMEw7b0JBQ1Y3RCxNQUFNQTtnQkFDUixJQUFJLG1FQUFtRTtnQkFFdkVBLEtBQUsrRyxNQUFNLEdBQUc3TyxhQUFhMkwsZUFBZXpMLFFBQVE7b0JBQ2hEMEIsS0FBS0E7b0JBQ0xrRyxNQUFNQTtvQkFDTnJRLE9BQU9BO2dCQUNUO2dCQUNBLE9BQU9xUTtZQUNUO1lBQ0FsRyxJQUFJcU4sS0FBSyxHQUFHeEcsZUFBZXRILEdBQUcsQ0FBQyxTQUFVakIsTUFBTTtnQkFDN0MsT0FBTzBCLElBQUltTixRQUFRLENBQUNaLElBQUksQ0FBQyxTQUFVckcsSUFBSTtvQkFDckMsT0FBT0EsS0FBSzVILE1BQU0sQ0FBQ3FCLEVBQUUsS0FBS3JCLE9BQU9xQixFQUFFO2dCQUNyQztZQUNGLElBQUksbUVBQW1FO1lBRXZFbkYsVUFBVW9QLFdBQVcxQyxVQUFVLEVBQUVsSCxLQUFLO2dCQUNwQzNCLFVBQVUwTDtZQUNaO1FBQ0YsR0FBRztZQUFDSDtZQUFVRztZQUFheEo7WUFBWXNHO1NBQWU7UUFDdERrRCxjQUFjNUMsYUFBYSxHQUFHcE4sZUFBZTZQLFdBQVd6QyxhQUFhLEVBQUU7WUFDckU5SSxVQUFVMEw7UUFDWjtRQUNBQSxjQUFjM0MsaUJBQWlCLEdBQUdyTixlQUFlNlAsV0FBV3hDLGlCQUFpQixFQUFFO1lBQzdFL0ksVUFBVTBMO1FBQ1o7UUFDQXZQLFVBQVVvUCxXQUFXakMsZ0JBQWdCLEVBQUVvQztRQUN2QyxPQUFPQTtJQUNUO0lBRUEsU0FBUzhDLHNCQUFzQjlMLE9BQU8sRUFBRXVNLElBQUk7UUFDMUMsSUFBSUEsU0FBUyxLQUFLLEdBQUc7WUFDbkJBLE9BQU87UUFDVDtRQUVBLElBQUlDLG1CQUFtQjtRQUN2QixJQUFJQyxnQkFBZ0I7UUFDcEIsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlDLG9CQUFvQjtRQUN4QjNNLFFBQVFyRyxPQUFPLENBQUMsU0FBVWlULE1BQU07WUFDOUIsSUFBSUMsYUFBYUQsT0FBTzVNLE9BQU87WUFDL0I0TSxPQUFPRSxTQUFTLEdBQUdQO1lBRW5CLElBQUlNLGNBQWNBLFdBQVcvVyxNQUFNLEVBQUU7Z0JBQ25DLElBQUlpWCx5QkFBeUJqQixzQkFBc0JlLFlBQVlOLE9BQzNEUyxnQkFBZ0JELHNCQUFzQixDQUFDLEVBQUUsRUFDekNFLGFBQWFGLHNCQUFzQixDQUFDLEVBQUUsRUFDdENHLGdCQUFnQkgsc0JBQXNCLENBQUMsRUFBRSxFQUN6Q0ksaUJBQWlCSixzQkFBc0IsQ0FBQyxFQUFFO2dCQUU5Q0gsT0FBT0ksYUFBYSxHQUFHQTtnQkFDdkJKLE9BQU9LLFVBQVUsR0FBR0E7Z0JBQ3BCTCxPQUFPTSxhQUFhLEdBQUdBO2dCQUN2Qk4sT0FBT08sY0FBYyxHQUFHQTtZQUMxQixPQUFPO2dCQUNMUCxPQUFPSSxhQUFhLEdBQUdKLE9BQU9oVixRQUFRO2dCQUN0Q2dWLE9BQU9LLFVBQVUsR0FBR0csS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUNWLE9BQU9oVixRQUFRLEVBQUVnVixPQUFPalYsS0FBSyxHQUFHaVYsT0FBTy9VLFFBQVE7Z0JBQ3JGK1UsT0FBT00sYUFBYSxHQUFHTixPQUFPL1UsUUFBUTtnQkFDdEMrVSxPQUFPTyxjQUFjLEdBQUdQLE9BQU9XLFNBQVMsR0FBR1gsT0FBT0ssVUFBVSxHQUFHO1lBQ2pFO1lBRUEsSUFBSUwsT0FBT2hGLFNBQVMsRUFBRTtnQkFDcEIyRSxRQUFRSyxPQUFPSyxVQUFVO2dCQUN6QlQsb0JBQW9CSSxPQUFPSSxhQUFhO2dCQUN4Q1AsaUJBQWlCRyxPQUFPSyxVQUFVO2dCQUNsQ1Asb0JBQW9CRSxPQUFPTSxhQUFhO2dCQUN4Q1AscUJBQXFCQyxPQUFPTyxjQUFjO1lBQzVDO1FBQ0Y7UUFDQSxPQUFPO1lBQUNYO1lBQWtCQztZQUFlQztZQUFrQkM7U0FBa0I7SUFDL0U7SUFFQSxTQUFTdEIsb0JBQW9CalUsSUFBSTtRQUMvQixJQUFJbVQsT0FBT25ULEtBQUttVCxJQUFJLEVBQ2hCdEksT0FBTzdLLEtBQUs2SyxJQUFJLEVBQ2hCZ0osV0FBVzdULEtBQUs2VCxRQUFRLEVBQ3hCQyxXQUFXOVQsS0FBSzhULFFBQVEsRUFDeEIzTixTQUFTbkcsS0FBS21HLE1BQU0sRUFDcEJ3TSxXQUFXM1MsS0FBSzJTLFFBQVEsRUFDeEJGLGFBQWF6UyxLQUFLeVMsVUFBVSxFQUM1QnlCLG1CQUFtQmxVLEtBQUtrVSxnQkFBZ0IsRUFDeEN0QyxjQUFjNVIsS0FBSzRSLFdBQVc7UUFFbEMseUNBQXlDO1FBQ3pDLDZEQUE2RDtRQUM3RCwyREFBMkQ7UUFDM0QsSUFBSXdFLFlBQVksU0FBU0EsVUFBVUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVuUCxLQUFLLEVBQUVELE1BQU0sRUFBRXFQLFVBQVU7WUFDakYsSUFBSXBQLFVBQVUsS0FBSyxHQUFHO2dCQUNwQkEsUUFBUTtZQUNWO1lBRUEscUNBQXFDO1lBQ3JDLElBQUltRSxXQUFXK0s7WUFDZixJQUFJN08sS0FBS21MLFNBQVMwRCxhQUFhQyxVQUFVcFA7WUFDekMsSUFBSVcsTUFBTWlNLFFBQVEsQ0FBQ3RNLEdBQUcsRUFBRSxnREFBZ0Q7WUFFeEUsSUFBSSxDQUFDSyxLQUFLO2dCQUNSQSxNQUFNO29CQUNKTCxJQUFJQTtvQkFDSjhELFVBQVVBO29CQUNWa0MsT0FBTzhJO29CQUNQblAsT0FBT0E7b0JBQ1ArTixPQUFPO3dCQUFDLENBQUM7cUJBQUUsQ0FBQyx1QkFBdUI7Z0JBRXJDLEdBQUcsK0VBQStFO2dCQUNsRixnRUFBZ0U7Z0JBRWhFck4sSUFBSXFOLEtBQUssQ0FBQzlOLEdBQUcsR0FBRzRFO2dCQUNoQm5FLElBQUlxTixLQUFLLENBQUN4SixNQUFNLEdBQUdNO2dCQUNuQm5FLElBQUlxTixLQUFLLENBQUMzUyxPQUFPLEdBQUd5SjtnQkFDcEJuRSxJQUFJcU4sS0FBSyxDQUFDLEVBQUUsQ0FBQzNGLFlBQVksR0FBR3ZELHlCQUF5Qiw4QkFBOEI7Z0JBRW5GbkUsSUFBSW9OLE1BQU0sR0FBRyxDQUFDLEdBQUcsMENBQTBDO2dCQUUzRHNCLFdBQVdqTixJQUFJLENBQUN6QixNQUFNLDBDQUEwQztnQkFFaEVnTSxTQUFTdkssSUFBSSxDQUFDekIsTUFBTSx5Q0FBeUM7Z0JBRTdEaU0sUUFBUSxDQUFDdE0sR0FBRyxHQUFHSyxLQUFLLDJCQUEyQjtnQkFFL0NBLElBQUkyTyxlQUFlLEdBQUcvRCxXQUFXNEQsYUFBYUMsV0FBVywrQkFBK0I7Z0JBRXhGLElBQUl6TyxJQUFJMk8sZUFBZSxFQUFFO29CQUN2QixJQUFJaEwsVUFBVSxFQUFFO29CQUNoQjNELElBQUkyTyxlQUFlLENBQUNqVSxPQUFPLENBQUMsU0FBVXlHLENBQUMsRUFBRXZLLENBQUM7d0JBQ3hDLE9BQU8yWCxVQUFVcE4sR0FBR3ZLLEdBQUcwSSxRQUFRLEdBQUdVLEtBQUsyRDtvQkFDekMsSUFBSSx3Q0FBd0M7b0JBRTVDM0QsSUFBSTJELE9BQU8sR0FBR0E7Z0JBQ2hCO1lBQ0YsT0FBTyxJQUFJM0QsSUFBSTJELE9BQU8sRUFBRTtnQkFDdEIscURBQXFEO2dCQUNyRCxvREFBb0Q7Z0JBQ3BELDhDQUE4QztnQkFDOUMzRCxJQUFJMk8sZUFBZSxDQUFDalUsT0FBTyxDQUFDLFNBQVV5RyxDQUFDLEVBQUV2SyxDQUFDO29CQUN4QyxPQUFPMlgsVUFBVXBOLEdBQUd2SyxHQUFHMEksUUFBUSxHQUFHVTtnQkFDcEM7WUFDRixFQUFFLHVEQUF1RDtZQUd6RCxJQUFJMUIsT0FBT3NCLFFBQVEsRUFBRTtnQkFDbkJJLElBQUlvTixNQUFNLENBQUM5TyxPQUFPcUIsRUFBRSxDQUFDLEdBQUdyQixPQUFPc0IsUUFBUSxDQUFDNE8sYUFBYUMsVUFBVXpPLEtBQUswTyxZQUFZcEQ7WUFDbEYsRUFBRSwrQ0FBK0M7WUFHakR0TCxJQUFJb04sTUFBTSxDQUFDOU8sT0FBT3FCLEVBQUUsQ0FBQyxHQUFHekYsWUFBWW1TLGtCQUFrQnJNLElBQUlvTixNQUFNLENBQUM5TyxPQUFPcUIsRUFBRSxDQUFDLEVBQUU7Z0JBQzNFSyxLQUFLQTtnQkFDTDFCLFFBQVFBO2dCQUNSRCxVQUFVMEw7WUFDWixHQUFHO1FBQ0w7UUFFQXVCLEtBQUs1USxPQUFPLENBQUMsU0FBVThULFdBQVcsRUFBRUMsUUFBUTtZQUMxQyxPQUFPRixVQUFVQyxhQUFhQyxVQUFVLEdBQUdqWSxXQUFXd007UUFDeEQ7SUFDRjtJQUVBaEwsUUFBUTRXLGFBQWEsR0FBRztJQUN4QjVXLFFBQVE2VyxpQkFBaUIsR0FBRztJQUM1QjdXLFFBQVE4VyxxQkFBcUIsR0FBRztJQUNoQyxJQUFJQyxjQUFjLFNBQVNBLFlBQVkvVSxLQUFLO1FBQzFDQSxNQUFNZ1YsNkJBQTZCLEdBQUc7WUFBQ0M7U0FBcUM7UUFDNUVqVixNQUFNa1YseUJBQXlCLEdBQUc7WUFBQ0M7U0FBaUM7UUFDcEVuVixNQUFNcU0sYUFBYSxDQUFDNUUsSUFBSSxDQUFDMk47UUFDekJwVixNQUFNaU4sV0FBVyxDQUFDeEYsSUFBSSxDQUFDNE47UUFDdkJyVixNQUFNa04sVUFBVSxDQUFDekYsSUFBSSxDQUFDeUY7SUFDeEI7SUFDQTZILFlBQVloVSxVQUFVLEdBQUc7SUFFekIsSUFBSWtVLHVDQUF1QyxTQUFTQSxxQ0FBcUM3VixLQUFLLEVBQUVqQixJQUFJO1FBQ2xHLElBQUlrRyxXQUFXbEcsS0FBS2tHLFFBQVE7UUFDNUIsT0FBTztZQUFDakY7WUFBTztnQkFDYmtXLFNBQVMsU0FBU0EsUUFBUTlNLENBQUM7b0JBQ3pCbkUsU0FBU3lRLHFCQUFxQjtnQkFDaEM7Z0JBQ0F4VixPQUFPO29CQUNMZ0osUUFBUTtnQkFDVjtnQkFDQXNHLE9BQU87WUFDVDtTQUFFO0lBQ0o7SUFFQSxJQUFJdUcsbUNBQW1DLFNBQVNBLGlDQUFpQy9WLEtBQUssRUFBRXdELEtBQUs7UUFDM0YsSUFBSW9ELE1BQU1wRCxNQUFNb0QsR0FBRztRQUNuQixPQUFPO1lBQUM1RztZQUFPO2dCQUNia1csU0FBUyxTQUFTQTtvQkFDaEJ0UCxJQUFJNk8saUJBQWlCO2dCQUN2QjtnQkFDQXZWLE9BQU87b0JBQ0xnSixRQUFRO2dCQUNWO2dCQUNBc0csT0FBTztZQUNUO1NBQUU7SUFDSixHQUFHLFVBQVU7SUFHYixTQUFTd0csVUFBVTlHLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkeU0sVUFBVSxDQUFDO1lBQ2IsR0FBR29GO1FBQ0w7UUFFQSxJQUFJUyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUTRXLGFBQWEsRUFBRTtZQUN6QyxPQUFPblksU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QnBGLFVBQVU3RSxTQUFTNEssWUFBWSxDQUFDL0YsUUFBUSxJQUFJLENBQUM7WUFDL0M7UUFDRjtRQUVBLElBQUk2RixPQUFPeEssSUFBSSxLQUFLdkcsUUFBUThXLHFCQUFxQixFQUFFO1lBQ2pELElBQUlqWixRQUFRa1QsT0FBT2xULEtBQUs7WUFDeEIsSUFBSW9XLFdBQVc1TixTQUFTNE4sUUFBUTtZQUNoQyxJQUFJc0Qsb0JBQW9CdmEsT0FBT2tDLElBQUksQ0FBQytVLFVBQVVwVixNQUFNLEtBQUs3QixPQUFPa0MsSUFBSSxDQUFDb1IsTUFBTXBGLFFBQVEsRUFBRXJNLE1BQU07WUFDM0YsSUFBSTJZLFlBQVksT0FBTzNaLFVBQVUsY0FBY0EsUUFBUSxDQUFDMFo7WUFFeEQsSUFBSUMsV0FBVztnQkFDYixJQUFJdE0sV0FBVyxDQUFDO2dCQUNoQmxPLE9BQU9rQyxJQUFJLENBQUMrVSxVQUFVdlIsT0FBTyxDQUFDLFNBQVUrVSxLQUFLO29CQUMzQ3ZNLFFBQVEsQ0FBQ3VNLE1BQU0sR0FBRztnQkFDcEI7Z0JBQ0EsT0FBT2haLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztvQkFDekJwRixVQUFVQTtnQkFDWjtZQUNGO1lBRUEsT0FBT3pNLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJwRixVQUFVLENBQUM7WUFDYjtRQUNGO1FBRUEsSUFBSTZGLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRNlcsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSWxQLEtBQUtvSixPQUFPcEosRUFBRSxFQUNkK1AsY0FBYzNHLE9BQU9sVCxLQUFLO1lBQzlCLElBQUk4WixTQUFTckgsTUFBTXBGLFFBQVEsQ0FBQ3ZELEdBQUc7WUFDL0IsSUFBSWlRLGNBQWMsT0FBT0YsZ0JBQWdCLGNBQWNBLGNBQWMsQ0FBQ0M7WUFFdEUsSUFBSSxDQUFDQSxVQUFVQyxhQUFhO2dCQUMxQixJQUFJQztnQkFFSixPQUFPcFosU0FBUyxDQUFDLEdBQUc2UixPQUFPO29CQUN6QnBGLFVBQVV6TSxTQUFTLENBQUMsR0FBRzZSLE1BQU1wRixRQUFRLEVBQUcyTSxDQUFBQSxZQUFZLENBQUMsR0FBR0EsU0FBUyxDQUFDbFEsR0FBRyxHQUFHLE1BQU1rUSxTQUFRO2dCQUN4RjtZQUNGLE9BQU8sSUFBSUYsVUFBVSxDQUFDQyxhQUFhO2dCQUNqQyxJQUFJRSxrQkFBa0J4SCxNQUFNcEYsUUFBUSxFQUNoQzZNLElBQUlELGVBQWUsQ0FBQ25RLEdBQUcsRUFDdkJuRyxPQUFPekMsOEJBQThCK1ksaUJBQWlCO29CQUFDblE7aUJBQUcsQ0FBQ0osR0FBRyxDQUFDekg7Z0JBRW5FLE9BQU9yQixTQUFTLENBQUMsR0FBRzZSLE9BQU87b0JBQ3pCcEYsVUFBVTFKO2dCQUNaO1lBQ0YsT0FBTztnQkFDTCxPQUFPOE87WUFDVDtRQUNGO0lBQ0Y7SUFFQSxTQUFTK0csY0FBY2hSLFFBQVE7UUFDN0IsSUFBSWlOLE9BQU9qTixTQUFTaU4sSUFBSSxFQUNwQnRJLE9BQU8zRSxTQUFTMkUsSUFBSSxFQUNwQmlKLFdBQVc1TixTQUFTNE4sUUFBUSxFQUM1QitELHdCQUF3QjNSLFNBQVM0RSxpQkFBaUIsRUFDbERBLG9CQUFvQitNLDBCQUEwQixLQUFLLElBQUksYUFBYUEsdUJBQ3BFQyx3QkFBd0I1UixTQUFTNlIsb0JBQW9CLEVBQ3JEQSx1QkFBdUJELDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQ2pFRSx3QkFBd0I5UixTQUFTK0UsYUFBYSxFQUM5Q0EsZ0JBQWdCK00sMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDMURDLHdCQUF3Qi9SLFNBQVNnUyxpQkFBaUIsRUFDbERBLG9CQUFvQkQsMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDOUR4RyxXQUFXdkwsU0FBU3VMLFFBQVEsRUFDNUIvTyxVQUFVd0QsU0FBU3hELE9BQU8sRUFDMUJxSSxXQUFXN0UsU0FBU2lLLEtBQUssQ0FBQ3BGLFFBQVEsRUFDbEN5RyxXQUFXdEwsU0FBU3NMLFFBQVE7UUFDaEMvTyxrQkFBa0JDLFNBQVM7WUFBQztZQUFhO1lBQWM7WUFBbUI7U0FBa0IsRUFBRTtRQUM5RixJQUFJeVYsdUJBQXVCN1UsYUFBYTRVO1FBQ3hDLElBQUlkLG9CQUFvQm5FLFFBQVFwVyxPQUFPa0MsSUFBSSxDQUFDK1UsVUFBVXBWLE1BQU0sSUFBSTdCLE9BQU9rQyxJQUFJLENBQUNnTSxVQUFVck0sTUFBTTtRQUU1RixJQUFJMFksbUJBQW1CO1lBQ3JCLElBQUl2YSxPQUFPa0MsSUFBSSxDQUFDK1UsVUFBVS9LLElBQUksQ0FBQyxTQUFVdkIsRUFBRTtnQkFDekMsT0FBTyxDQUFDdUQsUUFBUSxDQUFDdkQsR0FBRztZQUN0QixJQUFJO2dCQUNGNFAsb0JBQW9CO1lBQ3RCO1FBQ0YsRUFBRSxtREFBbUQ7UUFHckRwVCx1QkFBdUI7WUFDckIsSUFBSW1VLHdCQUF3QjtnQkFDMUIzRyxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVE0VyxhQUFhO2dCQUM3QjtZQUNGO1FBQ0YsR0FBRztZQUFDakY7WUFBVTJCO1NBQUs7UUFDbkIsSUFBSXVELG9CQUFvQjlaLE1BQU0rRyxXQUFXLENBQUMsU0FBVTZELEVBQUUsRUFBRTlKLEtBQUs7WUFDM0Q4VCxTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVE2VyxpQkFBaUI7Z0JBQy9CbFAsSUFBSUE7Z0JBQ0o5SixPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDOFQ7U0FBUztRQUNiLElBQUltRix3QkFBd0IvWixNQUFNK0csV0FBVyxDQUFDLFNBQVVqRyxLQUFLO1lBQzNELE9BQU84VCxTQUFTO2dCQUNkcEwsTUFBTXZHLFFBQVE4VyxxQkFBcUI7Z0JBQ25DalosT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJdEcsZUFBZXRPLE1BQU0rVyxPQUFPLENBQUM7WUFDL0IsSUFBSW9FLHNCQUFzQjtnQkFDeEIsT0FBT25OLFdBQVdDLE1BQU07b0JBQ3RCQyxtQkFBbUJBO29CQUNuQkMsVUFBVUE7b0JBQ1ZFLGVBQWVBO2dCQUNqQjtZQUNGO1lBRUEsT0FBT0o7UUFDVCxHQUFHO1lBQUNrTjtZQUFzQmxOO1lBQU1DO1lBQW1CQztZQUFVRTtTQUFjO1FBQzNFLElBQUltTixnQkFBZ0J4YixNQUFNK1csT0FBTyxDQUFDO1lBQ2hDLE9BQU8wRSxrQkFBa0J0TjtRQUMzQixHQUFHO1lBQUNBO1NBQVM7UUFDYixJQUFJNkcsY0FBY3RPLGFBQWE0QztRQUMvQixJQUFJMlEsZ0NBQWdDalYsZUFBZTZQLFdBQVdvRiw2QkFBNkIsRUFBRTtZQUMzRjNRLFVBQVUwTDtRQUNaO1FBQ0EvVSxPQUFPMEIsTUFBTSxDQUFDMkgsVUFBVTtZQUN0Qm9TLGlCQUFpQnpOO1lBQ2pCSyxjQUFjQTtZQUNkTCxNQUFNSztZQUNOa04sZUFBZUE7WUFDZmhCLG1CQUFtQkE7WUFDbkJWLG1CQUFtQkE7WUFDbkJDLHVCQUF1QkE7WUFDdkJFLCtCQUErQkE7UUFDakM7SUFDRjtJQUVBLFNBQVM5SCxXQUFXbEgsR0FBRyxFQUFFMEYsS0FBSztRQUM1QixJQUFJa0UsV0FBV2xFLE1BQU1ySCxRQUFRLENBQUN1TCxRQUFRLEVBQ2xDdkwsV0FBV3FILE1BQU1ySCxRQUFRO1FBRTdCMkIsSUFBSTZPLGlCQUFpQixHQUFHLFNBQVV6TSxHQUFHO1lBQ25DLE9BQU8vRCxTQUFTd1EsaUJBQWlCLENBQUM3TyxJQUFJTCxFQUFFLEVBQUV5QztRQUM1QztRQUVBcEMsSUFBSWtQLHlCQUF5QixHQUFHblYsZUFBZTZQLFdBQVdzRix5QkFBeUIsRUFBRTtZQUNuRjdRLFVBQVVBO1lBQ1YyQixLQUFLQTtRQUNQO0lBQ0Y7SUFFQSxTQUFTd1Esa0JBQWtCdE4sUUFBUTtRQUNqQyxJQUFJd04sV0FBVztRQUNmMWIsT0FBT2tDLElBQUksQ0FBQ2dNLFVBQVV4SSxPQUFPLENBQUMsU0FBVWlGLEVBQUU7WUFDeEMsSUFBSWdSLFVBQVVoUixHQUFHSSxLQUFLLENBQUM7WUFDdkIyUSxXQUFXdkMsS0FBS0UsR0FBRyxDQUFDcUMsVUFBVUMsUUFBUTlaLE1BQU07UUFDOUM7UUFDQSxPQUFPNlo7SUFDVDtJQUVBLElBQUkxTSxPQUFPLFNBQVNBLEtBQUtoQixJQUFJLEVBQUU0TixHQUFHLEVBQUVDLFdBQVc7UUFDN0M3TixPQUFPQSxLQUFLYSxNQUFNLENBQUMsU0FBVTdELEdBQUc7WUFDOUIsT0FBTzRRLElBQUkxUCxJQUFJLENBQUMsU0FBVXZCLEVBQUU7Z0JBQzFCLElBQUltUixXQUFXOVEsSUFBSW9OLE1BQU0sQ0FBQ3pOLEdBQUc7Z0JBQzdCLE9BQU8vSCxPQUFPa1osVUFBVUMsV0FBVyxHQUFHOVIsUUFBUSxDQUFDckgsT0FBT2laLGFBQWFFLFdBQVc7WUFDaEY7UUFDRjtRQUNBLE9BQU8vTjtJQUNUO0lBRUFnQixLQUFLRSxVQUFVLEdBQUcsU0FBVTdCLEdBQUc7UUFDN0IsT0FBTyxDQUFDQTtJQUNWO0lBRUEsSUFBSTJPLFlBQVksU0FBU0EsVUFBVWhPLElBQUksRUFBRTROLEdBQUcsRUFBRUMsV0FBVztRQUN2RCxPQUFPN04sS0FBS2EsTUFBTSxDQUFDLFNBQVU3RCxHQUFHO1lBQzlCLE9BQU80USxJQUFJMVAsSUFBSSxDQUFDLFNBQVV2QixFQUFFO2dCQUMxQixJQUFJbVIsV0FBVzlRLElBQUlvTixNQUFNLENBQUN6TixHQUFHO2dCQUM3QixPQUFPbVIsYUFBYXRhLFlBQVlvQixPQUFPa1osVUFBVUMsV0FBVyxPQUFPblosT0FBT2laLGFBQWFFLFdBQVcsS0FBSztZQUN6RztRQUNGO0lBQ0Y7SUFFQUMsVUFBVTlNLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUNsQyxPQUFPLENBQUNBO0lBQ1Y7SUFFQSxJQUFJNE8sZ0JBQWdCLFNBQVNBLGNBQWNqTyxJQUFJLEVBQUU0TixHQUFHLEVBQUVDLFdBQVc7UUFDL0QsT0FBTzdOLEtBQUthLE1BQU0sQ0FBQyxTQUFVN0QsR0FBRztZQUM5QixPQUFPNFEsSUFBSTFQLElBQUksQ0FBQyxTQUFVdkIsRUFBRTtnQkFDMUIsSUFBSW1SLFdBQVc5USxJQUFJb04sTUFBTSxDQUFDek4sR0FBRztnQkFDN0IsT0FBT21SLGFBQWF0YSxZQUFZb0IsT0FBT2taLGNBQWNsWixPQUFPaVosZUFBZTtZQUM3RTtRQUNGO0lBQ0Y7SUFFQUksY0FBYy9NLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUN0QyxPQUFPLENBQUNBO0lBQ1Y7SUFFQSxJQUFJcEQsV0FBVyxTQUFTQSxTQUFTK0QsSUFBSSxFQUFFNE4sR0FBRyxFQUFFQyxXQUFXO1FBQ3JELE9BQU83TixLQUFLYSxNQUFNLENBQUMsU0FBVTdELEdBQUc7WUFDOUIsT0FBTzRRLElBQUkxUCxJQUFJLENBQUMsU0FBVXZCLEVBQUU7Z0JBQzFCLElBQUltUixXQUFXOVEsSUFBSW9OLE1BQU0sQ0FBQ3pOLEdBQUc7Z0JBQzdCLE9BQU9tUixTQUFTN1IsUUFBUSxDQUFDNFI7WUFDM0I7UUFDRjtJQUNGO0lBRUE1UixTQUFTaUYsVUFBVSxHQUFHLFNBQVU3QixHQUFHO1FBQ2pDLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDQSxJQUFJeEwsTUFBTTtJQUM1QjtJQUVBLElBQUlxYSxjQUFjLFNBQVNBLFlBQVlsTyxJQUFJLEVBQUU0TixHQUFHLEVBQUVDLFdBQVc7UUFDM0QsT0FBTzdOLEtBQUthLE1BQU0sQ0FBQyxTQUFVN0QsR0FBRztZQUM5QixPQUFPNFEsSUFBSTFQLElBQUksQ0FBQyxTQUFVdkIsRUFBRTtnQkFDMUIsSUFBSW1SLFdBQVc5USxJQUFJb04sTUFBTSxDQUFDek4sR0FBRztnQkFDN0IsT0FBT21SLFlBQVlBLFNBQVNqYSxNQUFNLElBQUlnYSxZQUFZTSxLQUFLLENBQUMsU0FBVTlPLEdBQUc7b0JBQ25FLE9BQU95TyxTQUFTN1IsUUFBUSxDQUFDb0Q7Z0JBQzNCO1lBQ0Y7UUFDRjtJQUNGO0lBRUE2TyxZQUFZaE4sVUFBVSxHQUFHLFNBQVU3QixHQUFHO1FBQ3BDLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDQSxJQUFJeEwsTUFBTTtJQUM1QjtJQUVBLElBQUl1YSxlQUFlLFNBQVNBLGFBQWFwTyxJQUFJLEVBQUU0TixHQUFHLEVBQUVDLFdBQVc7UUFDN0QsT0FBTzdOLEtBQUthLE1BQU0sQ0FBQyxTQUFVN0QsR0FBRztZQUM5QixPQUFPNFEsSUFBSTFQLElBQUksQ0FBQyxTQUFVdkIsRUFBRTtnQkFDMUIsSUFBSW1SLFdBQVc5USxJQUFJb04sTUFBTSxDQUFDek4sR0FBRztnQkFDN0IsT0FBT21SLFlBQVlBLFNBQVNqYSxNQUFNLElBQUlnYSxZQUFZM1AsSUFBSSxDQUFDLFNBQVVtQixHQUFHO29CQUNsRSxPQUFPeU8sU0FBUzdSLFFBQVEsQ0FBQ29EO2dCQUMzQjtZQUNGO1FBQ0Y7SUFDRjtJQUVBK08sYUFBYWxOLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUNyQyxPQUFPLENBQUNBLE9BQU8sQ0FBQ0EsSUFBSXhMLE1BQU07SUFDNUI7SUFFQSxJQUFJd2EsZ0JBQWdCLFNBQVNBLGNBQWNyTyxJQUFJLEVBQUU0TixHQUFHLEVBQUVDLFdBQVc7UUFDL0QsT0FBTzdOLEtBQUthLE1BQU0sQ0FBQyxTQUFVN0QsR0FBRztZQUM5QixPQUFPNFEsSUFBSTFQLElBQUksQ0FBQyxTQUFVdkIsRUFBRTtnQkFDMUIsSUFBSW1SLFdBQVc5USxJQUFJb04sTUFBTSxDQUFDek4sR0FBRztnQkFDN0IsT0FBT2tSLFlBQVk1UixRQUFRLENBQUM2UjtZQUM5QjtRQUNGO0lBQ0Y7SUFFQU8sY0FBY25OLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUN0QyxPQUFPLENBQUNBLE9BQU8sQ0FBQ0EsSUFBSXhMLE1BQU07SUFDNUI7SUFFQSxJQUFJeWEsUUFBUSxTQUFTQSxNQUFNdE8sSUFBSSxFQUFFNE4sR0FBRyxFQUFFQyxXQUFXO1FBQy9DLE9BQU83TixLQUFLYSxNQUFNLENBQUMsU0FBVTdELEdBQUc7WUFDOUIsT0FBTzRRLElBQUkxUCxJQUFJLENBQUMsU0FBVXZCLEVBQUU7Z0JBQzFCLElBQUltUixXQUFXOVEsSUFBSW9OLE1BQU0sQ0FBQ3pOLEdBQUc7Z0JBQzdCLE9BQU9tUixhQUFhRDtZQUN0QjtRQUNGO0lBQ0Y7SUFFQVMsTUFBTXBOLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUM5QixPQUFPLE9BQU9BLFFBQVE7SUFDeEI7SUFFQSxJQUFJa1AsU0FBUyxTQUFTQSxPQUFPdk8sSUFBSSxFQUFFNE4sR0FBRyxFQUFFQyxXQUFXO1FBQ2pELE9BQU83TixLQUFLYSxNQUFNLENBQUMsU0FBVTdELEdBQUc7WUFDOUIsT0FBTzRRLElBQUkxUCxJQUFJLENBQUMsU0FBVXZCLEVBQUU7Z0JBQzFCLElBQUltUixXQUFXOVEsSUFBSW9OLE1BQU0sQ0FBQ3pOLEdBQUcsRUFBRSxrQ0FBa0M7Z0JBRWpFLE9BQU9tUixZQUFZRDtZQUNyQjtRQUNGO0lBQ0Y7SUFFQVUsT0FBT3JOLFVBQVUsR0FBRyxTQUFVN0IsR0FBRztRQUMvQixPQUFPQSxPQUFPO0lBQ2hCO0lBRUEsSUFBSW1QLFVBQVUsU0FBU0EsUUFBUXhPLElBQUksRUFBRTROLEdBQUcsRUFBRUMsV0FBVztRQUNuRCxJQUFJMVksT0FBTzBZLGVBQWUsRUFBRSxFQUN4QnpDLE1BQU1qVyxJQUFJLENBQUMsRUFBRSxFQUNia1csTUFBTWxXLElBQUksQ0FBQyxFQUFFO1FBRWpCaVcsTUFBTSxPQUFPQSxRQUFRLFdBQVdBLE1BQU0sQ0FBQ3FEO1FBQ3ZDcEQsTUFBTSxPQUFPQSxRQUFRLFdBQVdBLE1BQU1vRDtRQUV0QyxJQUFJckQsTUFBTUMsS0FBSztZQUNiLElBQUlxRCxPQUFPdEQ7WUFDWEEsTUFBTUM7WUFDTkEsTUFBTXFEO1FBQ1I7UUFFQSxPQUFPMU8sS0FBS2EsTUFBTSxDQUFDLFNBQVU3RCxHQUFHO1lBQzlCLE9BQU80USxJQUFJMVAsSUFBSSxDQUFDLFNBQVV2QixFQUFFO2dCQUMxQixJQUFJbVIsV0FBVzlRLElBQUlvTixNQUFNLENBQUN6TixHQUFHO2dCQUM3QixPQUFPbVIsWUFBWTFDLE9BQU8wQyxZQUFZekM7WUFDeEM7UUFDRjtJQUNGO0lBRUFtRCxRQUFRdE4sVUFBVSxHQUFHLFNBQVU3QixHQUFHO1FBQ2hDLE9BQU8sQ0FBQ0EsT0FBTyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLFlBQVksT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSztJQUNqRTtJQUVBLElBQUkwQixjQUFjLFdBQVcsR0FBRS9PLE9BQU8yYyxNQUFNLENBQUM7UUFDM0NDLFdBQVc7UUFDWDVOLE1BQU1BO1FBQ05nTixXQUFXQTtRQUNYQyxlQUFlQTtRQUNmaFMsVUFBVUE7UUFDVmlTLGFBQWFBO1FBQ2JFLGNBQWNBO1FBQ2RDLGVBQWVBO1FBQ2ZDLE9BQU9BO1FBQ1BDLFFBQVFBO1FBQ1JDLFNBQVNBO0lBQ1g7SUFFQXhaLFFBQVE2WixZQUFZLEdBQUc7SUFDdkI3WixRQUFROFosU0FBUyxHQUFHO0lBQ3BCOVosUUFBUStaLGFBQWEsR0FBRztJQUN4QixJQUFJQyxhQUFhLFNBQVNBLFdBQVdoWSxLQUFLO1FBQ3hDQSxNQUFNcU0sYUFBYSxDQUFDNUUsSUFBSSxDQUFDd1E7UUFDekJqWSxNQUFNaU4sV0FBVyxDQUFDeEYsSUFBSSxDQUFDeVE7SUFDekI7SUFDQUYsV0FBV2pYLFVBQVUsR0FBRztJQUV4QixTQUFTa1gsVUFBVTNKLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkMGIsU0FBUyxFQUFFO1lBQ2IsR0FBRzdKO1FBQ0w7UUFFQSxJQUFJUyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUTZaLFlBQVksRUFBRTtZQUN4QyxPQUFPcGIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QjZKLFNBQVM5VCxTQUFTNEssWUFBWSxDQUFDa0osT0FBTyxJQUFJLEVBQUU7WUFDOUM7UUFDRjtRQUVBLElBQUlwSixPQUFPeEssSUFBSSxLQUFLdkcsUUFBUThaLFNBQVMsRUFBRTtZQUNyQyxJQUFJM0ksV0FBV0osT0FBT0ksUUFBUSxFQUMxQjBILGNBQWM5SCxPQUFPOEgsV0FBVztZQUNwQyxJQUFJdFEsYUFBYWxDLFNBQVNrQyxVQUFVLEVBQ2hDdUQsa0JBQWtCekYsU0FBUzBGLFdBQVc7WUFDMUMsSUFBSXpGLFNBQVNpQyxXQUFXZ00sSUFBSSxDQUFDLFNBQVVwTCxDQUFDO2dCQUN0QyxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLd0o7WUFDbEI7WUFFQSxJQUFJLENBQUM3SyxRQUFRO2dCQUNYLE1BQU0sSUFBSS9ELE1BQU0sbURBQW1ENE87WUFDckU7WUFFQSxJQUFJaUosZUFBZXhPLGdCQUFnQnRGLE9BQU91RixNQUFNLEVBQUVDLG1CQUFtQixDQUFDLEdBQUdDO1lBQ3pFLElBQUlzTyxpQkFBaUIvSixNQUFNNkosT0FBTyxDQUFDNUYsSUFBSSxDQUFDLFNBQVVwTCxDQUFDO2dCQUNqRCxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLd0o7WUFDbEI7WUFDQSxJQUFJbUosWUFBWWhYLGlCQUFpQnVWLGFBQWF3QixrQkFBa0JBLGVBQWV4YyxLQUFLLEdBQUcsRUFBRTtZQUV6RixJQUFJb08sdUJBQXVCbU8sYUFBYWxPLFVBQVUsRUFBRW9PLFdBQVdoVSxTQUFTO2dCQUN0RSxPQUFPN0gsU0FBUyxDQUFDLEdBQUc2UixPQUFPO29CQUN6QjZKLFNBQVM3SixNQUFNNkosT0FBTyxDQUFDdE8sTUFBTSxDQUFDLFNBQVUxQyxDQUFDO3dCQUN2QyxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLd0o7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJa0osZ0JBQWdCO2dCQUNsQixPQUFPNWIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO29CQUN6QjZKLFNBQVM3SixNQUFNNkosT0FBTyxDQUFDNVMsR0FBRyxDQUFDLFNBQVU0QixDQUFDO3dCQUNwQyxJQUFJQSxFQUFFeEIsRUFBRSxLQUFLd0osVUFBVTs0QkFDckIsT0FBTztnQ0FDTHhKLElBQUl3SjtnQ0FDSnRULE9BQU95Yzs0QkFDVDt3QkFDRjt3QkFFQSxPQUFPblI7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBLE9BQU8xSyxTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCNkosU0FBUyxFQUFFLENBQUNyWSxNQUFNLENBQUN3TyxNQUFNNkosT0FBTyxFQUFFO29CQUFDO3dCQUNqQ3hTLElBQUl3Sjt3QkFDSnRULE9BQU95YztvQkFDVDtpQkFBRTtZQUNKO1FBQ0Y7UUFFQSxJQUFJdkosT0FBT3hLLElBQUksS0FBS3ZHLFFBQVErWixhQUFhLEVBQUU7WUFDekMsSUFBSUksVUFBVXBKLE9BQU9vSixPQUFPO1lBQzVCLElBQUlJLGNBQWNsVSxTQUFTa0MsVUFBVSxFQUNqQ2lTLG1CQUFtQm5VLFNBQVMwRixXQUFXO1lBQzNDLE9BQU90TixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCLDhCQUE4QjtnQkFDOUI2SixTQUFTN1csaUJBQWlCNlcsU0FBUzdKLE1BQU02SixPQUFPLEVBQUV0TyxNQUFNLENBQUMsU0FBVUEsTUFBTTtvQkFDdkUsSUFBSXZGLFNBQVNpVSxZQUFZaEcsSUFBSSxDQUFDLFNBQVVwTCxDQUFDO3dCQUN2QyxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLa0UsT0FBT2xFLEVBQUU7b0JBQzNCO29CQUVBLElBQUl5UyxlQUFleE8sZ0JBQWdCdEYsT0FBT3VGLE1BQU0sRUFBRTJPLG9CQUFvQixDQUFDLEdBQUd6TztvQkFFMUUsSUFBSUUsdUJBQXVCbU8sYUFBYWxPLFVBQVUsRUFBRUwsT0FBT2hPLEtBQUssRUFBRXlJLFNBQVM7d0JBQ3pFLE9BQU87b0JBQ1Q7b0JBRUEsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVM0VCxjQUFjN1QsUUFBUTtRQUM3QixJQUFJaU4sT0FBT2pOLFNBQVNpTixJQUFJLEVBQ3BCdEksT0FBTzNFLFNBQVMyRSxJQUFJLEVBQ3BCZ0osV0FBVzNOLFNBQVMyTixRQUFRLEVBQzVCQyxXQUFXNU4sU0FBUzROLFFBQVEsRUFDNUIxTCxhQUFhbEMsU0FBU2tDLFVBQVUsRUFDaEN1RCxrQkFBa0J6RixTQUFTMEYsV0FBVyxFQUN0QzBPLGdCQUFnQnBVLFNBQVNvVSxhQUFhLEVBQ3RDQyx3QkFBd0JyVSxTQUFTc1UsZ0JBQWdCLEVBQ2pEQSxtQkFBbUJELDBCQUEwQixLQUFLLElBQUksUUFBUUEsdUJBQzlERSxpQkFBaUJ2VSxTQUFTdVUsY0FBYyxFQUN4Q1QsVUFBVTlULFNBQVNpSyxLQUFLLENBQUM2SixPQUFPLEVBQ2hDeEksV0FBV3RMLFNBQVNzTCxRQUFRLEVBQzVCa0osd0JBQXdCeFUsU0FBU3lVLGdCQUFnQixFQUNqREEsbUJBQW1CRCwwQkFBMEIsS0FBSyxJQUFJLE9BQU9BO1FBQ2pFLElBQUlmLFlBQVkvYyxNQUFNK0csV0FBVyxDQUFDLFNBQVVxTixRQUFRLEVBQUUwSCxXQUFXO1lBQy9EbEgsU0FBUztnQkFDUHBMLE1BQU12RyxRQUFROFosU0FBUztnQkFDdkIzSSxVQUFVQTtnQkFDVjBILGFBQWFBO1lBQ2Y7UUFDRixHQUFHO1lBQUNsSDtTQUFTO1FBQ2IsSUFBSW9JLGdCQUFnQmhkLE1BQU0rRyxXQUFXLENBQUMsU0FBVXFXLE9BQU87WUFDckR4SSxTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVErWixhQUFhO2dCQUMzQkksU0FBU0E7WUFDWDtRQUNGLEdBQUc7WUFBQ3hJO1NBQVM7UUFDYnBKLFdBQVc3RixPQUFPLENBQUMsU0FBVTRELE1BQU07WUFDakMsSUFBSXFCLEtBQUtyQixPQUFPcUIsRUFBRSxFQUNkQyxXQUFXdEIsT0FBT3NCLFFBQVEsRUFDMUJtVCx5QkFBeUJ6VSxPQUFPcVUsZ0JBQWdCLEVBQ2hESyx1QkFBdUIxVSxPQUFPc1UsY0FBYyxFQUFFLHNDQUFzQztZQUV4RnRVLE9BQU8yVSxTQUFTLEdBQUdyVCxXQUFXNkMsZ0JBQWdCdVEseUJBQXlCLE9BQU8sUUFBUXhjLFdBQVdvYyxtQkFBbUIsT0FBTyxRQUFRcGMsV0FBVyxRQUFRaU0sZ0JBQWdCc1Esd0JBQXdCSixrQkFBa0IsUUFBUSx3REFBd0Q7WUFFaFJyVSxPQUFPd1QsU0FBUyxHQUFHLFNBQVV6UCxHQUFHO2dCQUM5QixPQUFPeVAsVUFBVXhULE9BQU9xQixFQUFFLEVBQUUwQztZQUM5QixHQUFHLHFEQUFxRDtZQUN4RCxjQUFjO1lBR2QsSUFBSTZRLFFBQVFmLFFBQVE1RixJQUFJLENBQUMsU0FBVXBMLENBQUM7Z0JBQ2xDLE9BQU9BLEVBQUV4QixFQUFFLEtBQUtBO1lBQ2xCO1lBQ0FyQixPQUFPdVMsV0FBVyxHQUFHcUMsU0FBU0EsTUFBTXJkLEtBQUs7UUFDM0M7UUFFQSxJQUFJa1csaUJBQWlCaFgsTUFBTStXLE9BQU8sQ0FBQztZQUNqQyxJQUFJMkcsaUJBQWlCLENBQUNOLFFBQVF0YixNQUFNLEVBQUU7Z0JBQ3BDLE9BQU87b0JBQUNtTTtvQkFBTWdKO29CQUFVQztpQkFBUztZQUNuQztZQUVBLElBQUlrSCxtQkFBbUIsRUFBRTtZQUN6QixJQUFJQyxtQkFBbUIsQ0FBQyxHQUFHLG9DQUFvQztZQUUvRCxJQUFJQyxhQUFhLFNBQVNBLFdBQVdyUSxJQUFJLEVBQUUxRCxLQUFLO2dCQUM5QyxJQUFJQSxVQUFVLEtBQUssR0FBRztvQkFDcEJBLFFBQVE7Z0JBQ1Y7Z0JBRUEsSUFBSWdVLGVBQWV0UTtnQkFDbkJzUSxlQUFlbkIsUUFBUWhaLE1BQU0sQ0FBQyxTQUFVb2EsYUFBYSxFQUFFcGIsSUFBSTtvQkFDekQsSUFBSWdSLFdBQVdoUixLQUFLd0gsRUFBRSxFQUNsQmtSLGNBQWMxWSxLQUFLdEMsS0FBSztvQkFDNUIsMEJBQTBCO29CQUMxQixJQUFJeUksU0FBU2lDLFdBQVdnTSxJQUFJLENBQUMsU0FBVXBMLENBQUM7d0JBQ3RDLE9BQU9BLEVBQUV4QixFQUFFLEtBQUt3SjtvQkFDbEI7b0JBRUEsSUFBSSxDQUFDN0ssUUFBUTt3QkFDWCxPQUFPaVY7b0JBQ1Q7b0JBRUEsSUFBSWpVLFVBQVUsR0FBRzt3QkFDZmhCLE9BQU9rVixlQUFlLEdBQUdEO29CQUMzQjtvQkFFQSxJQUFJbkIsZUFBZXhPLGdCQUFnQnRGLE9BQU91RixNQUFNLEVBQUVDLG1CQUFtQixDQUFDLEdBQUdDO29CQUV6RSxJQUFJLENBQUNxTyxjQUFjO3dCQUNqQjlYLFFBQVFtWixJQUFJLENBQUMsb0VBQW9FblYsT0FBT3FCLEVBQUUsR0FBRzt3QkFDN0YsT0FBTzRUO29CQUNULEVBQUUsZ0VBQWdFO29CQUNsRSxnQ0FBZ0M7b0JBR2hDalYsT0FBT2dWLFlBQVksR0FBR2xCLGFBQWFtQixlQUFlO3dCQUFDcEs7cUJBQVMsRUFBRTBIO29CQUM5RCxPQUFPdlMsT0FBT2dWLFlBQVk7Z0JBQzVCLEdBQUd0USxPQUFPLGtDQUFrQztnQkFDNUMsOERBQThEO2dCQUM5RCxrRUFBa0U7Z0JBQ2xFLDJEQUEyRDtnQkFFM0RzUSxhQUFhNVksT0FBTyxDQUFDLFNBQVVzRixHQUFHO29CQUNoQ21ULGlCQUFpQjFSLElBQUksQ0FBQ3pCO29CQUN0Qm9ULGdCQUFnQixDQUFDcFQsSUFBSUwsRUFBRSxDQUFDLEdBQUdLO29CQUUzQixJQUFJLENBQUNBLElBQUkyRCxPQUFPLEVBQUU7d0JBQ2hCO29CQUNGO29CQUVBM0QsSUFBSTJELE9BQU8sR0FBRzNELElBQUkyRCxPQUFPLElBQUkzRCxJQUFJMkQsT0FBTyxDQUFDOU0sTUFBTSxHQUFHLElBQUl3YyxXQUFXclQsSUFBSTJELE9BQU8sRUFBRXJFLFFBQVEsS0FBS1UsSUFBSTJELE9BQU87Z0JBQ3hHO2dCQUNBLE9BQU8yUDtZQUNUO1lBRUEsT0FBTztnQkFBQ0QsV0FBV3JRO2dCQUFPbVE7Z0JBQWtCQzthQUFpQjtRQUMvRCxHQUFHO1lBQUNYO1lBQWVOO1lBQVNuUDtZQUFNZ0o7WUFBVUM7WUFBVTFMO1lBQVl1RDtTQUFnQixHQUM5RXdQLGVBQWV2SCxjQUFjLENBQUMsRUFBRSxFQUNoQ29ILG1CQUFtQnBILGNBQWMsQ0FBQyxFQUFFLEVBQ3BDcUgsbUJBQW1CckgsY0FBYyxDQUFDLEVBQUU7UUFFeENoWCxNQUFNK1csT0FBTyxDQUFDO1lBQ1osa0VBQWtFO1lBQ2xFLGtFQUFrRTtZQUNsRSxJQUFJNEgscUJBQXFCblQsV0FBV3NELE1BQU0sQ0FBQyxTQUFVdkYsTUFBTTtnQkFDekQsT0FBTyxDQUFDNlQsUUFBUTVGLElBQUksQ0FBQyxTQUFVcEwsQ0FBQztvQkFDOUIsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS3JCLE9BQU9xQixFQUFFO2dCQUMzQjtZQUNGLElBQUkscUVBQXFFO1lBQ3pFLDZDQUE2QztZQUU3QytULG1CQUFtQmhaLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtnQkFDekNBLE9BQU9rVixlQUFlLEdBQUdGO2dCQUN6QmhWLE9BQU9nVixZQUFZLEdBQUdBO1lBQ3hCO1FBQ0YsR0FBRztZQUFDQTtZQUFjbkI7WUFBUzVSO1NBQVc7UUFDdEMsSUFBSW9ULHNCQUFzQmxZLGFBQWFxWDtRQUN2QzNXLHVCQUF1QjtZQUNyQixJQUFJd1gsdUJBQXVCO2dCQUN6QmhLLFNBQVM7b0JBQ1BwTCxNQUFNdkcsUUFBUTZaLFlBQVk7Z0JBQzVCO1lBQ0Y7UUFDRixHQUFHO1lBQUNsSTtZQUFVOEksZ0JBQWdCLE9BQU9uSDtTQUFLO1FBQzFDdFcsT0FBTzBCLE1BQU0sQ0FBQzJILFVBQVU7WUFDdEJtVixpQkFBaUJ4UTtZQUNqQjRRLHFCQUFxQjVIO1lBQ3JCNkgscUJBQXFCNUg7WUFDckJxSCxjQUFjQTtZQUNkSCxrQkFBa0JBO1lBQ2xCQyxrQkFBa0JBO1lBQ2xCcFEsTUFBTXNRO1lBQ050SCxVQUFVbUg7WUFDVmxILFVBQVVtSDtZQUNWdEIsV0FBV0E7WUFDWEMsZUFBZUE7UUFDakI7SUFDRjtJQUVBL1osUUFBUThiLGlCQUFpQixHQUFHO0lBQzVCOWIsUUFBUStiLGVBQWUsR0FBRztJQUMxQixJQUFJQyxrQkFBa0IsU0FBU0EsZ0JBQWdCaGEsS0FBSztRQUNsREEsTUFBTXFNLGFBQWEsQ0FBQzVFLElBQUksQ0FBQ3dTO1FBQ3pCamEsTUFBTWlOLFdBQVcsQ0FBQ3hGLElBQUksQ0FBQ3lTO0lBQ3pCO0lBQ0FGLGdCQUFnQmpaLFVBQVUsR0FBRztJQUU3QixTQUFTa1osVUFBVTNMLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUThiLGlCQUFpQixFQUFFO1lBQzdDLE9BQU9yZCxTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCNkwsY0FBYzlWLFNBQVM0SyxZQUFZLENBQUNrTCxZQUFZLElBQUkzZDtZQUN0RDtRQUNGO1FBRUEsSUFBSXVTLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRK2IsZUFBZSxFQUFFO1lBQzNDLElBQUlsRCxjQUFjOUgsT0FBTzhILFdBQVc7WUFDcEMsSUFBSS9NLGtCQUFrQnpGLFNBQVN5RixlQUFlO1lBQzlDLElBQUlzTyxlQUFleE8sZ0JBQWdCdkYsU0FBUzhWLFlBQVksRUFBRXJRLG1CQUFtQixDQUFDLEdBQUdDO1lBQ2pGLElBQUl1TyxZQUFZaFgsaUJBQWlCdVYsYUFBYXZJLE1BQU02TCxZQUFZLEdBQUcsRUFBRTtZQUVyRSxJQUFJbFEsdUJBQXVCbU8sYUFBYWxPLFVBQVUsRUFBRW9PLFlBQVk7Z0JBQzlELElBQUk2QixlQUFlN0wsTUFBTTZMLFlBQVksRUFDakNDLDJCQUEyQnJkLDhCQUE4QnVSLE9BQU87b0JBQUM7aUJBQWU7Z0JBRXBGLE9BQU84TDtZQUNUO1lBRUEsT0FBTzNkLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekI2TCxjQUFjN0I7WUFDaEI7UUFDRjtJQUNGO0lBRUEsU0FBUzRCLGNBQWM3VixRQUFRO1FBQzdCLElBQUlpTixPQUFPak4sU0FBU2lOLElBQUksRUFDcEJ0SSxPQUFPM0UsU0FBUzJFLElBQUksRUFDcEJnSixXQUFXM04sU0FBUzJOLFFBQVEsRUFDNUJDLFdBQVc1TixTQUFTNE4sUUFBUSxFQUM1QjFMLGFBQWFsQyxTQUFTa0MsVUFBVSxFQUNoQ3VELGtCQUFrQnpGLFNBQVMwRixXQUFXLEVBQ3RDb1EsZUFBZTlWLFNBQVM4VixZQUFZLEVBQ3BDRSxxQkFBcUJoVyxTQUFTZ1csa0JBQWtCLEVBQ2hEQyxvQkFBb0JqVyxTQUFTaUssS0FBSyxDQUFDNkwsWUFBWSxFQUMvQ3hLLFdBQVd0TCxTQUFTc0wsUUFBUSxFQUM1QjRLLHdCQUF3QmxXLFNBQVNtVyxxQkFBcUIsRUFDdERBLHdCQUF3QkQsMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDbEVFLHNCQUFzQnBXLFNBQVNvVyxtQkFBbUI7UUFDdEQsSUFBSVYsa0JBQWtCaGYsTUFBTStHLFdBQVcsQ0FBQyxTQUFVK1UsV0FBVztZQUMzRGxILFNBQVM7Z0JBQ1BwTCxNQUFNdkcsUUFBUStiLGVBQWU7Z0JBQzdCbEQsYUFBYUE7WUFDZjtRQUNGLEdBQUc7WUFBQ2xIO1NBQVMsR0FBRyx5RUFBeUU7UUFDekYseUVBQXlFO1FBQ3pFLDhFQUE4RTtRQUM5RSxnRUFBZ0U7UUFFaEUsSUFBSW9DLGlCQUFpQmhYLE1BQU0rVyxPQUFPLENBQUM7WUFDakMsSUFBSXVJLHNCQUFzQixPQUFPQyxzQkFBc0IsYUFBYTtnQkFDbEUsT0FBTztvQkFBQ3RSO29CQUFNZ0o7b0JBQVVDO2lCQUFTO1lBQ25DO1lBRUEsSUFBSWtILG1CQUFtQixFQUFFO1lBQ3pCLElBQUlDLG1CQUFtQixDQUFDO1lBQ3hCLElBQUloQixlQUFleE8sZ0JBQWdCdVEsY0FBY3JRLG1CQUFtQixDQUFDLEdBQUdDO1lBRXhFLElBQUksQ0FBQ3FPLGNBQWM7Z0JBQ2pCOVgsUUFBUW1aLElBQUksQ0FBQztnQkFDYixPQUFPelE7WUFDVDtZQUVBekMsV0FBVzdGLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtnQkFDakMsSUFBSW9XLDRCQUE0QnBXLE9BQU9tVyxtQkFBbUI7Z0JBQzFEblcsT0FBTzJVLFNBQVMsR0FBR3hRLGdCQUFnQmlTLDhCQUE4QixPQUFPLFFBQVFsZSxXQUFXaWUsd0JBQXdCLE9BQU8sUUFBUWplLFdBQVc7WUFDL0k7WUFDQSxJQUFJbWUsb0JBQW9CcFUsV0FBV3NELE1BQU0sQ0FBQyxTQUFVK1EsQ0FBQztnQkFDbkQsT0FBT0EsRUFBRTNCLFNBQVMsS0FBSztZQUN6QixJQUFJLG9DQUFvQztZQUV4QyxJQUFJSSxhQUFhLFNBQVNBLFdBQVdDLFlBQVk7Z0JBQy9DQSxlQUFlbEIsYUFBYWtCLGNBQWNxQixrQkFBa0JwVixHQUFHLENBQUMsU0FBVTRCLENBQUM7b0JBQ3pFLE9BQU9BLEVBQUV4QixFQUFFO2dCQUNiLElBQUkyVTtnQkFDSmhCLGFBQWE1WSxPQUFPLENBQUMsU0FBVXNGLEdBQUc7b0JBQ2hDbVQsaUJBQWlCMVIsSUFBSSxDQUFDekI7b0JBQ3RCb1QsZ0JBQWdCLENBQUNwVCxJQUFJTCxFQUFFLENBQUMsR0FBR0s7b0JBQzNCQSxJQUFJMkQsT0FBTyxHQUFHM0QsSUFBSTJELE9BQU8sSUFBSTNELElBQUkyRCxPQUFPLENBQUM5TSxNQUFNLEdBQUd3YyxXQUFXclQsSUFBSTJELE9BQU8sSUFBSTNELElBQUkyRCxPQUFPO2dCQUN6RjtnQkFDQSxPQUFPMlA7WUFDVDtZQUVBLE9BQU87Z0JBQUNELFdBQVdyUTtnQkFBT21RO2dCQUFrQkM7YUFBaUI7UUFDL0QsR0FBRztZQUFDaUI7WUFBb0JDO1lBQW1CSDtZQUFjclE7WUFBaUJ2RDtZQUFZeUM7WUFBTWdKO1lBQVVDO1lBQVV3STtTQUFvQixHQUNoSUkscUJBQXFCOUksY0FBYyxDQUFDLEVBQUUsRUFDdEMrSSx5QkFBeUIvSSxjQUFjLENBQUMsRUFBRSxFQUMxQ2dKLHlCQUF5QmhKLGNBQWMsQ0FBQyxFQUFFO1FBRTlDLElBQUlpSiwyQkFBMkJ2WixhQUFhK1k7UUFDNUNyWSx1QkFBdUI7WUFDckIsSUFBSTZZLDRCQUE0QjtnQkFDOUJyTCxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVE4YixpQkFBaUI7Z0JBQ2pDO1lBQ0Y7UUFDRixHQUFHO1lBQUNuSztZQUFVMEsscUJBQXFCLE9BQU8vSTtTQUFLO1FBQy9DdFcsT0FBTzBCLE1BQU0sQ0FBQzJILFVBQVU7WUFDdEI0Vyx1QkFBdUJqUztZQUN2QmtTLDJCQUEyQmxKO1lBQzNCbUosMkJBQTJCbEo7WUFDM0I0SSxvQkFBb0JBO1lBQ3BCQyx3QkFBd0JBO1lBQ3hCQyx3QkFBd0JBO1lBQ3hCL1IsTUFBTTZSO1lBQ043SSxVQUFVOEk7WUFDVjdJLFVBQVU4STtZQUNWaEIsaUJBQWlCQTtZQUNqQlUscUJBQXFCQTtRQUN2QjtJQUNGO0lBRUEsU0FBU1csSUFBSWhJLE1BQU0sRUFBRWlJLGdCQUFnQjtRQUNuQywrREFBK0Q7UUFDL0Qsa0NBQWtDO1FBQ2xDLE9BQU9BLGlCQUFpQmxjLE1BQU0sQ0FBQyxTQUFVaWMsR0FBRyxFQUFFL2IsSUFBSTtZQUNoRCxPQUFPK2IsTUFBTyxRQUFPL2IsU0FBUyxXQUFXQSxPQUFPO1FBQ2xELEdBQUc7SUFDTDtJQUNBLFNBQVMrVSxJQUFJaEIsTUFBTTtRQUNqQixJQUFJZ0IsTUFBTWhCLE1BQU0sQ0FBQyxFQUFFLElBQUk7UUFDdkJBLE9BQU8xUyxPQUFPLENBQUMsU0FBVTdFLEtBQUs7WUFDNUIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7Z0JBQzdCdVksTUFBTUQsS0FBS0MsR0FBRyxDQUFDQSxLQUFLdlk7WUFDdEI7UUFDRjtRQUNBLE9BQU91WTtJQUNUO0lBQ0EsU0FBU0MsSUFBSWpCLE1BQU07UUFDakIsSUFBSWlCLE1BQU1qQixNQUFNLENBQUMsRUFBRSxJQUFJO1FBQ3ZCQSxPQUFPMVMsT0FBTyxDQUFDLFNBQVU3RSxLQUFLO1lBQzVCLElBQUksT0FBT0EsVUFBVSxVQUFVO2dCQUM3QndZLE1BQU1GLEtBQUtFLEdBQUcsQ0FBQ0EsS0FBS3hZO1lBQ3RCO1FBQ0Y7UUFDQSxPQUFPd1k7SUFDVDtJQUNBLFNBQVNpSCxPQUFPbEksTUFBTTtRQUNwQixJQUFJZ0IsTUFBTWhCLE1BQU0sQ0FBQyxFQUFFLElBQUk7UUFDdkIsSUFBSWlCLE1BQU1qQixNQUFNLENBQUMsRUFBRSxJQUFJO1FBQ3ZCQSxPQUFPMVMsT0FBTyxDQUFDLFNBQVU3RSxLQUFLO1lBQzVCLElBQUksT0FBT0EsVUFBVSxVQUFVO2dCQUM3QnVZLE1BQU1ELEtBQUtDLEdBQUcsQ0FBQ0EsS0FBS3ZZO2dCQUNwQndZLE1BQU1GLEtBQUtFLEdBQUcsQ0FBQ0EsS0FBS3hZO1lBQ3RCO1FBQ0Y7UUFDQSxPQUFPdVksTUFBTSxPQUFPQztJQUN0QjtJQUNBLFNBQVNrSCxRQUFRbkksTUFBTTtRQUNyQixPQUFPZ0ksSUFBSSxNQUFNaEksVUFBVUEsT0FBT3ZXLE1BQU07SUFDMUM7SUFDQSxTQUFTMmUsT0FBT3BJLE1BQU07UUFDcEIsSUFBSSxDQUFDQSxPQUFPdlcsTUFBTSxFQUFFO1lBQ2xCLE9BQU87UUFDVDtRQUVBLElBQUk0ZSxNQUFNdEgsS0FBS3VILEtBQUssQ0FBQ3RJLE9BQU92VyxNQUFNLEdBQUc7UUFDckMsSUFBSThlLE9BQU8sRUFBRSxDQUFDN2IsTUFBTSxDQUFDc1QsUUFBUVQsSUFBSSxDQUFDLFNBQVVoSyxDQUFDLEVBQUVpVCxDQUFDO1lBQzlDLE9BQU9qVCxJQUFJaVQ7UUFDYjtRQUNBLE9BQU94SSxPQUFPdlcsTUFBTSxHQUFHLE1BQU0sSUFBSThlLElBQUksQ0FBQ0YsSUFBSSxHQUFHLENBQUNFLElBQUksQ0FBQ0YsTUFBTSxFQUFFLEdBQUdFLElBQUksQ0FBQ0YsSUFBSSxJQUFJO0lBQzdFO0lBQ0EsU0FBU0ksT0FBT3pJLE1BQU07UUFDcEIsT0FBT25VLE1BQU02YyxJQUFJLENBQUMsSUFBSUMsSUFBSTNJLFFBQVFBLE1BQU07SUFDMUM7SUFDQSxTQUFTNEksWUFBWTVJLE1BQU07UUFDekIsT0FBTyxJQUFJMkksSUFBSTNJLFFBQVE2SSxJQUFJO0lBQzdCO0lBQ0EsU0FBU0MsTUFBTTlJLE1BQU07UUFDbkIsT0FBT0EsT0FBT3ZXLE1BQU07SUFDdEI7SUFFQSxJQUFJc2YsZUFBZSxXQUFXLEdBQUVuaEIsT0FBTzJjLE1BQU0sQ0FBQztRQUM1Q0MsV0FBVztRQUNYd0QsS0FBS0E7UUFDTGhILEtBQUtBO1FBQ0xDLEtBQUtBO1FBQ0xpSCxRQUFRQTtRQUNSQyxTQUFTQTtRQUNUQyxRQUFRQTtRQUNSSyxRQUFRQTtRQUNSRyxhQUFhQTtRQUNiRSxPQUFPQTtJQUNUO0lBRUEsSUFBSUUsYUFBYSxFQUFFO0lBQ25CLElBQUlDLGNBQWMsQ0FBQyxHQUFHLFVBQVU7SUFFaENyZSxRQUFRc2UsWUFBWSxHQUFHO0lBQ3ZCdGUsUUFBUXVlLFVBQVUsR0FBRztJQUNyQnZlLFFBQVF3ZSxhQUFhLEdBQUc7SUFDeEIsSUFBSUMsYUFBYSxTQUFTQSxXQUFXemMsS0FBSztRQUN4Q0EsTUFBTTBjLHFCQUFxQixHQUFHO1lBQUNDO1NBQTZCO1FBQzVEM2MsTUFBTXFNLGFBQWEsQ0FBQzVFLElBQUksQ0FBQ21WO1FBQ3pCNWMsTUFBTThNLGtCQUFrQixDQUFDckYsSUFBSSxDQUFDLFNBQVVyRixJQUFJLEVBQUVqRSxJQUFJO1lBQ2hELElBQUlrRyxXQUFXbEcsS0FBS2tHLFFBQVE7WUFDNUIsT0FBTyxFQUFFLENBQUN2RSxNQUFNLENBQUNzQyxNQUFNO2dCQUFDaUMsU0FBU2lLLEtBQUssQ0FBQ3VPLE9BQU87YUFBQztRQUNqRDtRQUNBN2MsTUFBTTZNLGNBQWMsQ0FBQ3BGLElBQUksQ0FBQ29GO1FBQzFCN00sTUFBTWlOLFdBQVcsQ0FBQ3hGLElBQUksQ0FBQ3FWO1FBQ3ZCOWMsTUFBTWtOLFVBQVUsQ0FBQ3pGLElBQUksQ0FBQ3NWO0lBQ3hCO0lBQ0FOLFdBQVcxYixVQUFVLEdBQUc7SUFFeEIsSUFBSTRiLCtCQUErQixTQUFTQSw2QkFBNkJ2ZCxLQUFLLEVBQUV3RCxLQUFLO1FBQ25GLElBQUkrUSxTQUFTL1EsTUFBTStRLE1BQU07UUFDekIsT0FBTztZQUFDdlU7WUFBTztnQkFDYmtXLFNBQVMzQixPQUFPcUosVUFBVSxHQUFHLFNBQVV4VSxDQUFDO29CQUN0Q0EsRUFBRXlVLE9BQU87b0JBQ1R0SixPQUFPNkksYUFBYTtnQkFDdEIsSUFBSWhnQjtnQkFDSjhDLE9BQU87b0JBQ0xnSixRQUFRcUwsT0FBT3FKLFVBQVUsR0FBRyxZQUFZeGdCO2dCQUMxQztnQkFDQW9TLE9BQU87WUFDVDtTQUFFO0lBQ0osR0FBRyxVQUFVO0lBR2IsU0FBU2dPLFVBQVV0TyxLQUFLLEVBQUVTLE1BQU0sRUFBRUMsYUFBYSxFQUFFM0ssUUFBUTtRQUN2RCxJQUFJMEssT0FBT3hLLElBQUksS0FBS3ZHLFFBQVFDLElBQUksRUFBRTtZQUNoQyxPQUFPeEIsU0FBUztnQkFDZG9nQixTQUFTLEVBQUU7WUFDYixHQUFHdk87UUFDTDtRQUVBLElBQUlTLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRc2UsWUFBWSxFQUFFO1lBQ3hDLE9BQU83ZixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCdU8sU0FBU3hZLFNBQVM0SyxZQUFZLENBQUM0TixPQUFPLElBQUksRUFBRTtZQUM5QztRQUNGO1FBRUEsSUFBSTlOLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRdWUsVUFBVSxFQUFFO1lBQ3RDLElBQUkxZ0IsUUFBUWtULE9BQU9sVCxLQUFLO1lBQ3hCLE9BQU9ZLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJ1TyxTQUFTaGhCO1lBQ1g7UUFDRjtRQUVBLElBQUlrVCxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXdlLGFBQWEsRUFBRTtZQUN6QyxJQUFJck4sV0FBV0osT0FBT0ksUUFBUSxFQUMxQm9OLGFBQWF4TixPQUFPbFQsS0FBSztZQUM3QixJQUFJcWhCLGtCQUFrQixPQUFPWCxlQUFlLGNBQWNBLGFBQWEsQ0FBQ2pPLE1BQU11TyxPQUFPLENBQUM1WCxRQUFRLENBQUNrSztZQUUvRixJQUFJK04saUJBQWlCO2dCQUNuQixPQUFPemdCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztvQkFDekJ1TyxTQUFTLEVBQUUsQ0FBQy9jLE1BQU0sQ0FBQ3dPLE1BQU11TyxPQUFPLEVBQUU7d0JBQUMxTjtxQkFBUztnQkFDOUM7WUFDRjtZQUVBLE9BQU8xUyxTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCdU8sU0FBU3ZPLE1BQU11TyxPQUFPLENBQUNoVCxNQUFNLENBQUMsU0FBVTFDLENBQUM7b0JBQ3ZDLE9BQU9BLE1BQU1nSTtnQkFDZjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVN0QyxlQUFlekgsT0FBTyxFQUFFc0csS0FBSztRQUNwQyxJQUFJbVIsVUFBVW5SLE1BQU1ySCxRQUFRLENBQUNpSyxLQUFLLENBQUN1TyxPQUFPO1FBQzFDLHVEQUF1RDtRQUN2RCwrQkFBK0I7UUFDL0IsSUFBSU0saUJBQWlCTixRQUFRdFgsR0FBRyxDQUFDLFNBQVU2WCxDQUFDO1lBQzFDLE9BQU9oWSxRQUFRbU4sSUFBSSxDQUFDLFNBQVU4SyxHQUFHO2dCQUMvQixPQUFPQSxJQUFJMVgsRUFBRSxLQUFLeVg7WUFDcEI7UUFDRixHQUFHdlQsTUFBTSxDQUFDdUg7UUFDVixJQUFJa00sb0JBQW9CbFksUUFBUXlFLE1BQU0sQ0FBQyxTQUFVd1QsR0FBRztZQUNsRCxPQUFPLENBQUNSLFFBQVE1WCxRQUFRLENBQUNvWSxJQUFJMVgsRUFBRTtRQUNqQztRQUNBUCxVQUFVLEVBQUUsQ0FBQ3RGLE1BQU0sQ0FBQ3FkLGdCQUFnQkc7UUFDcENsWSxRQUFRMUUsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO1lBQzlCQSxPQUFPaVosU0FBUyxHQUFHVixRQUFRNVgsUUFBUSxDQUFDWCxPQUFPcUIsRUFBRTtZQUM3Q3JCLE9BQU9rWixZQUFZLEdBQUdYLFFBQVExZixPQUFPLENBQUNtSCxPQUFPcUIsRUFBRTtRQUNqRDtRQUNBLE9BQU9QO0lBQ1Q7SUFFQSxJQUFJcVksMEJBQTBCLENBQUM7SUFFL0IsU0FBU1gsY0FBY3pZLFFBQVE7UUFDN0IsSUFBSWlOLE9BQU9qTixTQUFTaU4sSUFBSSxFQUNwQnRJLE9BQU8zRSxTQUFTMkUsSUFBSSxFQUNwQmdKLFdBQVczTixTQUFTMk4sUUFBUSxFQUM1QkMsV0FBVzVOLFNBQVM0TixRQUFRLEVBQzVCMUwsYUFBYWxDLFNBQVNrQyxVQUFVLEVBQ2hDbUosY0FBY3JMLFNBQVNxTCxXQUFXLEVBQ2xDZ08sc0JBQXNCclosU0FBU3NaLFNBQVMsRUFDeENBLFlBQVlELHdCQUF3QixLQUFLLElBQUlFLG1CQUFtQkYscUJBQ2hFRyxnQkFBZ0J4WixTQUFTd1osYUFBYSxFQUN0Q0Msd0JBQXdCelosU0FBUzhYLFlBQVksRUFDN0M0QixtQkFBbUJELDBCQUEwQixLQUFLLElBQUlMLDBCQUEwQkssdUJBQ2hGamQsVUFBVXdELFNBQVN4RCxPQUFPLEVBQzFCZ2MsVUFBVXhZLFNBQVNpSyxLQUFLLENBQUN1TyxPQUFPLEVBQ2hDbE4sV0FBV3RMLFNBQVNzTCxRQUFRLEVBQzVCcU8sd0JBQXdCM1osU0FBUzRaLGdCQUFnQixFQUNqREEsbUJBQW1CRCwwQkFBMEIsS0FBSyxJQUFJLE9BQU9BLHVCQUM3REUsaUJBQWlCN1osU0FBUzZaLGNBQWMsRUFDeENDLG9CQUFvQjlaLFNBQVM4WixpQkFBaUIsRUFDOUN2TyxXQUFXdkwsU0FBU3VMLFFBQVE7UUFDaENoUCxrQkFBa0JDLFNBQVM7WUFBQztZQUFrQjtTQUFhLEVBQUU7UUFDN0QsSUFBSWtQLGNBQWN0TyxhQUFhNEM7UUFDL0JrQyxXQUFXN0YsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO1lBQ2pDLElBQUlzQixXQUFXdEIsT0FBT3NCLFFBQVEsRUFDMUJ3WSx1QkFBdUI5WixPQUFPK1osY0FBYyxFQUM1Q0MsdUJBQXVCaGEsT0FBTzRaLGNBQWM7WUFDaEQ1WixPQUFPMFksVUFBVSxHQUFHcFgsV0FBVzZDLGdCQUFnQm5FLE9BQU8wWSxVQUFVLEVBQUVzQix5QkFBeUIsT0FBTyxRQUFROWhCLFdBQVcwaEIsbUJBQW1CLE9BQU8sUUFBUTFoQixXQUFXLFFBQVFpTSxnQkFBZ0JuRSxPQUFPMFksVUFBVSxFQUFFb0Isc0JBQXNCRCxtQkFBbUI7WUFFdFAsSUFBSTdaLE9BQU8wWSxVQUFVLEVBQUU7Z0JBQ3JCMVksT0FBT2tZLGFBQWEsR0FBRztvQkFDckIsT0FBT25ZLFNBQVNtWSxhQUFhLENBQUNsWSxPQUFPcUIsRUFBRTtnQkFDekM7WUFDRjtZQUVBckIsT0FBT2lhLFVBQVUsR0FBR2phLE9BQU9pYSxVQUFVLElBQUlqYSxPQUFPN0YsSUFBSTtRQUN0RDtRQUNBLElBQUkrZCxnQkFBZ0J6aEIsTUFBTStHLFdBQVcsQ0FBQyxTQUFVcU4sUUFBUSxFQUFFdFQsS0FBSztZQUM3RDhULFNBQVM7Z0JBQ1BwTCxNQUFNdkcsUUFBUXdlLGFBQWE7Z0JBQzNCck4sVUFBVUE7Z0JBQ1Z0VCxPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDOFQ7U0FBUztRQUNiLElBQUk0TSxhQUFheGhCLE1BQU0rRyxXQUFXLENBQUMsU0FBVWpHLEtBQUs7WUFDaEQ4VCxTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVF1ZSxVQUFVO2dCQUN4QjFnQixPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDOFQ7U0FBUztRQUNiRCxZQUFZaFAsT0FBTyxDQUFDLFNBQVVpVCxNQUFNO1lBQ2xDQSxPQUFPK0kscUJBQXFCLEdBQUczYyxlQUFlNlAsV0FBVzhNLHFCQUFxQixFQUFFO2dCQUM5RXJZLFVBQVUwTDtnQkFDVjRELFFBQVFBO1lBQ1Y7UUFDRjtRQUVBLElBQUk1QixpQkFBaUJoWCxNQUFNK1csT0FBTyxDQUFDO1lBQ2pDLElBQUkrTCxpQkFBaUIsQ0FBQ2hCLFFBQVFoZ0IsTUFBTSxFQUFFO2dCQUNwQyxPQUFPO29CQUFDbU07b0JBQU1nSjtvQkFBVUM7b0JBQVVtSztvQkFBWUM7b0JBQWFySztvQkFBVUM7aUJBQVM7WUFDaEYsRUFBRSxpREFBaUQ7WUFHbkQsSUFBSXVNLGtCQUFrQjNCLFFBQVFoVCxNQUFNLENBQUMsU0FBVXVULENBQUM7Z0JBQzlDLE9BQU83VyxXQUFXZ00sSUFBSSxDQUFDLFNBQVU4SyxHQUFHO29CQUNsQyxPQUFPQSxJQUFJMVgsRUFBRSxLQUFLeVg7Z0JBQ3BCO1lBQ0YsSUFBSSwrQ0FBK0M7WUFDbkQseURBQXlEO1lBRXpELElBQUlxQix3QkFBd0IsU0FBU0Esc0JBQXNCQyxRQUFRLEVBQUVDLFdBQVcsRUFBRXJaLEtBQUs7Z0JBQ3JGLElBQUk4TixTQUFTLENBQUM7Z0JBQ2Q3TSxXQUFXN0YsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO29CQUNqQyxrREFBa0Q7b0JBQ2xELElBQUlrYSxnQkFBZ0J2WixRQUFRLENBQUNYLE9BQU9xQixFQUFFLEdBQUc7d0JBQ3ZDeU4sTUFBTSxDQUFDOU8sT0FBT3FCLEVBQUUsQ0FBQyxHQUFHZ1osV0FBVyxDQUFDLEVBQUUsR0FBR0EsV0FBVyxDQUFDLEVBQUUsQ0FBQ3ZMLE1BQU0sQ0FBQzlPLE9BQU9xQixFQUFFLENBQUMsR0FBRzt3QkFDeEU7b0JBQ0YsRUFBRSx1QkFBdUI7b0JBR3pCLElBQUlpWixjQUFjLE9BQU90YSxPQUFPdWEsU0FBUyxLQUFLLGFBQWF2YSxPQUFPdWEsU0FBUyxHQUFHZCxnQkFBZ0IsQ0FBQ3paLE9BQU91YSxTQUFTLENBQUMsSUFBSTFDLFlBQVksQ0FBQzdYLE9BQU91YSxTQUFTLENBQUM7b0JBRWxKLElBQUlELGFBQWE7d0JBQ2Ysb0NBQW9DO3dCQUNwQyxJQUFJRSxnQkFBZ0JILFlBQVlwWixHQUFHLENBQUMsU0FBVVMsR0FBRzs0QkFDL0MsT0FBT0EsSUFBSW9OLE1BQU0sQ0FBQzlPLE9BQU9xQixFQUFFLENBQUM7d0JBQzlCLElBQUksb0NBQW9DO3dCQUV4QyxJQUFJb1osYUFBYUwsU0FBU25aLEdBQUcsQ0FBQyxTQUFVUyxHQUFHOzRCQUN6QyxJQUFJZ1osY0FBY2haLElBQUlvTixNQUFNLENBQUM5TyxPQUFPcUIsRUFBRSxDQUFDOzRCQUV2QyxJQUFJLENBQUNMLFNBQVNoQixPQUFPMmEsY0FBYyxFQUFFO2dDQUNuQyxJQUFJQyxtQkFBbUIsT0FBTzVhLE9BQU8yYSxjQUFjLEtBQUssYUFBYTNhLE9BQU8yYSxjQUFjLEdBQUdsQixnQkFBZ0IsQ0FBQ3paLE9BQU8yYSxjQUFjLENBQUMsSUFBSTlDLFlBQVksQ0FBQzdYLE9BQU8yYSxjQUFjLENBQUM7Z0NBRTNLLElBQUksQ0FBQ0Msa0JBQWtCO29DQUNyQjVlLFFBQVExRSxJQUFJLENBQUM7d0NBQ1gwSSxRQUFRQTtvQ0FDVjtvQ0FDQSxNQUFNLElBQUkvRCxNQUFNO2dDQUNsQjtnQ0FFQXllLGNBQWNFLGlCQUFpQkYsYUFBYWhaLEtBQUsxQjs0QkFDbkQ7NEJBRUEsT0FBTzBhO3dCQUNUO3dCQUNBNUwsTUFBTSxDQUFDOU8sT0FBT3FCLEVBQUUsQ0FBQyxHQUFHaVosWUFBWUcsWUFBWUQ7b0JBQzlDLE9BQU8sSUFBSXhhLE9BQU91YSxTQUFTLEVBQUU7d0JBQzNCdmUsUUFBUTFFLElBQUksQ0FBQzs0QkFDWDBJLFFBQVFBO3dCQUNWO3dCQUNBLE1BQU0sSUFBSS9ELE1BQU07b0JBQ2xCLE9BQU87d0JBQ0w2UyxNQUFNLENBQUM5TyxPQUFPcUIsRUFBRSxDQUFDLEdBQUc7b0JBQ3RCO2dCQUNGO2dCQUNBLE9BQU95TjtZQUNUO1lBRUEsSUFBSStMLGtCQUFrQixFQUFFO1lBQ3hCLElBQUlDLGtCQUFrQixDQUFDO1lBQ3ZCLElBQUlDLHNCQUFzQixFQUFFO1lBQzVCLElBQUlDLHNCQUFzQixDQUFDO1lBQzNCLElBQUlDLHFCQUFxQixFQUFFO1lBQzNCLElBQUlDLHFCQUFxQixDQUFDLEdBQUcsNkJBQTZCO1lBRTFELElBQUlDLHFCQUFxQixTQUFTQSxtQkFBbUJ6VyxJQUFJLEVBQUUxRCxLQUFLLEVBQUVvYSxRQUFRO2dCQUN4RSxJQUFJcGEsVUFBVSxLQUFLLEdBQUc7b0JBQ3BCQSxRQUFRO2dCQUNWO2dCQUVBLCtDQUErQztnQkFDL0MsSUFBSUEsVUFBVWtaLGdCQUFnQjNoQixNQUFNLEVBQUU7b0JBQ3BDLE9BQU9tTSxLQUFLekQsR0FBRyxDQUFDLFNBQVVTLEdBQUc7d0JBQzNCLE9BQU92SixTQUFTLENBQUMsR0FBR3VKLEtBQUs7NEJBQ3ZCVixPQUFPQTt3QkFDVDtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJNkosV0FBV3FQLGVBQWUsQ0FBQ2xaLE1BQU0sRUFBRSx5Q0FBeUM7Z0JBRWhGLElBQUlxYSxlQUFlaEMsVUFBVTNVLE1BQU1tRyxXQUFXLHFDQUFxQztnQkFFbkYsSUFBSXlRLHdCQUF3QjVrQixPQUFPNmtCLE9BQU8sQ0FBQ0YsY0FBY3BhLEdBQUcsQ0FBQyxTQUFVc0csS0FBSyxFQUFFRixLQUFLO29CQUNqRixJQUFJbVUsYUFBYWpVLEtBQUssQ0FBQyxFQUFFLEVBQ3JCOFMsY0FBYzlTLEtBQUssQ0FBQyxFQUFFO29CQUMxQixJQUFJbEcsS0FBS3dKLFdBQVcsTUFBTTJRO29CQUMxQm5hLEtBQUsrWixXQUFXQSxXQUFXLE1BQU0vWixLQUFLQSxJQUFJLHNEQUFzRDtvQkFFaEcsSUFBSWdFLFVBQVU4VixtQkFBbUJkLGFBQWFyWixRQUFRLEdBQUdLLEtBQUssa0RBQWtEO29CQUVoSCxJQUFJK1ksV0FBV3BaLFFBQVFJLFVBQVVpWixhQUFhLGNBQWNBO29CQUM1RCxJQUFJdkwsU0FBU3FMLHNCQUFzQkMsVUFBVUMsYUFBYXJaO29CQUMxRCxJQUFJVSxNQUFNO3dCQUNSTCxJQUFJQTt3QkFDSjRYLFdBQVc7d0JBQ1h3QyxXQUFXNVE7d0JBQ1gyUSxZQUFZQTt3QkFDWjFNLFFBQVFBO3dCQUNSekosU0FBU0E7d0JBQ1QrVSxVQUFVQTt3QkFDVnBaLE9BQU9BO3dCQUNQcUcsT0FBT0E7b0JBQ1Q7b0JBQ0FoQyxRQUFRakosT0FBTyxDQUFDLFNBQVVzZixNQUFNO3dCQUM5QmIsZ0JBQWdCMVgsSUFBSSxDQUFDdVk7d0JBQ3JCWixlQUFlLENBQUNZLE9BQU9yYSxFQUFFLENBQUMsR0FBR3FhO3dCQUU3QixJQUFJQSxPQUFPekMsU0FBUyxFQUFFOzRCQUNwQjhCLG9CQUFvQjVYLElBQUksQ0FBQ3VZOzRCQUN6QlYsbUJBQW1CLENBQUNVLE9BQU9yYSxFQUFFLENBQUMsR0FBR3FhO3dCQUNuQyxPQUFPOzRCQUNMVCxtQkFBbUI5WCxJQUFJLENBQUN1WTs0QkFDeEJSLGtCQUFrQixDQUFDUSxPQUFPcmEsRUFBRSxDQUFDLEdBQUdxYTt3QkFDbEM7b0JBQ0Y7b0JBQ0EsT0FBT2hhO2dCQUNUO2dCQUNBLE9BQU80WjtZQUNUO1lBRUEsSUFBSWpCLGNBQWNjLG1CQUFtQnpXO1lBQ3JDMlYsWUFBWWplLE9BQU8sQ0FBQyxTQUFVc2YsTUFBTTtnQkFDbENiLGdCQUFnQjFYLElBQUksQ0FBQ3VZO2dCQUNyQlosZUFBZSxDQUFDWSxPQUFPcmEsRUFBRSxDQUFDLEdBQUdxYTtnQkFFN0IsSUFBSUEsT0FBT3pDLFNBQVMsRUFBRTtvQkFDcEI4QixvQkFBb0I1WCxJQUFJLENBQUN1WTtvQkFDekJWLG1CQUFtQixDQUFDVSxPQUFPcmEsRUFBRSxDQUFDLEdBQUdxYTtnQkFDbkMsT0FBTztvQkFDTFQsbUJBQW1COVgsSUFBSSxDQUFDdVk7b0JBQ3hCUixrQkFBa0IsQ0FBQ1EsT0FBT3JhLEVBQUUsQ0FBQyxHQUFHcWE7Z0JBQ2xDO1lBQ0YsSUFBSSxzQkFBc0I7WUFFMUIsT0FBTztnQkFBQ3JCO2dCQUFhUTtnQkFBaUJDO2dCQUFpQkM7Z0JBQXFCQztnQkFBcUJDO2dCQUFvQkM7YUFBbUI7UUFDMUksR0FBRztZQUFDM0I7WUFBZWhCO1lBQVM3VDtZQUFNZ0o7WUFBVUM7WUFBVTFMO1lBQVl3WDtZQUFrQko7U0FBVSxHQUMxRmdCLGNBQWM1TSxjQUFjLENBQUMsRUFBRSxFQUMvQm9OLGtCQUFrQnBOLGNBQWMsQ0FBQyxFQUFFLEVBQ25DcU4sa0JBQWtCck4sY0FBYyxDQUFDLEVBQUUsRUFDbkNzTixzQkFBc0J0TixjQUFjLENBQUMsRUFBRSxFQUN2Q3VOLHNCQUFzQnZOLGNBQWMsQ0FBQyxFQUFFLEVBQ3ZDd04scUJBQXFCeE4sY0FBYyxDQUFDLEVBQUUsRUFDdEN5TixxQkFBcUJ6TixjQUFjLENBQUMsRUFBRTtRQUUxQyxJQUFJa08sc0JBQXNCeGUsYUFBYXdjO1FBQ3ZDOWIsdUJBQXVCO1lBQ3JCLElBQUk4ZCx1QkFBdUI7Z0JBQ3pCdFEsU0FBUztvQkFDUHBMLE1BQU12RyxRQUFRc2UsWUFBWTtnQkFDNUI7WUFDRjtRQUNGLEdBQUc7WUFBQzNNO1lBQVVrTyxnQkFBZ0IsT0FBT3ZNO1NBQUs7UUFDMUN0VyxPQUFPMEIsTUFBTSxDQUFDMkgsVUFBVTtZQUN0QjZiLGdCQUFnQmxYO1lBQ2hCbVgsbUJBQW1Cbk87WUFDbkJvTyxvQkFBb0JuTztZQUNwQjBNLGFBQWFBO1lBQ2JRLGlCQUFpQkE7WUFDakJDLGlCQUFpQkE7WUFDakJDLHFCQUFxQkE7WUFDckJDLHFCQUFxQkE7WUFDckJDLG9CQUFvQkE7WUFDcEJDLG9CQUFvQkE7WUFDcEJ4VyxNQUFNMlY7WUFDTjNNLFVBQVVtTjtZQUNWbE4sVUFBVW1OO1lBQ1Y1QyxlQUFlQTtZQUNmRCxZQUFZQTtRQUNkO0lBQ0Y7SUFFQSxTQUFTUSxhQUFhL1csR0FBRztRQUN2QkEsSUFBSW1OLFFBQVEsQ0FBQ3pTLE9BQU8sQ0FBQyxTQUFVd0wsSUFBSTtZQUNqQyxJQUFJbVU7WUFFSixrRUFBa0U7WUFDbEVuVSxLQUFLcVIsU0FBUyxHQUFHclIsS0FBSzVILE1BQU0sQ0FBQ2laLFNBQVMsSUFBSXJSLEtBQUs1SCxNQUFNLENBQUNxQixFQUFFLEtBQUtLLElBQUkrWixTQUFTLEVBQUUsd0VBQXdFO1lBRXBKN1QsS0FBS29VLGFBQWEsR0FBRyxDQUFDcFUsS0FBS3FSLFNBQVMsSUFBSXJSLEtBQUs1SCxNQUFNLENBQUNpWixTQUFTLEVBQUUseUVBQXlFO1lBRXhJclIsS0FBS3FVLFlBQVksR0FBRyxDQUFDclUsS0FBS3FSLFNBQVMsSUFBSSxDQUFDclIsS0FBS29VLGFBQWEsSUFBSyxFQUFDRCxlQUFlcmEsSUFBSTJELE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSTBXLGFBQWF4akIsTUFBTTtRQUNwSTtJQUNGO0lBRUEsU0FBUytnQixpQkFBaUI1VSxJQUFJLEVBQUVtRyxRQUFRO1FBQ3RDLE9BQU9uRyxLQUFLN0osTUFBTSxDQUFDLFNBQVVjLElBQUksRUFBRStGLEdBQUcsRUFBRXBKLENBQUM7WUFDdkMseURBQXlEO1lBQ3pELDBEQUEwRDtZQUMxRCxJQUFJNGpCLFNBQVMsS0FBS3hhLElBQUlvTixNQUFNLENBQUNqRSxTQUFTO1lBQ3RDbFAsSUFBSSxDQUFDdWdCLE9BQU8sR0FBR3ZoQixNQUFNWSxPQUFPLENBQUNJLElBQUksQ0FBQ3VnQixPQUFPLElBQUl2Z0IsSUFBSSxDQUFDdWdCLE9BQU8sR0FBRyxFQUFFO1lBQzlEdmdCLElBQUksQ0FBQ3VnQixPQUFPLENBQUMvWSxJQUFJLENBQUN6QjtZQUNsQixPQUFPL0Y7UUFDVCxHQUFHLENBQUM7SUFDTjtJQUVBLElBQUl3Z0Isc0JBQXNCLGNBQWMsZ0VBQWdFO0lBQ3hHLGdFQUFnRTtJQUNoRSxnQ0FBZ0M7SUFFaEMsSUFBSUMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJLEVBQUVDLElBQUksRUFBRXpSLFFBQVE7UUFDM0QsSUFBSTBSLHdCQUF3QkMsdUJBQXVCSCxNQUFNQyxNQUFNelIsV0FDM0R4RyxJQUFJa1kscUJBQXFCLENBQUMsRUFBRSxFQUM1QmpGLElBQUlpRixxQkFBcUIsQ0FBQyxFQUFFLEVBQUUsaURBQWlEO1FBR25GbFksSUFBSW9ZLFNBQVNwWTtRQUNiaVQsSUFBSW1GLFNBQVNuRixJQUFJLGlEQUFpRDtRQUNsRSxrQ0FBa0M7UUFFbENqVCxJQUFJQSxFQUFFNUMsS0FBSyxDQUFDMGEscUJBQXFCNVcsTUFBTSxDQUFDdUg7UUFDeEN3SyxJQUFJQSxFQUFFN1YsS0FBSyxDQUFDMGEscUJBQXFCNVcsTUFBTSxDQUFDdUgsVUFBVSxRQUFRO1FBRTFELE1BQU96SSxFQUFFOUwsTUFBTSxJQUFJK2UsRUFBRS9lLE1BQU0sQ0FBRTtZQUMzQixJQUFJbWtCLEtBQUtyWSxFQUFFd0osS0FBSztZQUNoQixJQUFJOE8sS0FBS3JGLEVBQUV6SixLQUFLO1lBQ2hCLElBQUkrTyxLQUFLQyxTQUFTSCxJQUFJO1lBQ3RCLElBQUlJLEtBQUtELFNBQVNGLElBQUk7WUFDdEIsSUFBSUksUUFBUTtnQkFBQ0g7Z0JBQUlFO2FBQUcsQ0FBQ3pPLElBQUksSUFBSSxrQkFBa0I7WUFFL0MsSUFBSTJPLE1BQU1ELEtBQUssQ0FBQyxFQUFFLEdBQUc7Z0JBQ25CLElBQUlMLEtBQUtDLElBQUk7b0JBQ1gsT0FBTztnQkFDVDtnQkFFQSxJQUFJQSxLQUFLRCxJQUFJO29CQUNYLE9BQU8sQ0FBQztnQkFDVjtnQkFFQTtZQUNGLEVBQUUsbUNBQW1DO1lBR3JDLElBQUlNLE1BQU1ELEtBQUssQ0FBQyxFQUFFLEdBQUc7Z0JBQ25CLE9BQU9DLE1BQU1KLE1BQU0sQ0FBQyxJQUFJO1lBQzFCLEVBQUUsbUJBQW1CO1lBR3JCLElBQUlBLEtBQUtFLElBQUk7Z0JBQ1gsT0FBTztZQUNUO1lBRUEsSUFBSUEsS0FBS0YsSUFBSTtnQkFDWCxPQUFPLENBQUM7WUFDVjtRQUNGO1FBRUEsT0FBT3ZZLEVBQUU5TCxNQUFNLEdBQUcrZSxFQUFFL2UsTUFBTTtJQUM1QjtJQUNBLFNBQVMwa0IsU0FBU1osSUFBSSxFQUFFQyxJQUFJLEVBQUV6UixRQUFRO1FBQ3BDLElBQUlxUyx5QkFBeUJWLHVCQUF1QkgsTUFBTUMsTUFBTXpSLFdBQzVEeEcsSUFBSTZZLHNCQUFzQixDQUFDLEVBQUUsRUFDN0I1RixJQUFJNEYsc0JBQXNCLENBQUMsRUFBRTtRQUVqQzdZLElBQUlBLEVBQUU4WSxPQUFPO1FBQ2I3RixJQUFJQSxFQUFFNkYsT0FBTztRQUNiLE9BQU9DLGFBQWEvWSxHQUFHaVQ7SUFDekI7SUFDQSxTQUFTK0YsTUFBTWhCLElBQUksRUFBRUMsSUFBSSxFQUFFelIsUUFBUTtRQUNqQyxJQUFJeVMseUJBQXlCZCx1QkFBdUJILE1BQU1DLE1BQU16UixXQUM1RHhHLElBQUlpWixzQkFBc0IsQ0FBQyxFQUFFLEVBQzdCaEcsSUFBSWdHLHNCQUFzQixDQUFDLEVBQUU7UUFFakMsT0FBT0YsYUFBYS9ZLEdBQUdpVDtJQUN6QjtJQUNBLFNBQVNpRyxPQUFPbEIsSUFBSSxFQUFFQyxJQUFJLEVBQUV6UixRQUFRO1FBQ2xDLElBQUkyUyx5QkFBeUJoQix1QkFBdUJILE1BQU1DLE1BQU16UixXQUM1RHhHLElBQUltWixzQkFBc0IsQ0FBQyxFQUFFLEVBQzdCbEcsSUFBSWtHLHNCQUFzQixDQUFDLEVBQUU7UUFFakNuWixJQUFJQSxFQUFFNUMsS0FBSyxDQUFDLElBQUk4RCxNQUFNLENBQUN1SDtRQUN2QndLLElBQUlBLEVBQUU3VixLQUFLLENBQUMsSUFBSThELE1BQU0sQ0FBQ3VIO1FBRXZCLE1BQU96SSxFQUFFOUwsTUFBTSxJQUFJK2UsRUFBRS9lLE1BQU0sQ0FBRTtZQUMzQixJQUFJbWtCLEtBQUtyWSxFQUFFd0osS0FBSztZQUNoQixJQUFJOE8sS0FBS3JGLEVBQUV6SixLQUFLO1lBQ2hCLElBQUk0UCxTQUFTZixHQUFHakssV0FBVztZQUMzQixJQUFJaUwsU0FBU2YsR0FBR2xLLFdBQVcsSUFBSSxxREFBcUQ7WUFFcEYsSUFBSWdMLFNBQVNDLFFBQVE7Z0JBQ25CLE9BQU87WUFDVDtZQUVBLElBQUlBLFNBQVNELFFBQVE7Z0JBQ25CLE9BQU8sQ0FBQztZQUNWLEVBQUUsd0NBQXdDO1lBRzFDLElBQUlmLEtBQUtDLElBQUk7Z0JBQ1gsT0FBTztZQUNUO1lBRUEsSUFBSUEsS0FBS0QsSUFBSTtnQkFDWCxPQUFPLENBQUM7WUFDVjtZQUVBO1FBQ0Y7UUFFQSxPQUFPclksRUFBRTlMLE1BQU0sR0FBRytlLEVBQUUvZSxNQUFNO0lBQzVCO0lBQ0EsU0FBU29sQixPQUFPdEIsSUFBSSxFQUFFQyxJQUFJLEVBQUV6UixRQUFRO1FBQ2xDLElBQUkrUyx5QkFBeUJwQix1QkFBdUJILE1BQU1DLE1BQU16UixXQUM1RHhHLElBQUl1WixzQkFBc0IsQ0FBQyxFQUFFLEVBQzdCdEcsSUFBSXNHLHNCQUFzQixDQUFDLEVBQUU7UUFFakMsSUFBSUMsb0JBQW9CO1FBQ3hCeFosSUFBSTlLLE9BQU9ELE9BQU8rSyxHQUFHb0MsT0FBTyxDQUFDb1gsbUJBQW1CO1FBQ2hEdkcsSUFBSS9kLE9BQU9ELE9BQU9nZSxHQUFHN1EsT0FBTyxDQUFDb1gsbUJBQW1CO1FBQ2hELE9BQU9ULGFBQWEvWSxHQUFHaVQ7SUFDekIsRUFBRSxRQUFRO0lBRVYsU0FBUzhGLGFBQWEvWSxDQUFDLEVBQUVpVCxDQUFDO1FBQ3hCLE9BQU9qVCxNQUFNaVQsSUFBSSxJQUFJalQsSUFBSWlULElBQUksSUFBSSxDQUFDO0lBQ3BDO0lBRUEsU0FBU2tGLHVCQUF1QnNCLElBQUksRUFBRUMsSUFBSSxFQUFFbFQsUUFBUTtRQUNsRCxPQUFPO1lBQUNpVCxLQUFLaFAsTUFBTSxDQUFDakUsU0FBUztZQUFFa1QsS0FBS2pQLE1BQU0sQ0FBQ2pFLFNBQVM7U0FBQztJQUN2RDtJQUVBLFNBQVM0UixTQUFTcFksQ0FBQztRQUNqQixJQUFJLE9BQU9BLE1BQU0sVUFBVTtZQUN6QixJQUFJMlksTUFBTTNZLE1BQU1BLE1BQU04TyxZQUFZOU8sTUFBTSxDQUFDOE8sVUFBVTtnQkFDakQsT0FBTztZQUNUO1lBRUEsT0FBTzdaLE9BQU8rSztRQUNoQjtRQUVBLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3pCLE9BQU9BO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJMlosWUFBWSxXQUFXLEdBQUV0bkIsT0FBTzJjLE1BQU0sQ0FBQztRQUN6Q0MsV0FBVztRQUNYOEksY0FBY0E7UUFDZGEsVUFBVUE7UUFDVkksT0FBT0E7UUFDUEUsUUFBUUE7UUFDUkksUUFBUUE7SUFDVjtJQUVBamtCLFFBQVF1a0IsV0FBVyxHQUFHO0lBQ3RCdmtCLFFBQVF3a0IsU0FBUyxHQUFHO0lBQ3BCeGtCLFFBQVF5a0IsWUFBWSxHQUFHO0lBQ3ZCemtCLFFBQVEwa0IsV0FBVyxHQUFHO0lBQ3RCbGtCLGNBQWNta0IsUUFBUSxHQUFHO0lBQ3pCbmtCLGNBQWNva0IsYUFBYSxHQUFHO0lBQzlCLElBQUlDLFlBQVksU0FBU0EsVUFBVTdpQixLQUFLO1FBQ3RDQSxNQUFNOGlCLG9CQUFvQixHQUFHO1lBQUNDO1NBQTRCO1FBQzFEL2lCLE1BQU1xTSxhQUFhLENBQUM1RSxJQUFJLENBQUN1YjtRQUN6QmhqQixNQUFNaU4sV0FBVyxDQUFDeEYsSUFBSSxDQUFDd2I7SUFDekI7SUFDQUosVUFBVTloQixVQUFVLEdBQUc7SUFFdkIsSUFBSWdpQiw4QkFBOEIsU0FBU0EsNEJBQTRCM2pCLEtBQUssRUFBRWpCLElBQUk7UUFDaEYsSUFBSWtHLFdBQVdsRyxLQUFLa0csUUFBUSxFQUN4QkMsU0FBU25HLEtBQUttRyxNQUFNO1FBQ3hCLElBQUk0ZSx3QkFBd0I3ZSxTQUFTOGUsZ0JBQWdCLEVBQ2pEQSxtQkFBbUJELDBCQUEwQixLQUFLLElBQUksU0FBVTFhLENBQUM7WUFDbkUsT0FBT0EsRUFBRTRhLFFBQVE7UUFDbkIsSUFBSUY7UUFDSixPQUFPO1lBQUM5akI7WUFBTztnQkFDYmtXLFNBQVNoUixPQUFPK2UsT0FBTyxHQUFHLFNBQVU3YSxDQUFDO29CQUNuQ0EsRUFBRXlVLE9BQU87b0JBQ1QzWSxPQUFPbWUsWUFBWSxDQUFDam1CLFdBQVcsQ0FBQzZILFNBQVNpZixnQkFBZ0IsSUFBSUgsaUJBQWlCM2E7Z0JBQ2hGLElBQUloTTtnQkFDSjhDLE9BQU87b0JBQ0xnSixRQUFRaEUsT0FBTytlLE9BQU8sR0FBRyxZQUFZN21CO2dCQUN2QztnQkFDQW9TLE9BQU90SyxPQUFPK2UsT0FBTyxHQUFHLGtCQUFrQjdtQjtZQUM1QztTQUFFO0lBQ0osR0FBRyxVQUFVO0lBR2IsU0FBU3dtQixVQUFVMVUsS0FBSyxFQUFFUyxNQUFNLEVBQUVDLGFBQWEsRUFBRTNLLFFBQVE7UUFDdkQsSUFBSTBLLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRQyxJQUFJLEVBQUU7WUFDaEMsT0FBT3hCLFNBQVM7Z0JBQ2Q4bUIsUUFBUSxFQUFFO1lBQ1osR0FBR2pWO1FBQ0w7UUFFQSxJQUFJUyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXVrQixXQUFXLEVBQUU7WUFDdkMsT0FBTzlsQixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCaVYsUUFBUWxmLFNBQVM0SyxZQUFZLENBQUNzVSxNQUFNLElBQUksRUFBRTtZQUM1QztRQUNGO1FBRUEsSUFBSXhVLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRMGtCLFdBQVcsRUFBRTtZQUN2QyxJQUFJYSxTQUFTalYsTUFBTWlWLE1BQU07WUFDekIsSUFBSUMsWUFBWUQsT0FBTzFaLE1BQU0sQ0FBQyxTQUFVMUMsQ0FBQztnQkFDdkMsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS29KLE9BQU9JLFFBQVE7WUFDakM7WUFDQSxPQUFPMVMsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmlWLFFBQVFDO1lBQ1Y7UUFDRjtRQUVBLElBQUl6VSxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXdrQixTQUFTLEVBQUU7WUFDckMsSUFBSWlCLFVBQVUxVSxPQUFPd1UsTUFBTTtZQUMzQixPQUFPOW1CLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJpVixRQUFRRTtZQUNWO1FBQ0Y7UUFFQSxJQUFJMVUsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVF5a0IsWUFBWSxFQUFFO1lBQ3hDLElBQUl0VCxXQUFXSixPQUFPSSxRQUFRLEVBQzFCdVUsT0FBTzNVLE9BQU8yVSxJQUFJLEVBQ2xCQyxRQUFRNVUsT0FBTzRVLEtBQUs7WUFDeEIsSUFBSXBkLGFBQWFsQyxTQUFTa0MsVUFBVSxFQUNoQytjLG1CQUFtQmpmLFNBQVNpZixnQkFBZ0IsRUFDNUNNLG9CQUFvQnZmLFNBQVN1ZixpQkFBaUIsRUFDOUNDLHFCQUFxQnhmLFNBQVN3ZixrQkFBa0IsRUFDaERDLHdCQUF3QnpmLFNBQVMwZixvQkFBb0IsRUFDckRBLHVCQUF1QkQsMEJBQTBCLEtBQUssSUFBSWptQixPQUFPZ0IsZ0JBQWdCLEdBQUdpbEI7WUFDeEYsSUFBSUUsV0FBVzFWLE1BQU1pVixNQUFNLEVBQUUsb0NBQW9DO1lBRWpFLElBQUlqZixTQUFTaUMsV0FBV2dNLElBQUksQ0FBQyxTQUFVcEwsQ0FBQztnQkFDdEMsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS3dKO1lBQ2xCO1lBQ0EsSUFBSXlULGdCQUFnQnRlLE9BQU9zZSxhQUFhLEVBQUUsMkNBQTJDO1lBRXJGLElBQUlxQixpQkFBaUJELFNBQVN6UixJQUFJLENBQUMsU0FBVXBMLENBQUM7Z0JBQzVDLE9BQU9BLEVBQUV4QixFQUFFLEtBQUt3SjtZQUNsQjtZQUVBLElBQUkrVSxnQkFBZ0JGLFNBQVM5aUIsU0FBUyxDQUFDLFNBQVVpRyxDQUFDO2dCQUNoRCxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLd0o7WUFDbEI7WUFFQSxJQUFJZ1YsaUJBQWlCLE9BQU9ULFNBQVMsZUFBZUEsU0FBUztZQUM3RCxJQUFJVSxhQUFhLEVBQUUsRUFBRSwyQ0FBMkM7WUFFaEUsSUFBSUM7WUFFSixJQUFJLENBQUNmLG9CQUFvQkssT0FBTztnQkFDOUIsSUFBSU0sZ0JBQWdCO29CQUNsQkksYUFBYTtnQkFDZixPQUFPO29CQUNMQSxhQUFhO2dCQUNmO1lBQ0YsT0FBTztnQkFDTCxjQUFjO2dCQUNkLElBQUlILGtCQUFrQkYsU0FBU25uQixNQUFNLEdBQUcsS0FBS21uQixTQUFTbm5CLE1BQU0sS0FBSyxHQUFHO29CQUNsRXduQixhQUFhO2dCQUNmLE9BQU8sSUFBSUosZ0JBQWdCO29CQUN6QkksYUFBYTtnQkFDZixPQUFPO29CQUNMQSxhQUFhO2dCQUNmO1lBQ0YsRUFBRSxtREFBbUQ7WUFHckQsSUFBSUEsZUFBZSxZQUFZLG1CQUFtQjtZQUNsRCxDQUFDVCxxQkFBcUIsMkNBQTJDO1lBQ2pFLENBQUNPLGtCQUNEUixDQUFBQSxRQUFRLENBQUNFLHFCQUFxQixJQUFHLEtBQ2pDSSxDQUFBQSxrQkFBa0IsaURBQWlEO1lBQ25FQSxlQUFlUCxJQUFJLElBQUksQ0FBQ2QsaUJBQWlCLENBQUNxQixlQUFlUCxJQUFJLElBQUlkLGFBQVksR0FBSTtnQkFDL0V5QixhQUFhO1lBQ2Y7WUFFQSxJQUFJQSxlQUFlLFdBQVc7Z0JBQzVCRCxhQUFhO29CQUFDO3dCQUNaemUsSUFBSXdKO3dCQUNKdVUsTUFBTVMsaUJBQWlCVCxPQUFPZDtvQkFDaEM7aUJBQUU7WUFDSixPQUFPLElBQUl5QixlQUFlLE9BQU87Z0JBQy9CRCxhQUFhLEVBQUUsQ0FBQ3RrQixNQUFNLENBQUNra0IsVUFBVTtvQkFBQzt3QkFDaENyZSxJQUFJd0o7d0JBQ0p1VSxNQUFNUyxpQkFBaUJULE9BQU9kO29CQUNoQztpQkFBRSxHQUFHLHdCQUF3QjtnQkFFN0J3QixXQUFXRSxNQUFNLENBQUMsR0FBR0YsV0FBV3ZuQixNQUFNLEdBQUdrbkI7WUFDM0MsT0FBTyxJQUFJTSxlQUFlLFVBQVU7Z0JBQ2xDLDJCQUEyQjtnQkFDM0JELGFBQWFKLFNBQVN6ZSxHQUFHLENBQUMsU0FBVTRCLENBQUM7b0JBQ25DLElBQUlBLEVBQUV4QixFQUFFLEtBQUt3SixVQUFVO3dCQUNyQixPQUFPMVMsU0FBUyxDQUFDLEdBQUcwSyxHQUFHOzRCQUNyQnVjLE1BQU1TLGlCQUFpQlQsT0FBTyxDQUFDTyxlQUFlUCxJQUFJO3dCQUNwRDtvQkFDRjtvQkFFQSxPQUFPdmM7Z0JBQ1Q7WUFDRixPQUFPLElBQUlrZCxlQUFlLFVBQVU7Z0JBQ2xDRCxhQUFhSixTQUFTbmEsTUFBTSxDQUFDLFNBQVUxQyxDQUFDO29CQUN0QyxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLd0o7Z0JBQ2xCO1lBQ0Y7WUFFQSxPQUFPMVMsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmlWLFFBQVFhO1lBQ1Y7UUFDRjtJQUNGO0lBRUEsU0FBU25CLGNBQWM1ZSxRQUFRO1FBQzdCLElBQUlpTixPQUFPak4sU0FBU2lOLElBQUksRUFDcEJ0SSxPQUFPM0UsU0FBUzJFLElBQUksRUFDcEJnSixXQUFXM04sU0FBUzJOLFFBQVEsRUFDNUJ6TCxhQUFhbEMsU0FBU2tDLFVBQVUsRUFDaENnZSxzQkFBc0JsZ0IsU0FBU21nQixTQUFTLEVBQ3hDQSxZQUFZRCx3QkFBd0IsS0FBSyxJQUFJRSxtQkFBbUJGLHFCQUNoRUcsZ0JBQWdCcmdCLFNBQVNpZSxTQUFTLEVBQ2xDcUMsZUFBZXRnQixTQUFTc2dCLFlBQVksRUFDcENDLGlCQUFpQnZnQixTQUFTdWdCLGNBQWMsRUFDeENDLGdCQUFnQnhnQixTQUFTd2dCLGFBQWEsRUFDdENuVixjQUFjckwsU0FBU3FMLFdBQVcsRUFDbEM2VCxTQUFTbGYsU0FBU2lLLEtBQUssQ0FBQ2lWLE1BQU0sRUFDOUI1VCxXQUFXdEwsU0FBU3NMLFFBQVEsRUFDNUI5TyxVQUFVd0QsU0FBU3hELE9BQU8sRUFDMUIrTyxXQUFXdkwsU0FBU3VMLFFBQVEsRUFDNUJrVix3QkFBd0J6Z0IsU0FBUzBnQixlQUFlLEVBQ2hEQSxrQkFBa0JELDBCQUEwQixLQUFLLElBQUksT0FBT0E7UUFDaEVsa0Isa0JBQWtCQyxTQUFTO1lBQUM7WUFBYztZQUFtQjtZQUFjO1NBQWtCLEVBQUU7UUFDL0YsSUFBSTJoQixZQUFZem5CLE1BQU0rRyxXQUFXLENBQUMsU0FBVXloQixNQUFNO1lBQ2hENVQsU0FBUztnQkFDUHBMLE1BQU12RyxRQUFRd2tCLFNBQVM7Z0JBQ3ZCZSxRQUFRQTtZQUNWO1FBQ0YsR0FBRztZQUFDNVQ7U0FBUyxHQUFHLGdFQUFnRTtRQUVoRixJQUFJOFMsZUFBZTFuQixNQUFNK0csV0FBVyxDQUFDLFNBQVVxTixRQUFRLEVBQUV1VSxJQUFJLEVBQUVDLEtBQUs7WUFDbEVoVSxTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVF5a0IsWUFBWTtnQkFDMUJ0VCxVQUFVQTtnQkFDVnVVLE1BQU1BO2dCQUNOQyxPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDaFU7U0FBUyxHQUFHLDhDQUE4QztRQUU5RCxJQUFJSSxjQUFjdE8sYUFBYTRDLFdBQVcsNkRBQTZEO1FBRXZHcUwsWUFBWWhQLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtZQUNsQyxJQUFJc0IsV0FBV3RCLE9BQU9zQixRQUFRLEVBQzFCb2YsdUJBQXVCMWdCLE9BQU8rZSxPQUFPLEVBQ3JDNEIsc0JBQXNCM2dCLE9BQU91Z0IsYUFBYSxFQUMxQ2xmLEtBQUtyQixPQUFPcUIsRUFBRTtZQUNsQixJQUFJMGQsVUFBVXpkLFdBQVc2QyxnQkFBZ0J3Yyx3QkFBd0IsT0FBTyxRQUFRem9CLFdBQVdxb0Isa0JBQWtCLE9BQU8sUUFBUXJvQixXQUFXLFFBQVFpTSxnQkFBZ0JtYyxnQkFBZ0JJLHNCQUFzQjtZQUNyTTFnQixPQUFPK2UsT0FBTyxHQUFHQTtZQUVqQixJQUFJL2UsT0FBTytlLE9BQU8sRUFBRTtnQkFDbEIvZSxPQUFPbWUsWUFBWSxHQUFHLFNBQVVpQixJQUFJLEVBQUVDLEtBQUs7b0JBQ3pDLE9BQU9sQixhQUFhbmUsT0FBT3FCLEVBQUUsRUFBRStkLE1BQU1DO2dCQUN2QztnQkFFQXJmLE9BQU9vZSxXQUFXLEdBQUc7b0JBQ25CL1MsU0FBUzt3QkFDUHBMLE1BQU12RyxRQUFRMGtCLFdBQVc7d0JBQ3pCdlQsVUFBVTdLLE9BQU9xQixFQUFFO29CQUNyQjtnQkFDRjtZQUNGO1lBRUFyQixPQUFPd2Usb0JBQW9CLEdBQUcvaUIsZUFBZTZQLFdBQVdrVCxvQkFBb0IsRUFBRTtnQkFDNUV6ZSxVQUFVMEw7Z0JBQ1Z6TCxRQUFRQTtZQUNWO1lBQ0EsSUFBSTRnQixhQUFhM0IsT0FBT2hSLElBQUksQ0FBQyxTQUFVcEwsQ0FBQztnQkFDdEMsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS0E7WUFDbEI7WUFDQXJCLE9BQU82Z0IsUUFBUSxHQUFHLENBQUMsQ0FBQ0Q7WUFDcEI1Z0IsT0FBTzhnQixXQUFXLEdBQUc3QixPQUFPcmlCLFNBQVMsQ0FBQyxTQUFVaUcsQ0FBQztnQkFDL0MsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS0E7WUFDbEI7WUFDQXJCLE9BQU8rZ0IsWUFBWSxHQUFHL2dCLE9BQU82Z0IsUUFBUSxHQUFHRCxXQUFXeEIsSUFBSSxHQUFHbG5CO1FBQzVEO1FBRUEsSUFBSXVWLGlCQUFpQmhYLE1BQU0rVyxPQUFPLENBQUM7WUFDakMsSUFBSTZTLGdCQUFnQixDQUFDcEIsT0FBTzFtQixNQUFNLEVBQUU7Z0JBQ2xDLE9BQU87b0JBQUNtTTtvQkFBTWdKO2lCQUFTO1lBQ3pCO1lBRUEsSUFBSXNULGlCQUFpQixFQUFFLEVBQUUsNkRBQTZEO1lBRXRGLElBQUlDLGtCQUFrQmhDLE9BQU8xWixNQUFNLENBQUMsU0FBVThJLElBQUk7Z0JBQ2hELE9BQU9wTSxXQUFXZ00sSUFBSSxDQUFDLFNBQVU4SyxHQUFHO29CQUNsQyxPQUFPQSxJQUFJMVgsRUFBRSxLQUFLZ04sS0FBS2hOLEVBQUU7Z0JBQzNCO1lBQ0Y7WUFFQSxJQUFJNmYsV0FBVyxTQUFTQSxTQUFTeGMsSUFBSTtnQkFDbkMsMkRBQTJEO2dCQUMzRCw4REFBOEQ7Z0JBQzlELGFBQWE7Z0JBQ2IsSUFBSXljLGFBQWFqQixVQUFVeGIsTUFBTXVjLGdCQUFnQmhnQixHQUFHLENBQUMsU0FBVW9OLElBQUk7b0JBQ2pFLGlEQUFpRDtvQkFDakQsSUFBSXJPLFNBQVNpQyxXQUFXZ00sSUFBSSxDQUFDLFNBQVVwTCxDQUFDO3dCQUN0QyxPQUFPQSxFQUFFeEIsRUFBRSxLQUFLZ04sS0FBS2hOLEVBQUU7b0JBQ3pCO29CQUVBLElBQUksQ0FBQ3JCLFFBQVE7d0JBQ1gsTUFBTSxJQUFJL0QsTUFBTSxtREFBbURvUyxLQUFLaE4sRUFBRSxHQUFHO29CQUMvRTtvQkFFQSxJQUFJZ2QsV0FBV3JlLE9BQU9xZSxRQUFRLEVBQUUsMENBQTBDO29CQUMxRSxrQkFBa0I7b0JBQ2xCLHdDQUF3QztvQkFDeEMsNENBQTRDO29CQUM1QyxtQkFBbUI7b0JBQ25CLHlDQUF5QztvQkFDekMsNkNBQTZDO29CQUU3QyxJQUFJK0MsYUFBYWhkLFdBQVdpYSxhQUFhLENBQUMrQixpQkFBaUIsQ0FBQyxFQUFFLENBQUMvQixTQUFTLElBQUlMLFNBQVMsQ0FBQ0ssU0FBUztvQkFFL0YsSUFBSSxDQUFDK0MsWUFBWTt3QkFDZixNQUFNLElBQUlubEIsTUFBTSxzREFBc0RvaUIsV0FBVyxtQkFBbUJoUSxLQUFLaE4sRUFBRSxHQUFHO29CQUNoSCxFQUFFLDZCQUE2QjtvQkFDL0Isd0RBQXdEO29CQUd4RCxPQUFPLFNBQVVnRCxDQUFDLEVBQUVpVCxDQUFDO3dCQUNuQixPQUFPOEosV0FBVy9jLEdBQUdpVCxHQUFHakosS0FBS2hOLEVBQUUsRUFBRWdOLEtBQUsrUSxJQUFJO29CQUM1QztnQkFDRixJQUNBNkIsZ0JBQWdCaGdCLEdBQUcsQ0FBQyxTQUFVb04sSUFBSTtvQkFDaEMseUNBQXlDO29CQUN6QyxJQUFJck8sU0FBU2lDLFdBQVdnTSxJQUFJLENBQUMsU0FBVXBMLENBQUM7d0JBQ3RDLE9BQU9BLEVBQUV4QixFQUFFLEtBQUtnTixLQUFLaE4sRUFBRTtvQkFDekI7b0JBRUEsSUFBSXJCLFVBQVVBLE9BQU9xaEIsWUFBWSxFQUFFO3dCQUNqQyxPQUFPaFQsS0FBSytRLElBQUk7b0JBQ2xCO29CQUVBLE9BQU8sQ0FBQy9RLEtBQUsrUSxJQUFJO2dCQUNuQixLQUFLLG1DQUFtQztnQkFFeEMrQixXQUFXL2tCLE9BQU8sQ0FBQyxTQUFVc0YsR0FBRztvQkFDOUJzZixlQUFlN2QsSUFBSSxDQUFDekI7b0JBRXBCLElBQUksQ0FBQ0EsSUFBSTJELE9BQU8sSUFBSTNELElBQUkyRCxPQUFPLENBQUM5TSxNQUFNLEtBQUssR0FBRzt3QkFDNUM7b0JBQ0Y7b0JBRUFtSixJQUFJMkQsT0FBTyxHQUFHNmIsU0FBU3hmLElBQUkyRCxPQUFPO2dCQUNwQztnQkFDQSxPQUFPOGI7WUFDVDtZQUVBLE9BQU87Z0JBQUNELFNBQVN4YztnQkFBT3NjO2FBQWU7UUFDekMsR0FBRztZQUFDWDtZQUFjcEI7WUFBUXZhO1lBQU1nSjtZQUFVekw7WUFBWWllO1lBQVdFO1NBQWMsR0FDM0VrQixhQUFhN1QsY0FBYyxDQUFDLEVBQUUsRUFDOUJ1VCxpQkFBaUJ2VCxjQUFjLENBQUMsRUFBRTtRQUV0QyxJQUFJOFQscUJBQXFCcGtCLGFBQWFzakI7UUFDdEM1aUIsdUJBQXVCO1lBQ3JCLElBQUkwakIsc0JBQXNCO2dCQUN4QmxXLFNBQVM7b0JBQ1BwTCxNQUFNdkcsUUFBUXVrQixXQUFXO2dCQUMzQjtZQUNGO1FBQ0YsR0FBRztZQUFDb0MsZUFBZSxPQUFPclQ7U0FBSztRQUMvQnRXLE9BQU8wQixNQUFNLENBQUMySCxVQUFVO1lBQ3RCeWhCLGVBQWU5YztZQUNmK2MsbUJBQW1CL1Q7WUFDbkI0VCxZQUFZQTtZQUNaTixnQkFBZ0JBO1lBQ2hCdGMsTUFBTTRjO1lBQ041VCxVQUFVc1Q7WUFDVjlDLFdBQVdBO1lBQ1hDLGNBQWNBO1FBQ2hCO0lBQ0Y7SUFFQSxTQUFTZ0MsaUJBQWlCN2IsR0FBRyxFQUFFb2QsS0FBSyxFQUFFQyxJQUFJO1FBQ3hDLE9BQU8sRUFBRSxDQUFDbm1CLE1BQU0sQ0FBQzhJLEtBQUsrSixJQUFJLENBQUMsU0FBVWdPLElBQUksRUFBRUMsSUFBSTtZQUM3QyxJQUFLLElBQUloa0IsSUFBSSxHQUFHQSxJQUFJb3BCLE1BQU1ucEIsTUFBTSxFQUFFRCxLQUFLLEVBQUc7Z0JBQ3hDLElBQUlzcEIsU0FBU0YsS0FBSyxDQUFDcHBCLEVBQUU7Z0JBQ3JCLElBQUk4bUIsT0FBT3VDLElBQUksQ0FBQ3JwQixFQUFFLEtBQUssU0FBU3FwQixJQUFJLENBQUNycEIsRUFBRSxLQUFLO2dCQUM1QyxJQUFJdXBCLFVBQVVELE9BQU92RixNQUFNQztnQkFFM0IsSUFBSXVGLFlBQVksR0FBRztvQkFDakIsT0FBT3pDLE9BQU8sQ0FBQ3lDLFVBQVVBO2dCQUMzQjtZQUNGO1lBRUEsT0FBT0YsSUFBSSxDQUFDLEVBQUUsR0FBR3RGLEtBQUtoVixLQUFLLEdBQUdpVixLQUFLalYsS0FBSyxHQUFHaVYsS0FBS2pWLEtBQUssR0FBR2dWLEtBQUtoVixLQUFLO1FBQ3BFO0lBQ0Y7SUFFQSxJQUFJNUssYUFBYSxpQkFBaUIsVUFBVTtJQUU1Qy9DLFFBQVFvb0IsU0FBUyxHQUFHO0lBQ3BCcG9CLFFBQVFxb0IsUUFBUSxHQUFHO0lBQ25Ccm9CLFFBQVFzb0IsV0FBVyxHQUFHO0lBQ3RCLElBQUlDLGdCQUFnQixTQUFTQSxjQUFjdm1CLEtBQUs7UUFDOUNBLE1BQU1xTSxhQUFhLENBQUM1RSxJQUFJLENBQUMrZTtRQUN6QnhtQixNQUFNaU4sV0FBVyxDQUFDeEYsSUFBSSxDQUFDZ2Y7SUFDekI7SUFDQUYsY0FBY3hsQixVQUFVLEdBQUdBO0lBRTNCLFNBQVN5bEIsVUFBVWxZLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkaXFCLFVBQVU7Z0JBQ1ZDLFdBQVc7WUFDYixHQUFHclk7UUFDTDtRQUVBLElBQUlTLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRb29CLFNBQVMsRUFBRTtZQUNyQyxPQUFPM3BCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJxWSxXQUFXdGlCLFNBQVM0SyxZQUFZLENBQUMwWCxTQUFTLElBQUk7WUFDaEQ7UUFDRjtRQUVBLElBQUk1WCxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXFvQixRQUFRLEVBQUU7WUFDcEMsSUFBSU8sWUFBWXZpQixTQUFTdWlCLFNBQVMsRUFDOUJDLE9BQU94aUIsU0FBU3dpQixJQUFJO1lBQ3hCLElBQUlDLGVBQWV4bEIsaUJBQWlCeU4sT0FBTzRYLFNBQVMsRUFBRXJZLE1BQU1xWSxTQUFTO1lBQ3JFLElBQUlJLGNBQWM7WUFFbEIsSUFBSUQsZUFBZXhZLE1BQU1xWSxTQUFTLEVBQUU7Z0JBQ2xDLFlBQVk7Z0JBQ1pJLGNBQWNILGNBQWMsQ0FBQyxJQUFJQyxLQUFLaHFCLE1BQU0sSUFBSXlSLE1BQU1vWSxRQUFRLEdBQUdJLGVBQWVGO1lBQ2xGLE9BQU8sSUFBSUUsZUFBZXhZLE1BQU1xWSxTQUFTLEVBQUU7Z0JBQ3pDLFlBQVk7Z0JBQ1pJLGNBQWNELGVBQWUsQ0FBQztZQUNoQztZQUVBLElBQUksQ0FBQ0MsYUFBYTtnQkFDaEIsT0FBT3pZO1lBQ1Q7WUFFQSxPQUFPN1IsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QnFZLFdBQVdHO1lBQ2I7UUFDRjtRQUVBLElBQUkvWCxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXNvQixXQUFXLEVBQUU7WUFDdkMsSUFBSUksV0FBVzNYLE9BQU8yWCxRQUFRO1lBQzlCLElBQUlNLGNBQWMxWSxNQUFNb1ksUUFBUSxHQUFHcFksTUFBTXFZLFNBQVM7WUFDbEQsSUFBSUEsWUFBWXhTLEtBQUt1SCxLQUFLLENBQUNzTCxjQUFjTjtZQUN6QyxPQUFPanFCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJxWSxXQUFXQTtnQkFDWEQsVUFBVUE7WUFDWjtRQUNGO0lBQ0Y7SUFFQSxTQUFTRCxjQUFjcGlCLFFBQVE7UUFDN0IsSUFBSTJFLE9BQU8zRSxTQUFTMkUsSUFBSSxFQUNwQmllLHdCQUF3QjVpQixTQUFTNmlCLGFBQWEsRUFDOUNBLGdCQUFnQkQsMEJBQTBCLEtBQUssSUFBSSxPQUFPQSx1QkFDMURqUix3QkFBd0IzUixTQUFTNEUsaUJBQWlCLEVBQ2xEQSxvQkFBb0IrTSwwQkFBMEIsS0FBSyxJQUFJLGFBQWFBLHVCQUNwRW5WLFVBQVV3RCxTQUFTeEQsT0FBTyxFQUMxQnNtQixnQkFBZ0I5aUIsU0FBU3VpQixTQUFTLEVBQ2xDM1Esd0JBQXdCNVIsU0FBUzZSLG9CQUFvQixFQUNyREEsdUJBQXVCRCwwQkFBMEIsS0FBSyxJQUFJLE9BQU9BLHVCQUNqRUUsd0JBQXdCOVIsU0FBUytFLGFBQWEsRUFDOUNBLGdCQUFnQitNLDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQzFEaVIsa0JBQWtCL2lCLFNBQVNpSyxLQUFLLEVBQ2hDb1ksV0FBV1UsZ0JBQWdCVixRQUFRLEVBQ25DQyxZQUFZUyxnQkFBZ0JULFNBQVMsRUFDckN6ZCxXQUFXa2UsZ0JBQWdCbGUsUUFBUSxFQUNuQ2lSLGVBQWVpTixnQkFBZ0JqTixZQUFZLEVBQzNDaEMsVUFBVWlQLGdCQUFnQmpQLE9BQU8sRUFDakMwRSxVQUFVdUssZ0JBQWdCdkssT0FBTyxFQUNqQzBHLFNBQVM2RCxnQkFBZ0I3RCxNQUFNLEVBQy9CNVQsV0FBV3RMLFNBQVNzTCxRQUFRLEVBQzVCMkIsT0FBT2pOLFNBQVNpTixJQUFJLEVBQ3BCK1YsbUJBQW1CaGpCLFNBQVNnakIsZ0JBQWdCO1FBQ2hEem1CLGtCQUFrQkMsU0FBUztZQUFDO1lBQW1CO1lBQWM7WUFBYztZQUFhO1NBQWMsRUFBRTtRQUN4RyxJQUFJeW1CLG1CQUFtQjdsQixhQUFheWxCO1FBQ3BDL2tCLHVCQUF1QjtZQUNyQixJQUFJbWxCLG9CQUFvQjtnQkFDdEIzWCxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVFvb0IsU0FBUztnQkFDekI7WUFDRjtRQUNGLEdBQUc7WUFBQ3pXO1lBQVUwWCxtQkFBbUIsT0FBTy9WO1lBQU02STtZQUFjaEM7WUFBUzBFO1lBQVMwRztTQUFPO1FBQ3JGLElBQUlxRCxZQUFZUyxtQkFBbUJGLGdCQUFnQmhULEtBQUtvVCxJQUFJLENBQUN2ZSxLQUFLbk0sTUFBTSxHQUFHNnBCO1FBQzNFLElBQUljLGNBQWN6c0IsTUFBTStXLE9BQU8sQ0FBQztZQUM5QixPQUFPOFUsWUFBWSxJQUFJLEVBQUUsQ0FBQzltQixNQUFNLENBQUMsSUFBSWIsTUFBTTJuQixZQUFZYSxJQUFJLENBQUMsTUFBTWxpQixHQUFHLENBQUMsU0FBVTRCLENBQUMsRUFBRXZLLENBQUM7Z0JBQ2xGLE9BQU9BO1lBQ1QsS0FBSyxFQUFFO1FBQ1QsR0FBRztZQUFDZ3FCO1NBQVU7UUFDZCxJQUFJQyxPQUFPOXJCLE1BQU0rVyxPQUFPLENBQUM7WUFDdkIsSUFBSStVO1lBRUosSUFBSVEsa0JBQWtCO2dCQUNwQlIsT0FBTzdkO1lBQ1QsT0FBTztnQkFDTCxJQUFJMGUsWUFBWWhCLFdBQVdDO2dCQUMzQixJQUFJZ0IsVUFBVUQsWUFBWWhCO2dCQUMxQkcsT0FBTzdkLEtBQUs0ZSxLQUFLLENBQUNGLFdBQVdDO1lBQy9CO1lBRUEsSUFBSXpSLHNCQUFzQjtnQkFDeEIsT0FBTzJRO1lBQ1Q7WUFFQSxPQUFPOWQsV0FBVzhkLE1BQU07Z0JBQ3RCNWQsbUJBQW1CQTtnQkFDbkJDLFVBQVVBO2dCQUNWRSxlQUFlQTtZQUNqQjtRQUNGLEdBQUc7WUFBQ0E7WUFBZUY7WUFBVUQ7WUFBbUJvZTtZQUFrQlY7WUFBV0Q7WUFBVXhRO1lBQXNCbE47U0FBSztRQUNsSCxJQUFJNmUsa0JBQWtCbEIsWUFBWTtRQUNsQyxJQUFJbUIsY0FBY2xCLGNBQWMsQ0FBQyxJQUFJQyxLQUFLaHFCLE1BQU0sSUFBSTZwQixXQUFXQyxZQUFZQyxZQUFZO1FBQ3ZGLElBQUlQLFdBQVd0ckIsTUFBTStHLFdBQVcsQ0FBQyxTQUFVNmtCLFNBQVM7WUFDbERoWCxTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVFxb0IsUUFBUTtnQkFDdEJNLFdBQVdBO1lBQ2I7UUFDRixHQUFHO1lBQUNoWDtTQUFTO1FBQ2IsSUFBSW9ZLGVBQWVodEIsTUFBTStHLFdBQVcsQ0FBQztZQUNuQyxPQUFPdWtCLFNBQVMsU0FBVTdrQixHQUFHO2dCQUMzQixPQUFPQSxNQUFNO1lBQ2Y7UUFDRixHQUFHO1lBQUM2a0I7U0FBUztRQUNiLElBQUkyQixXQUFXanRCLE1BQU0rRyxXQUFXLENBQUM7WUFDL0IsT0FBT3VrQixTQUFTLFNBQVU3a0IsR0FBRztnQkFDM0IsT0FBT0EsTUFBTTtZQUNmO1FBQ0YsR0FBRztZQUFDNmtCO1NBQVM7UUFDYixJQUFJQyxjQUFjdnJCLE1BQU0rRyxXQUFXLENBQUMsU0FBVTRrQixRQUFRO1lBQ3BEL1csU0FBUztnQkFDUHBMLE1BQU12RyxRQUFRc29CLFdBQVc7Z0JBQ3pCSSxVQUFVQTtZQUNaO1FBQ0YsR0FBRztZQUFDL1c7U0FBUztRQUNiM1UsT0FBTzBCLE1BQU0sQ0FBQzJILFVBQVU7WUFDdEJtakIsYUFBYUE7WUFDYlosV0FBV0E7WUFDWEMsTUFBTUE7WUFDTmdCLGlCQUFpQkE7WUFDakJDLGFBQWFBO1lBQ2J6QixVQUFVQTtZQUNWMEIsY0FBY0E7WUFDZEMsVUFBVUE7WUFDVjFCLGFBQWFBO1FBQ2Y7SUFDRjtJQUVBdG9CLFFBQVFpcUIsVUFBVSxHQUFHO0lBQ3JCanFCLFFBQVFrcUIsV0FBVyxHQUFHO0lBQ3RCLElBQUlDLDRCQUE0QixTQUFTQSwwQkFBMEJub0IsS0FBSztRQUN0RUEsTUFBTW9vQixtQkFBbUIsR0FBRztZQUFDQztTQUEyQjtRQUN4RHJvQixNQUFNcU0sYUFBYSxDQUFDNUUsSUFBSSxDQUFDNmdCO1FBQ3pCdG9CLE1BQU00TSxvQkFBb0IsQ0FBQ25GLElBQUksQ0FBQ21GO1FBQ2hDNU0sTUFBTXVHLFVBQVUsQ0FBQ2tCLElBQUksQ0FBQ2xCO1FBQ3RCdkcsTUFBTXlNLFdBQVcsQ0FBQ2hGLElBQUksQ0FBQ2dGO1FBQ3ZCek0sTUFBTTBNLG1CQUFtQixDQUFDakYsSUFBSSxDQUFDaUY7UUFDL0IxTSxNQUFNMk0sdUJBQXVCLENBQUNsRixJQUFJLENBQUNrRjtRQUNuQzNNLE1BQU02TSxjQUFjLENBQUNwRixJQUFJLENBQUM4Z0I7UUFDMUJ2b0IsTUFBTThNLGtCQUFrQixDQUFDckYsSUFBSSxDQUFDcUY7UUFDOUI5TSxNQUFNaU4sV0FBVyxDQUFDeEYsSUFBSSxDQUFDK2dCO1FBQ3ZCeG9CLE1BQU1rTixVQUFVLENBQUN6RixJQUFJLENBQUNnaEI7SUFDeEI7SUFDQU4sMEJBQTBCcG5CLFVBQVUsR0FBRztJQUN2QyxJQUFJMm5CLHNCQUFzQixFQUFFO0lBRTVCLElBQUlMLDZCQUE2QixTQUFTQSwyQkFBMkJqcEIsS0FBSyxFQUFFakIsSUFBSTtRQUM5RSxJQUFJd1YsU0FBU3hWLEtBQUt3VixNQUFNO1FBQ3hCLE9BQU87WUFBQ3ZVO1lBQU87Z0JBQ2JrVyxTQUFTM0IsT0FBT2dWLFFBQVEsR0FBRyxTQUFVbmdCLENBQUM7b0JBQ3BDQSxFQUFFeVUsT0FBTztvQkFDVHRKLE9BQU91VSxXQUFXO2dCQUNwQixJQUFJMXJCO2dCQUNKOEMsT0FBTztvQkFDTGdKLFFBQVFxTCxPQUFPZ1YsUUFBUSxHQUFHLFlBQVluc0I7Z0JBQ3hDO2dCQUNBb1MsT0FBTztZQUNUO1NBQUU7SUFDSixHQUFHLFVBQVU7SUFHYixTQUFTMFosVUFBVWhhLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkbXNCLGNBQWNGO1lBQ2hCLEdBQUdwYTtRQUNMO1FBRUEsSUFBSVMsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVFpcUIsVUFBVSxFQUFFO1lBQ3RDLE9BQU94ckIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QnNhLGNBQWN2a0IsU0FBUzRLLFlBQVksQ0FBQzJaLFlBQVksSUFBSUY7WUFDdEQ7UUFDRjtRQUVBLElBQUkzWixPQUFPeEssSUFBSSxLQUFLdkcsUUFBUWtxQixXQUFXLEVBQUU7WUFDdkMsSUFBSS9ZLFdBQVdKLE9BQU9JLFFBQVEsRUFDMUIwWixXQUFXOVosT0FBT2xULEtBQUs7WUFDM0IsSUFBSWl0QixnQkFBZ0IsT0FBT0QsYUFBYSxjQUFjQSxXQUFXLENBQUN2YSxNQUFNc2EsWUFBWSxDQUFDM2pCLFFBQVEsQ0FBQ2tLO1lBRTlGLElBQUkyWixlQUFlO2dCQUNqQixPQUFPcnNCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztvQkFDekJzYSxjQUFjLEVBQUUsQ0FBQzlvQixNQUFNLENBQUN3TyxNQUFNc2EsWUFBWSxFQUFFO3dCQUFDelo7cUJBQVM7Z0JBQ3hEO1lBQ0Y7WUFFQSxPQUFPMVMsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QnNhLGNBQWN0YSxNQUFNc2EsWUFBWSxDQUFDL2UsTUFBTSxDQUFDLFNBQVUxQyxDQUFDO29CQUNqRCxPQUFPQSxNQUFNZ0k7Z0JBQ2Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxTQUFTdkMscUJBQXFCdkksUUFBUTtRQUNwQ0EsU0FBU2tDLFVBQVUsQ0FBQzdGLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtZQUMxQ0EsT0FBT3lrQixhQUFhLEdBQUcxa0IsU0FBU2lLLEtBQUssQ0FBQ3NhLFlBQVksQ0FBQzNqQixRQUFRLENBQUNYLE9BQU9xQixFQUFFO1FBQ3ZFO0lBQ0Y7SUFFQSxTQUFTWSxXQUFXbkIsT0FBTyxFQUFFeEMsS0FBSztRQUNoQyxJQUFJeUIsV0FBV3pCLE1BQU15QixRQUFRO1FBQzdCZSxRQUFRMUUsT0FBTyxDQUFDLFNBQVU0RCxNQUFNO1lBQzlCQSxPQUFPeWtCLGFBQWEsR0FBRzFrQixTQUFTaUssS0FBSyxDQUFDc2EsWUFBWSxDQUFDM2pCLFFBQVEsQ0FBQ1gsT0FBT3FCLEVBQUU7WUFDckVyQixPQUFPMGtCLFlBQVksR0FBRyxJQUFJak47UUFDNUI7UUFDQSxPQUFPM1c7SUFDVDtJQUVBLFNBQVNxSCxZQUFZNVEsS0FBSyxFQUFFNlAsS0FBSztRQUMvQixJQUFJcEgsU0FBU29ILE1BQU1wSCxNQUFNO1FBRXpCLElBQUlBLE9BQU8wa0IsWUFBWSxJQUFJLE9BQU9udEIsVUFBVSxhQUFhO1lBQ3ZEeUksT0FBTzBrQixZQUFZLENBQUNDLEdBQUcsQ0FBQ3B0QjtRQUMxQjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQSxTQUFTNlEsb0JBQW9Cd2MsWUFBWSxFQUFFcmQsS0FBSztRQUM5QyxJQUFJeEgsV0FBV3dILE1BQU14SCxRQUFRO1FBQzdCLElBQUlrQyxhQUFhbEMsU0FBU2tDLFVBQVUsRUFDaEMrSCxRQUFRakssU0FBU2lLLEtBQUs7UUFFMUIsSUFBSSxDQUFDQSxNQUFNc2EsWUFBWSxDQUFDL3JCLE1BQU0sSUFBSSxDQUFDeVIsTUFBTXVPLE9BQU8sSUFBSSxDQUFDdk8sTUFBTXVPLE9BQU8sQ0FBQ2hnQixNQUFNLEVBQUU7WUFDekUsT0FBT3FzQjtRQUNUO1FBRUEsSUFBSU4sZUFBZXRhLE1BQU1zYSxZQUFZLENBQUNyakIsR0FBRyxDQUFDLFNBQVVJLEVBQUU7WUFDcEQsT0FBT1ksV0FBV2dNLElBQUksQ0FBQyxTQUFVcEwsQ0FBQztnQkFDaEMsT0FBT0EsRUFBRXhCLEVBQUUsS0FBS0E7WUFDbEI7UUFDRixHQUFHa0UsTUFBTSxDQUFDdUg7UUFDVixJQUFJK1gsZ0JBQWdCNWlCLFdBQVdzRCxNQUFNLENBQUMsU0FBVTFDLENBQUM7WUFDL0MsT0FBTyxDQUFDQSxFQUFFNGhCLGFBQWEsSUFBSSxDQUFDemEsTUFBTXVPLE9BQU8sQ0FBQzVYLFFBQVEsQ0FBQ2tDLEVBQUV4QixFQUFFLEtBQUssQ0FBQzJJLE1BQU1zYSxZQUFZLENBQUMzakIsUUFBUSxDQUFDa0MsRUFBRXhCLEVBQUU7UUFDL0Y7UUFFQSxJQUFJeWpCLG9CQUFvQixTQUFTQSxrQkFBa0I5akIsS0FBSyxFQUFFRCxNQUFNLEVBQUVna0IsWUFBWTtZQUM1RSxJQUFJL2pCLFVBQVUsS0FBSyxHQUFHO2dCQUNwQkEsUUFBUTtZQUNWO1lBRUEsSUFBSStqQixpQkFBaUIsS0FBSyxHQUFHO2dCQUMzQkEsZUFBZSxFQUFFO1lBQ25CO1lBRUEsSUFBSUMsY0FBY1YsWUFBWSxDQUFDdGpCLE1BQU07WUFFckMsSUFBSSxDQUFDZ2tCLGFBQWE7Z0JBQ2hCLE9BQU9ILGNBQWM1akIsR0FBRyxDQUFDLFNBQVVna0IsWUFBWTtvQkFDN0MsMERBQTBEO29CQUMxRCx5REFBeUQ7b0JBQ3pELG1FQUFtRTtvQkFDbkUsd0RBQXdEO29CQUN4RCxrQkFBa0I7b0JBQ2xCLE9BQU85c0IsU0FBUyxDQUFDLEdBQUc4c0IsY0FBYzt3QkFDaENaLFVBQVU7d0JBQ1ZhLFdBQVc7d0JBQ1hua0IsUUFBUUE7d0JBQ1JDLE9BQU9BO3dCQUNQSyxJQUFJLEtBQU1OLENBQUFBLFNBQVNBLE9BQU9NLEVBQUUsR0FBRyxNQUFNNGpCLGFBQWE1akIsRUFBRSxHQUFHNGpCLGFBQWE1akIsRUFBRTt3QkFDdEVDLFVBQVUsU0FBU0EsU0FBUzRPLFdBQVcsRUFBRTVYLENBQUMsRUFBRW9KLEdBQUc7NEJBQzdDLElBQUlxakIsYUFBYWxTLEtBQUssQ0FBQyxTQUFVdE4sTUFBTTtnQ0FDckMsT0FBT0EsT0FBTzdEOzRCQUNoQixJQUFJO2dDQUNGLE9BQU9BLElBQUlvTixNQUFNLENBQUNtVyxhQUFhNWpCLEVBQUUsQ0FBQzs0QkFDcEM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlxakIsZUFBZS9wQixNQUFNNmMsSUFBSSxDQUFDd04sWUFBWU4sWUFBWSxFQUFFclcsSUFBSTtZQUM1RCxPQUFPcVcsYUFBYXpqQixHQUFHLENBQUMsU0FBVWtrQixXQUFXO2dCQUMzQyxJQUFJQyxjQUFjanRCLFNBQVMsQ0FBQyxHQUFHNnNCLGFBQWE7b0JBQzFDempCLFFBQVF5akIsWUFBWUssV0FBVyxJQUFJLE9BQU9MLFlBQVkzVixNQUFNLEtBQUssV0FBVzJWLFlBQVl6akIsTUFBTSxHQUFHLE9BQU80akIsY0FBY0E7b0JBQ3RIRyxjQUFjO29CQUNkdmtCLFFBQVFBO29CQUNSQyxPQUFPQTtvQkFDUEssSUFBSU4sU0FBU0EsT0FBT00sRUFBRSxHQUFHLE1BQU0yakIsWUFBWTNqQixFQUFFLEdBQUcsTUFBTThqQixjQUFjSCxZQUFZM2pCLEVBQUUsR0FBRyxNQUFNOGpCO29CQUMzRkksWUFBWUo7Z0JBQ2Q7Z0JBRUFDLFlBQVl0a0IsT0FBTyxHQUFHZ2tCLGtCQUFrQjlqQixRQUFRLEdBQUdva0IsYUFBYSxFQUFFLENBQUM1cEIsTUFBTSxDQUFDdXBCLGNBQWM7b0JBQUMsU0FBVXJqQixHQUFHO3dCQUNwRyxPQUFPQSxJQUFJb04sTUFBTSxDQUFDa1csWUFBWTNqQixFQUFFLENBQUMsS0FBSzhqQjtvQkFDeEM7aUJBQUU7Z0JBQ0YsT0FBT0M7WUFDVDtRQUNGO1FBRUEsSUFBSUksa0JBQWtCcmtCLGVBQWUyakI7UUFDckMsT0FBTyxFQUFFLENBQUN0cEIsTUFBTSxDQUFDb3BCLGNBQWNZO0lBQ2pDO0lBRUEsU0FBU25kLHdCQUF3QnZLLElBQUksRUFBRTJKLEtBQUs7UUFDMUMsSUFBSWdlLHVCQUF1QmhlLE1BQU0xSCxRQUFRLENBQUNpSyxLQUFLLEVBQzNDc2EsZUFBZW1CLHFCQUFxQm5CLFlBQVksRUFDaEQvTCxVQUFVa04scUJBQXFCbE4sT0FBTztRQUMxQyxPQUFPLEVBQUUsQ0FBQy9jLE1BQU0sQ0FBQ3NDLE1BQU07WUFBQ3dtQjtZQUFjL0w7U0FBUTtJQUNoRDtJQUVBLFNBQVMwTCxpQkFBaUIxYixjQUFjLEVBQUVaLEtBQUs7UUFDN0MsSUFBSXFDLFFBQVFyQyxNQUFNNUgsUUFBUSxDQUFDaUssS0FBSztRQUNoQ3pCLGlCQUFpQkEsZUFBZWhELE1BQU0sQ0FBQyxTQUFVMUMsQ0FBQztZQUNoRCxPQUFPLENBQUNBLEVBQUU0aEIsYUFBYTtRQUN6QjtRQUVBLElBQUl6YSxNQUFNc2EsWUFBWSxDQUFDL3JCLE1BQU0sSUFBSXlSLE1BQU11TyxPQUFPLElBQUl2TyxNQUFNdU8sT0FBTyxDQUFDaGdCLE1BQU0sRUFBRTtZQUN0RWdRLGlCQUFpQkEsZUFBZWhELE1BQU0sQ0FBQyxTQUFVdkYsTUFBTTtnQkFDckQsT0FBT0EsT0FBT2laLFNBQVMsSUFBSWpaLE9BQU9rbEIsU0FBUztZQUM3QztRQUNGO1FBRUEsT0FBTzNjO0lBQ1Q7SUFFQSxTQUFTQyxtQkFBbUIxSyxJQUFJLEVBQUU0bkIsS0FBSztRQUNyQyxJQUFJM2xCLFdBQVcybEIsTUFBTTNsQixRQUFRO1FBQzdCLE9BQU8sRUFBRSxDQUFDdkUsTUFBTSxDQUFDc0MsTUFBTTtZQUFDaUMsU0FBU2lLLEtBQUssQ0FBQ3NhLFlBQVk7WUFBRXZrQixTQUFTaUssS0FBSyxDQUFDdU8sT0FBTztTQUFDO0lBQzlFO0lBRUEsU0FBUzJMLGNBQWNua0IsUUFBUTtRQUM3QixJQUFJZSxVQUFVZixTQUFTZSxPQUFPLEVBQzFCbUIsYUFBYWxDLFNBQVNrQyxVQUFVLEVBQ2hDbUosY0FBY3JMLFNBQVNxTCxXQUFXLEVBQ2xDRSxXQUFXdkwsU0FBU3VMLFFBQVEsRUFDNUIvTyxVQUFVd0QsU0FBU3hELE9BQU8sRUFDMUI4TyxXQUFXdEwsU0FBU3NMLFFBQVEsRUFDNUJzYSx3QkFBd0I1bEIsU0FBUzZsQixjQUFjLEVBQy9DQSxpQkFBaUJELDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQzNERSxjQUFjOWxCLFNBQVM4bEIsV0FBVyxFQUNsQ0MsZUFBZS9sQixTQUFTK2xCLFlBQVksRUFDcENDLGtCQUFrQmhtQixTQUFTZ21CLGVBQWU7UUFDOUN6cEIsa0JBQWtCQyxTQUFTO1lBQUM7U0FBYSxFQUFFO1FBQzNDLElBQUlrUCxjQUFjdE8sYUFBYTRDO1FBQy9Ca0MsV0FBVzdGLE9BQU8sQ0FBQyxTQUFVNEQsTUFBTTtZQUNqQyxJQUFJc0IsV0FBV3RCLE9BQU9zQixRQUFRLEVBQzFCMGtCLHFCQUFxQmhtQixPQUFPaW1CLFlBQVksRUFDeENDLHFCQUFxQmxtQixPQUFPOGxCLFlBQVk7WUFDNUM5bEIsT0FBT3FrQixRQUFRLEdBQUcvaUIsV0FBVzZDLGdCQUFnQm5FLE9BQU9xa0IsUUFBUSxFQUFFNkIsdUJBQXVCLE9BQU8sUUFBUWh1QixXQUFXNHRCLGlCQUFpQixPQUFPLFFBQVE1dEIsV0FBVyxRQUFRaU0sZ0JBQWdCbkUsT0FBT3FrQixRQUFRLEVBQUUyQixvQkFBb0JELGlCQUFpQjtZQUV4TyxJQUFJL2xCLE9BQU9xa0IsUUFBUSxFQUFFO2dCQUNuQnJrQixPQUFPNGpCLFdBQVcsR0FBRztvQkFDbkIsT0FBTzdqQixTQUFTNmpCLFdBQVcsQ0FBQzVqQixPQUFPcUIsRUFBRTtnQkFDdkM7WUFDRjtZQUVBckIsT0FBT2lhLFVBQVUsR0FBR2phLE9BQU9pYSxVQUFVLElBQUlqYSxPQUFPN0YsSUFBSTtRQUN0RDtRQUVBLElBQUl5cEIsY0FBYyxTQUFTQSxZQUFZL1ksUUFBUSxFQUFFdFQsS0FBSztZQUNwRDhULFNBQVM7Z0JBQ1BwTCxNQUFNdkcsUUFBUWtxQixXQUFXO2dCQUN6Qi9ZLFVBQVVBO2dCQUNWdFQsT0FBT0E7WUFDVDtRQUNGO1FBRUE2VCxZQUFZaFAsT0FBTyxDQUFDLFNBQVVpVCxNQUFNO1lBQ2xDQSxPQUFPeVUsbUJBQW1CLEdBQUdyb0IsZUFBZTZQLFdBQVd3WSxtQkFBbUIsRUFBRTtnQkFDMUUvakIsVUFBVTBMO2dCQUNWNEQsUUFBUUE7WUFDVjtRQUNGO1FBQ0EsSUFBSThXLG9CQUFvQmhwQixhQUFheW9CO1FBQ3JDL25CLHVCQUF1QjtZQUNyQixJQUFJc29CLHFCQUFxQjtnQkFDdkI5YSxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVFpcUIsVUFBVTtnQkFDMUI7WUFDRjtRQUNGLEdBQUc7WUFBQ3RZO1lBQVV3YSxjQUFjLE9BQU8va0I7U0FBUTtRQUMzQ3BLLE9BQU8wQixNQUFNLENBQUMySCxVQUFVO1lBQ3RCNmpCLGFBQWFBO1FBQ2Y7SUFDRjtJQUVBLFNBQVNPLGFBQWF6aUIsR0FBRztRQUN2QkEsSUFBSW1OLFFBQVEsQ0FBQ3pTLE9BQU8sQ0FBQyxTQUFVd0wsSUFBSTtZQUNqQyx1RUFBdUU7WUFDdkVBLEtBQUtzZCxTQUFTLEdBQUd0ZCxLQUFLNUgsTUFBTSxDQUFDa2xCLFNBQVM7UUFDeEM7SUFDRjtJQUVBLElBQUlrQixlQUFlLGdCQUFnQixVQUFVO0lBRTdDMXNCLFFBQVEyc0IsaUJBQWlCLEdBQUc7SUFDNUIzc0IsUUFBUTRzQixxQkFBcUIsR0FBRztJQUNoQzVzQixRQUFRNnNCLGlCQUFpQixHQUFHO0lBQzVCN3NCLFFBQVE4c0IseUJBQXlCLEdBQUc7SUFDcEMsSUFBSUMsZUFBZSxTQUFTQSxhQUFhL3FCLEtBQUs7UUFDNUNBLE1BQU1nckIseUJBQXlCLEdBQUc7WUFBQ0M7U0FBaUM7UUFDcEVqckIsTUFBTWtyQiw2QkFBNkIsR0FBRztZQUFDQztTQUFxQztRQUM1RW5yQixNQUFNb3JCLGlDQUFpQyxHQUFHO1lBQUNDO1NBQXlDO1FBQ3BGcnJCLE1BQU1xTSxhQUFhLENBQUM1RSxJQUFJLENBQUM2akI7UUFDekJ0ckIsTUFBTWlOLFdBQVcsQ0FBQ3hGLElBQUksQ0FBQzhqQjtRQUN2QnZyQixNQUFNa04sVUFBVSxDQUFDekYsSUFBSSxDQUFDK2pCO0lBQ3hCO0lBQ0FULGFBQWFocUIsVUFBVSxHQUFHMnBCO0lBRTFCLElBQUlPLG1DQUFtQyxTQUFTQSxpQ0FBaUM3ckIsS0FBSyxFQUFFakIsSUFBSTtRQUMxRixJQUFJa0csV0FBV2xHLEtBQUtrRyxRQUFRLEVBQ3hCMkIsTUFBTTdILEtBQUs2SCxHQUFHO1FBQ2xCLElBQUl5bEIsd0JBQXdCcG5CLFNBQVNxbkIsb0JBQW9CLEVBQ3JEQSx1QkFBdUJELDBCQUEwQixLQUFLLElBQUksZUFBZUE7UUFDN0UsSUFBSS9jLFVBQVU7UUFFZCxJQUFJMUksSUFBSXlELFFBQVEsSUFBSXpELElBQUl5RCxRQUFRLENBQUNpaUIscUJBQXFCLEVBQUU7WUFDdERoZCxVQUFVO1FBQ1osT0FBTztZQUNMQSxVQUFVMUksSUFBSTJsQixVQUFVO1FBQzFCO1FBRUEsT0FBTztZQUFDdnNCO1lBQU87Z0JBQ2JvUCxVQUFVLFNBQVNBLFNBQVNoRyxDQUFDO29CQUMzQnhDLElBQUk2a0IsaUJBQWlCLENBQUNyaUIsRUFBRTdMLE1BQU0sQ0FBQytSLE9BQU87Z0JBQ3hDO2dCQUNBcFAsT0FBTztvQkFDTGdKLFFBQVE7Z0JBQ1Y7Z0JBQ0FvRyxTQUFTQTtnQkFDVEUsT0FBTztnQkFDUEUsZUFBZTlJLElBQUk0bEIsY0FBYztZQUNuQztTQUFFO0lBQ0o7SUFFQSxJQUFJVCx1Q0FBdUMsU0FBU0EscUNBQXFDL3JCLEtBQUssRUFBRXdELEtBQUs7UUFDbkcsSUFBSXlCLFdBQVd6QixNQUFNeUIsUUFBUTtRQUM3QixPQUFPO1lBQUNqRjtZQUFPO2dCQUNib1AsVUFBVSxTQUFTQSxTQUFTaEcsQ0FBQztvQkFDM0JuRSxTQUFTdW1CLHFCQUFxQixDQUFDcGlCLEVBQUU3TCxNQUFNLENBQUMrUixPQUFPO2dCQUNqRDtnQkFDQXBQLE9BQU87b0JBQ0xnSixRQUFRO2dCQUNWO2dCQUNBb0csU0FBU3JLLFNBQVN3bkIsaUJBQWlCO2dCQUNuQ2pkLE9BQU87Z0JBQ1BFLGVBQWVzQyxRQUFRLENBQUMvTSxTQUFTd25CLGlCQUFpQixJQUFJN3dCLE9BQU9rQyxJQUFJLENBQUNtSCxTQUFTaUssS0FBSyxDQUFDd2QsY0FBYyxFQUFFanZCLE1BQU07WUFDekc7U0FBRTtJQUNKO0lBRUEsSUFBSXd1QiwyQ0FBMkMsU0FBU0EseUNBQXlDanNCLEtBQUssRUFBRXNNLEtBQUs7UUFDM0csSUFBSXJILFdBQVdxSCxNQUFNckgsUUFBUTtRQUM3QixPQUFPO1lBQUNqRjtZQUFPO2dCQUNib1AsVUFBVSxTQUFTQSxTQUFTaEcsQ0FBQztvQkFDM0JuRSxTQUFTeW1CLHlCQUF5QixDQUFDdGlCLEVBQUU3TCxNQUFNLENBQUMrUixPQUFPO2dCQUNyRDtnQkFDQXBQLE9BQU87b0JBQ0xnSixRQUFRO2dCQUNWO2dCQUNBb0csU0FBU3JLLFNBQVMwbkIscUJBQXFCO2dCQUN2Q25kLE9BQU87Z0JBQ1BFLGVBQWVzQyxRQUFRLENBQUMvTSxTQUFTMG5CLHFCQUFxQixJQUFJMW5CLFNBQVN3aUIsSUFBSSxDQUFDM2YsSUFBSSxDQUFDLFNBQVUyRSxLQUFLO29CQUMxRixJQUFJbEcsS0FBS2tHLE1BQU1sRyxFQUFFO29CQUNqQixPQUFPdEIsU0FBU2lLLEtBQUssQ0FBQ3dkLGNBQWMsQ0FBQ25tQixHQUFHO2dCQUMxQztZQUNGO1NBQUU7SUFDSixHQUFHLHNDQUFzQztJQUd6QyxTQUFTMmxCLFVBQVVoZCxLQUFLLEVBQUVTLE1BQU0sRUFBRUMsYUFBYSxFQUFFM0ssUUFBUTtRQUN2RCxJQUFJMEssT0FBT3hLLElBQUksS0FBS3ZHLFFBQVFDLElBQUksRUFBRTtZQUNoQyxPQUFPeEIsU0FBUztnQkFDZHF2QixnQkFBZ0IsQ0FBQztZQUNuQixHQUFHeGQ7UUFDTDtRQUVBLElBQUlTLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRMnNCLGlCQUFpQixFQUFFO1lBQzdDLE9BQU9sdUIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QndkLGdCQUFnQnpuQixTQUFTNEssWUFBWSxDQUFDNmMsY0FBYyxJQUFJLENBQUM7WUFDM0Q7UUFDRjtRQUVBLElBQUkvYyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUTRzQixxQkFBcUIsRUFBRTtZQUNqRCxJQUFJb0IsY0FBY2pkLE9BQU9sVCxLQUFLO1lBQzlCLElBQUlnd0Isb0JBQW9CeG5CLFNBQVN3bkIsaUJBQWlCLEVBQzlDNVosV0FBVzVOLFNBQVM0TixRQUFRLEVBQzVCZ2Esd0JBQXdCNW5CLFNBQVNtYixrQkFBa0IsRUFDbkRBLHFCQUFxQnlNLDBCQUEwQixLQUFLLElBQUloYSxXQUFXZ2E7WUFDdkUsSUFBSUMsWUFBWSxPQUFPRixnQkFBZ0IsY0FBY0EsY0FBYyxDQUFDSCxtQkFBbUIsMERBQTBEO1lBQ2pKLHFEQUFxRDtZQUVyRCxJQUFJQyxpQkFBaUI5d0IsT0FBTzBCLE1BQU0sQ0FBQyxDQUFDLEdBQUc0UixNQUFNd2QsY0FBYztZQUUzRCxJQUFJSSxXQUFXO2dCQUNibHhCLE9BQU9rQyxJQUFJLENBQUNzaUIsb0JBQW9COWUsT0FBTyxDQUFDLFNBQVUrVSxLQUFLO29CQUNyRHFXLGNBQWMsQ0FBQ3JXLE1BQU0sR0FBRztnQkFDMUI7WUFDRixPQUFPO2dCQUNMemEsT0FBT2tDLElBQUksQ0FBQ3NpQixvQkFBb0I5ZSxPQUFPLENBQUMsU0FBVStVLEtBQUs7b0JBQ3JELE9BQU9xVyxjQUFjLENBQUNyVyxNQUFNO2dCQUM5QjtZQUNGO1lBRUEsT0FBT2haLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJ3ZCxnQkFBZ0JBO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJL2MsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVE2c0IsaUJBQWlCLEVBQUU7WUFDN0MsSUFBSWxsQixLQUFLb0osT0FBT3BKLEVBQUUsRUFDZHdtQixlQUFlcGQsT0FBT2xULEtBQUs7WUFDL0IsSUFBSXV3QixZQUFZL25CLFNBQVM0TixRQUFRLEVBQzdCb2Esd0JBQXdCaG9CLFNBQVNpb0IsYUFBYSxFQUM5Q0EsZ0JBQWdCRCwwQkFBMEIsS0FBSyxJQUFJLE9BQU9BLHVCQUMxRHpiLGFBQWF2TSxTQUFTdU0sVUFBVTtZQUNwQyxJQUFJK2EsYUFBYXJkLE1BQU13ZCxjQUFjLENBQUNubUIsR0FBRztZQUN6QyxJQUFJaVEsY0FBYyxPQUFPdVcsaUJBQWlCLGNBQWNBLGVBQWUsQ0FBQ1I7WUFFeEUsSUFBSUEsZUFBZS9WLGFBQWE7Z0JBQzlCLE9BQU90SDtZQUNUO1lBRUEsSUFBSWllLG9CQUFvQjl2QixTQUFTLENBQUMsR0FBRzZSLE1BQU13ZCxjQUFjO1lBRXpELElBQUlVLGdCQUFnQixTQUFTQSxjQUFjN21CLEVBQUU7Z0JBQzNDLElBQUlLLE1BQU1vbUIsU0FBUyxDQUFDem1CLEdBQUc7Z0JBRXZCLElBQUlLLEtBQUs7b0JBQ1AsSUFBSSxDQUFDQSxJQUFJdVgsU0FBUyxFQUFFO3dCQUNsQixJQUFJM0gsYUFBYTs0QkFDZjJXLGlCQUFpQixDQUFDNW1CLEdBQUcsR0FBRzt3QkFDMUIsT0FBTzs0QkFDTCxPQUFPNG1CLGlCQUFpQixDQUFDNW1CLEdBQUc7d0JBQzlCO29CQUNGO29CQUVBLElBQUkybUIsaUJBQWlCMWIsV0FBVzVLLE1BQU07d0JBQ3BDLE9BQU80SyxXQUFXNUssS0FBS3RGLE9BQU8sQ0FBQyxTQUFVc0YsR0FBRzs0QkFDMUMsT0FBT3dtQixjQUFjeG1CLElBQUlMLEVBQUU7d0JBQzdCO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQTZtQixjQUFjN21CO1lBQ2QsT0FBT2xKLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJ3ZCxnQkFBZ0JTO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJeGQsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVE4c0IseUJBQXlCLEVBQUU7WUFDckQsSUFBSTJCLGdCQUFnQjFkLE9BQU9sVCxLQUFLO1lBRWhDLElBQUlnckIsT0FBT3hpQixTQUFTd2lCLElBQUksRUFDcEI2RixhQUFhcm9CLFNBQVM0TixRQUFRLEVBQzlCMGEseUJBQXlCdG9CLFNBQVNpb0IsYUFBYSxFQUMvQ00saUJBQWlCRCwyQkFBMkIsS0FBSyxJQUFJLE9BQU9BLHdCQUM1RFosd0JBQXdCMW5CLFNBQVMwbkIscUJBQXFCLEVBQ3REYyxjQUFjeG9CLFNBQVN1TSxVQUFVO1lBRXJDLElBQUlrYyxhQUFhLE9BQU9MLGtCQUFrQixjQUFjQSxnQkFBZ0IsQ0FBQ1Y7WUFFekUsSUFBSWdCLHFCQUFxQnR3QixTQUFTLENBQUMsR0FBRzZSLE1BQU13ZCxjQUFjO1lBRTFELElBQUlrQixpQkFBaUIsU0FBU0EsZUFBZXJuQixFQUFFO2dCQUM3QyxJQUFJSyxNQUFNMG1CLFVBQVUsQ0FBQy9tQixHQUFHO2dCQUV4QixJQUFJLENBQUNLLElBQUl1WCxTQUFTLEVBQUU7b0JBQ2xCLElBQUl1UCxZQUFZO3dCQUNkQyxrQkFBa0IsQ0FBQ3BuQixHQUFHLEdBQUc7b0JBQzNCLE9BQU87d0JBQ0wsT0FBT29uQixrQkFBa0IsQ0FBQ3BuQixHQUFHO29CQUMvQjtnQkFDRjtnQkFFQSxJQUFJaW5CLGtCQUFrQkMsWUFBWTdtQixNQUFNO29CQUN0QyxPQUFPNm1CLFlBQVk3bUIsS0FBS3RGLE9BQU8sQ0FBQyxTQUFVc0YsR0FBRzt3QkFDM0MsT0FBT2duQixlQUFlaG5CLElBQUlMLEVBQUU7b0JBQzlCO2dCQUNGO1lBQ0Y7WUFFQWtoQixLQUFLbm1CLE9BQU8sQ0FBQyxTQUFVc0YsR0FBRztnQkFDeEIsT0FBT2duQixlQUFlaG5CLElBQUlMLEVBQUU7WUFDOUI7WUFDQSxPQUFPbEosU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QndkLGdCQUFnQmlCO1lBQ2xCO1FBQ0Y7UUFFQSxPQUFPemU7SUFDVDtJQUVBLFNBQVNpZCxjQUFjbG5CLFFBQVE7UUFDN0IsSUFBSWlOLE9BQU9qTixTQUFTaU4sSUFBSSxFQUNwQnRJLE9BQU8zRSxTQUFTMkUsSUFBSSxFQUNwQjRHLFdBQVd2TCxTQUFTdUwsUUFBUSxFQUM1Qi9PLFVBQVV3RCxTQUFTeEQsT0FBTyxFQUMxQm9SLFdBQVc1TixTQUFTNE4sUUFBUSxFQUM1QmdiLHlCQUF5QjVvQixTQUFTbWIsa0JBQWtCLEVBQ3BEQSxxQkFBcUJ5TiwyQkFBMkIsS0FBSyxJQUFJaGIsV0FBV2diLHdCQUNwRUMsd0JBQXdCN29CLFNBQVM4b0IscUJBQXFCLEVBQ3REQSx3QkFBd0JELDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQ2xFcEIsaUJBQWlCem5CLFNBQVNpSyxLQUFLLENBQUN3ZCxjQUFjLEVBQzlDc0IseUJBQXlCL29CLFNBQVNpb0IsYUFBYSxFQUMvQ0EsZ0JBQWdCYywyQkFBMkIsS0FBSyxJQUFJLE9BQU9BLHdCQUMzRHpkLFdBQVd0TCxTQUFTc0wsUUFBUSxFQUM1QmtYLE9BQU94aUIsU0FBU3dpQixJQUFJLEVBQ3BCalcsYUFBYXZNLFNBQVN1TSxVQUFVO1FBQ3BDaFEsa0JBQWtCQyxTQUFTO1lBQUM7WUFBYztZQUFjO1lBQWE7WUFBZTtTQUFnQixFQUFFO1FBQ3RHLElBQUl3c0IsbUJBQW1CdHlCLE1BQU0rVyxPQUFPLENBQUM7WUFDbkMsSUFBSXViLG1CQUFtQixFQUFFO1lBQ3pCcmtCLEtBQUt0SSxPQUFPLENBQUMsU0FBVXNGLEdBQUc7Z0JBQ3hCLElBQUkybEIsYUFBYVcsZ0JBQWdCZ0IsaUJBQWlCdG5CLEtBQUs4bEIsZ0JBQWdCbGIsY0FBYyxDQUFDLENBQUNrYixjQUFjLENBQUM5bEIsSUFBSUwsRUFBRSxDQUFDO2dCQUM3R0ssSUFBSTJsQixVQUFVLEdBQUcsQ0FBQyxDQUFDQTtnQkFDbkIzbEIsSUFBSTRsQixjQUFjLEdBQUdELGVBQWU7Z0JBRXBDLElBQUlBLFlBQVk7b0JBQ2QwQixpQkFBaUI1bEIsSUFBSSxDQUFDekI7Z0JBQ3hCO1lBQ0Y7WUFDQSxPQUFPcW5CO1FBQ1QsR0FBRztZQUFDcmtCO1lBQU1zakI7WUFBZVI7WUFBZ0JsYjtTQUFXO1FBQ3BELElBQUlpYixvQkFBb0J6YSxRQUFRcFcsT0FBT2tDLElBQUksQ0FBQ3NpQixvQkFBb0IzaUIsTUFBTSxJQUFJN0IsT0FBT2tDLElBQUksQ0FBQzR1QixnQkFBZ0JqdkIsTUFBTTtRQUM1RyxJQUFJa3ZCLHdCQUF3QkY7UUFFNUIsSUFBSUEsbUJBQW1CO1lBQ3JCLElBQUk3d0IsT0FBT2tDLElBQUksQ0FBQ3NpQixvQkFBb0J0WSxJQUFJLENBQUMsU0FBVXZCLEVBQUU7Z0JBQ25ELE9BQU8sQ0FBQ21tQixjQUFjLENBQUNubUIsR0FBRztZQUM1QixJQUFJO2dCQUNGa21CLG9CQUFvQjtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDQSxtQkFBbUI7WUFDdEIsSUFBSWhGLFFBQVFBLEtBQUtocUIsTUFBTSxJQUFJZ3FCLEtBQUszZixJQUFJLENBQUMsU0FBVTZFLEtBQUs7Z0JBQ2xELElBQUlwRyxLQUFLb0csTUFBTXBHLEVBQUU7Z0JBQ2pCLE9BQU8sQ0FBQ21tQixjQUFjLENBQUNubUIsR0FBRztZQUM1QixJQUFJO2dCQUNGb21CLHdCQUF3QjtZQUMxQjtRQUNGO1FBRUEsSUFBSXdCLDJCQUEyQjlyQixhQUFhMHJCO1FBQzVDaHJCLHVCQUF1QjtZQUNyQixJQUFJb3JCLDRCQUE0QjtnQkFDOUI1ZCxTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVEyc0IsaUJBQWlCO2dCQUNqQztZQUNGO1FBQ0YsR0FBRztZQUFDaGI7WUFBVTJCO1NBQUs7UUFDbkIsSUFBSXNaLHdCQUF3Qjd2QixNQUFNK0csV0FBVyxDQUFDLFNBQVVqRyxLQUFLO1lBQzNELE9BQU84VCxTQUFTO2dCQUNkcEwsTUFBTXZHLFFBQVE0c0IscUJBQXFCO2dCQUNuQy91QixPQUFPQTtZQUNUO1FBQ0YsR0FBRztZQUFDOFQ7U0FBUztRQUNiLElBQUltYiw0QkFBNEIvdkIsTUFBTStHLFdBQVcsQ0FBQyxTQUFVakcsS0FBSztZQUMvRCxPQUFPOFQsU0FBUztnQkFDZHBMLE1BQU12RyxRQUFROHNCLHlCQUF5QjtnQkFDdkNqdkIsT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJa2Isb0JBQW9COXZCLE1BQU0rRyxXQUFXLENBQUMsU0FBVTZELEVBQUUsRUFBRTlKLEtBQUs7WUFDM0QsT0FBTzhULFNBQVM7Z0JBQ2RwTCxNQUFNdkcsUUFBUTZzQixpQkFBaUI7Z0JBQy9CbGxCLElBQUlBO2dCQUNKOUosT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJSSxjQUFjdE8sYUFBYTRDO1FBQy9CLElBQUk2bUIsZ0NBQWdDbnJCLGVBQWU2UCxXQUFXc2IsNkJBQTZCLEVBQUU7WUFDM0Y3bUIsVUFBVTBMO1FBQ1o7UUFDQSxJQUFJcWIsb0NBQW9DcnJCLGVBQWU2UCxXQUFXd2IsaUNBQWlDLEVBQUU7WUFDbkcvbUIsVUFBVTBMO1FBQ1o7UUFDQS9VLE9BQU8wQixNQUFNLENBQUMySCxVQUFVO1lBQ3RCZ3BCLGtCQUFrQkE7WUFDbEJ4QixtQkFBbUJBO1lBQ25CRSx1QkFBdUJBO1lBQ3ZCbEIsbUJBQW1CQTtZQUNuQkQsdUJBQXVCQTtZQUN2Qk0sK0JBQStCQTtZQUMvQkUsbUNBQW1DQTtZQUNuQ04sMkJBQTJCQTtRQUM3QjtJQUNGO0lBRUEsU0FBU1UsYUFBYXhsQixHQUFHLEVBQUVpRyxLQUFLO1FBQzlCLElBQUk1SCxXQUFXNEgsTUFBTTVILFFBQVE7UUFFN0IyQixJQUFJNmtCLGlCQUFpQixHQUFHLFNBQVV6aUIsR0FBRztZQUNuQyxPQUFPL0QsU0FBU3dtQixpQkFBaUIsQ0FBQzdrQixJQUFJTCxFQUFFLEVBQUV5QztRQUM1QztRQUVBcEMsSUFBSWdsQix5QkFBeUIsR0FBR2pyQixlQUFlc0UsU0FBU3VMLFFBQVEsR0FBR29iLHlCQUF5QixFQUFFO1lBQzVGM21CLFVBQVVBO1lBQ1YyQixLQUFLQTtRQUNQO0lBQ0Y7SUFFQSxTQUFTc25CLGlCQUFpQnRuQixHQUFHLEVBQUU4bEIsY0FBYyxFQUFFbGIsVUFBVTtRQUN2RCxJQUFJa2IsY0FBYyxDQUFDOWxCLElBQUlMLEVBQUUsQ0FBQyxFQUFFO1lBQzFCLE9BQU87UUFDVDtRQUVBLElBQUlnRSxVQUFVaUgsV0FBVzVLO1FBRXpCLElBQUkyRCxXQUFXQSxRQUFROU0sTUFBTSxFQUFFO1lBQzdCLElBQUkyd0Isc0JBQXNCO1lBQzFCLElBQUlDLGVBQWU7WUFDbkI5akIsUUFBUWpKLE9BQU8sQ0FBQyxTQUFVc2YsTUFBTTtnQkFDOUIsMENBQTBDO2dCQUMxQyxJQUFJeU4sZ0JBQWdCLENBQUNELHFCQUFxQjtvQkFDeEM7Z0JBQ0Y7Z0JBRUEsSUFBSUYsaUJBQWlCdE4sUUFBUThMLGdCQUFnQmxiLGFBQWE7b0JBQ3hENmMsZUFBZTtnQkFDakIsT0FBTztvQkFDTEQsc0JBQXNCO2dCQUN4QjtZQUNGO1lBQ0EsT0FBT0Esc0JBQXNCLE9BQU9DLGVBQWUsT0FBTztRQUM1RDtRQUVBLE9BQU87SUFDVDtJQUVBLElBQUlDLGlDQUFpQyxTQUFTQSwrQkFBK0IxbkIsR0FBRztRQUM5RSxPQUFPLENBQUM7SUFDVjtJQUVBLElBQUkybkIsa0NBQWtDLFNBQVNBLGdDQUFnQ3poQixJQUFJO1FBQ2pGLE9BQU8sQ0FBQztJQUNWLEdBQUcsVUFBVTtJQUdibE8sUUFBUTR2QixXQUFXLEdBQUc7SUFDdEI1dkIsUUFBUTZ2QixZQUFZLEdBQUc7SUFDdkI3dkIsUUFBUTh2QixhQUFhLEdBQUc7SUFDeEIsSUFBSUMsY0FBYyxTQUFTQSxZQUFZL3RCLEtBQUs7UUFDMUNBLE1BQU1xTSxhQUFhLENBQUM1RSxJQUFJLENBQUN1bUI7UUFDekJodUIsTUFBTWlOLFdBQVcsQ0FBQ3hGLElBQUksQ0FBQ3dtQjtRQUN2Qmp1QixNQUFNa04sVUFBVSxDQUFDekYsSUFBSSxDQUFDeW1CO0lBQ3hCO0lBQ0FILFlBQVlodEIsVUFBVSxHQUFHO0lBRXpCLFNBQVNpdEIsVUFBVTFmLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUk4cEIsd0JBQXdCOXBCLFNBQVMrcEIsdUJBQXVCLEVBQ3hEQSwwQkFBMEJELDBCQUEwQixLQUFLLElBQUlULGlDQUFpQ1MsdUJBQzlGRSx3QkFBd0JocUIsU0FBU2lxQix3QkFBd0IsRUFDekRBLDJCQUEyQkQsMEJBQTBCLEtBQUssSUFBSVYsa0NBQWtDVSx1QkFDaEdwYyxXQUFXNU4sU0FBUzROLFFBQVE7UUFFaEMsSUFBSWxELE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRQyxJQUFJLEVBQUU7WUFDaEMsT0FBT3hCLFNBQVM7Z0JBQ2Q4eEIsVUFBVSxDQUFDO1lBQ2IsR0FBR2pnQjtRQUNMO1FBRUEsSUFBSVMsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVE4dkIsYUFBYSxFQUFFO1lBQ3pDLE9BQU9yeEIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmlnQixVQUFVbHFCLFNBQVM0SyxZQUFZLENBQUNzZixRQUFRLElBQUksQ0FBQztZQUMvQztRQUNGO1FBRUEsSUFBSXhmLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRNHZCLFdBQVcsRUFBRTtZQUN2QyxJQUFJL1g7WUFFSixJQUFJSixRQUFRMUcsT0FBTzBHLEtBQUssRUFDcEI1WixRQUFRa1QsT0FBT2xULEtBQUs7WUFDeEIsSUFBSTJ5QixjQUFjLE9BQU9sZ0IsTUFBTWlnQixRQUFRLENBQUM5WSxNQUFNLEtBQUssY0FBY25ILE1BQU1pZ0IsUUFBUSxDQUFDOVksTUFBTSxHQUFHMlksd0JBQXdCbmMsUUFBUSxDQUFDd0QsTUFBTTtZQUNoSSxPQUFPaFosU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmlnQixVQUFVOXhCLFNBQVMsQ0FBQyxHQUFHNlIsTUFBTWlnQixRQUFRLEVBQUcxWSxDQUFBQSxZQUFZLENBQUMsR0FBR0EsU0FBUyxDQUFDSixNQUFNLEdBQUduVSxpQkFBaUJ6RixPQUFPMnlCLGNBQWMzWSxTQUFRO1lBQzNIO1FBQ0Y7UUFFQSxJQUFJOUcsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVE2dkIsWUFBWSxFQUFFO1lBQ3hDLElBQUlZLHVCQUF1QkMsa0JBQWtCQyx1QkFBdUJDLFdBQVdDO1lBRS9FLElBQUlDLFNBQVMvZixPQUFPMEcsS0FBSyxFQUNyQnRHLFdBQVdKLE9BQU9JLFFBQVEsRUFDMUI0ZixTQUFTaGdCLE9BQU9sVCxLQUFLO1lBRXpCLElBQUltekIsZUFBZSxPQUFPMWdCLE1BQU1pZ0IsUUFBUSxDQUFDTyxPQUFPLEtBQUssY0FBY3hnQixNQUFNaWdCLFFBQVEsQ0FBQ08sT0FBTyxHQUFHVix3QkFBd0JuYyxRQUFRLENBQUM2YyxPQUFPO1lBRXBJLElBQUlHLGVBQWUsT0FBUUQsQ0FBQUEsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJLENBQUNQLHdCQUF3Qk8sYUFBYUUsU0FBUyxLQUFLLE9BQU8sS0FBSyxJQUFJVCxxQkFBcUIsQ0FBQ3RmLFNBQVMsTUFBTSxjQUFjNmYsYUFBYUUsU0FBUyxDQUFDL2YsU0FBUyxHQUFHbWYseUJBQXlCLENBQUNJLG1CQUFtQnpjLFFBQVEsQ0FBQzZjLE9BQU8sS0FBSyxPQUFPLEtBQUssSUFBSSxDQUFDSCx3QkFBd0JELGlCQUFpQnJiLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSXNiLHNCQUFzQnBjLElBQUksQ0FBQyxTQUFVckcsSUFBSTtnQkFDbFosT0FBT0EsS0FBSzVILE1BQU0sQ0FBQ3FCLEVBQUUsS0FBS3dKO1lBQzVCO1lBQ0EsT0FBTzFTLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJpZ0IsVUFBVTl4QixTQUFTLENBQUMsR0FBRzZSLE1BQU1pZ0IsUUFBUSxFQUFHTSxDQUFBQSxZQUFZLENBQUMsR0FBR0EsU0FBUyxDQUFDQyxPQUFPLEdBQUdyeUIsU0FBUyxDQUFDLEdBQUd1eUIsY0FBYztvQkFDckdFLFdBQVd6eUIsU0FBUyxDQUFDLEdBQUd1eUIsYUFBYUUsU0FBUyxJQUFJLENBQUMsR0FBSU4sQ0FBQUEsWUFBWSxDQUFDLEdBQUdBLFNBQVMsQ0FBQ3pmLFNBQVMsR0FBRzdOLGlCQUFpQnl0QixRQUFRRSxlQUFlTCxTQUFRO2dCQUMvSSxJQUFJQyxTQUFRO1lBQ2Q7UUFDRjtJQUNGO0lBRUEsU0FBU1osY0FBYzVwQixRQUFRO1FBQzdCLElBQUk4cUIsd0JBQXdCOXFCLFNBQVMrcUIsaUJBQWlCLEVBQ2xEQSxvQkFBb0JELDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQzlEN2QsT0FBT2pOLFNBQVNpTixJQUFJLEVBQ3BCM0IsV0FBV3RMLFNBQVNzTCxRQUFRO1FBQ2hDLElBQUlpZSxjQUFjN3lCLE1BQU0rRyxXQUFXLENBQUMsU0FBVTJULEtBQUssRUFBRTVaLEtBQUs7WUFDeEQsT0FBTzhULFNBQVM7Z0JBQ2RwTCxNQUFNdkcsUUFBUTR2QixXQUFXO2dCQUN6Qm5ZLE9BQU9BO2dCQUNQNVosT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJa2UsZUFBZTl5QixNQUFNK0csV0FBVyxDQUFDLFNBQVUyVCxLQUFLLEVBQUV0RyxRQUFRLEVBQUV0VCxLQUFLO1lBQ25FLE9BQU84VCxTQUFTO2dCQUNkcEwsTUFBTXZHLFFBQVE2dkIsWUFBWTtnQkFDMUJwWSxPQUFPQTtnQkFDUHRHLFVBQVVBO2dCQUNWdFQsT0FBT0E7WUFDVDtRQUNGLEdBQUc7WUFBQzhUO1NBQVM7UUFDYixJQUFJMGYsdUJBQXVCNXRCLGFBQWEydEI7UUFDeENqdEIsdUJBQXVCO1lBQ3JCLElBQUlrdEIsd0JBQXdCO2dCQUMxQjFmLFNBQVM7b0JBQ1BwTCxNQUFNdkcsUUFBUTh2QixhQUFhO2dCQUM3QjtZQUNGO1FBQ0YsR0FBRztZQUFDeGM7U0FBSztRQUNUdFcsT0FBTzBCLE1BQU0sQ0FBQzJILFVBQVU7WUFDdEJ1cEIsYUFBYUE7WUFDYkMsY0FBY0E7UUFDaEI7SUFDRjtJQUVBLFNBQVNLLGFBQWFsb0IsR0FBRyxFQUFFN0gsSUFBSTtRQUM3QixJQUFJa0csV0FBV2xHLEtBQUtrRyxRQUFRO1FBQzVCLElBQUlpckIseUJBQXlCanJCLFNBQVMrcEIsdUJBQXVCLEVBQ3pEQSwwQkFBMEJrQiwyQkFBMkIsS0FBSyxJQUFJNUIsaUNBQWlDNEIsd0JBQy9GQyx5QkFBeUJsckIsU0FBU2lxQix3QkFBd0IsRUFDMURBLDJCQUEyQmlCLDJCQUEyQixLQUFLLElBQUk1QixrQ0FBa0M0Qix3QkFDakdoQixXQUFXbHFCLFNBQVNpSyxLQUFLLENBQUNpZ0IsUUFBUTtRQUV0QyxJQUFJdm9CLEtBQUs7WUFDUEEsSUFBSXNJLEtBQUssR0FBRyxPQUFPaWdCLFFBQVEsQ0FBQ3ZvQixJQUFJTCxFQUFFLENBQUMsS0FBSyxjQUFjNG9CLFFBQVEsQ0FBQ3ZvQixJQUFJTCxFQUFFLENBQUMsR0FBR3lvQix3QkFBd0Jwb0I7WUFFakdBLElBQUl3cEIsUUFBUSxHQUFHLFNBQVVqdUIsT0FBTztnQkFDOUIsT0FBTzhDLFNBQVN1cEIsV0FBVyxDQUFDNW5CLElBQUlMLEVBQUUsRUFBRXBFO1lBQ3RDO1lBRUF5RSxJQUFJcU4sS0FBSyxDQUFDM1MsT0FBTyxDQUFDLFNBQVV3TCxJQUFJO2dCQUM5QixJQUFJLENBQUNsRyxJQUFJc0ksS0FBSyxDQUFDNGdCLFNBQVMsRUFBRTtvQkFDeEJscEIsSUFBSXNJLEtBQUssQ0FBQzRnQixTQUFTLEdBQUcsQ0FBQztnQkFDekI7Z0JBRUFoakIsS0FBS29DLEtBQUssR0FBRyxPQUFPdEksSUFBSXNJLEtBQUssQ0FBQzRnQixTQUFTLENBQUNoakIsS0FBSzVILE1BQU0sQ0FBQ3FCLEVBQUUsQ0FBQyxLQUFLLGNBQWNLLElBQUlzSSxLQUFLLENBQUM0Z0IsU0FBUyxDQUFDaGpCLEtBQUs1SCxNQUFNLENBQUNxQixFQUFFLENBQUMsR0FBRzJvQix5QkFBeUJwaUI7Z0JBRXpJQSxLQUFLc2pCLFFBQVEsR0FBRyxTQUFVanVCLE9BQU87b0JBQy9CLE9BQU84QyxTQUFTd3BCLFlBQVksQ0FBQzduQixJQUFJTCxFQUFFLEVBQUV1RyxLQUFLNUgsTUFBTSxDQUFDcUIsRUFBRSxFQUFFcEU7Z0JBQ3ZEO1lBQ0Y7UUFDRjtJQUNGO0lBRUF2RCxRQUFReXhCLGdCQUFnQixHQUFHO0lBQzNCenhCLFFBQVEweEIsY0FBYyxHQUFHO0lBQ3pCLElBQUlDLGlCQUFpQixTQUFTQSxlQUFlM3ZCLEtBQUs7UUFDaERBLE1BQU1xTSxhQUFhLENBQUM1RSxJQUFJLENBQUNtb0I7UUFDekI1dkIsTUFBTThNLGtCQUFrQixDQUFDckYsSUFBSSxDQUFDLFNBQVVyRixJQUFJLEVBQUVqRSxJQUFJO1lBQ2hELElBQUlrRyxXQUFXbEcsS0FBS2tHLFFBQVE7WUFDNUIsT0FBTyxFQUFFLENBQUN2RSxNQUFNLENBQUNzQyxNQUFNO2dCQUFDaUMsU0FBU2lLLEtBQUssQ0FBQ3VoQixXQUFXO2FBQUM7UUFDckQ7UUFDQTd2QixNQUFNNk0sY0FBYyxDQUFDcEYsSUFBSSxDQUFDcW9CO1FBQzFCOXZCLE1BQU1pTixXQUFXLENBQUN4RixJQUFJLENBQUNzb0I7SUFDekI7SUFDQUosZUFBZTV1QixVQUFVLEdBQUc7SUFFNUIsU0FBUzZ1QixVQUFVdGhCLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkb3pCLGFBQWEsRUFBRTtZQUNqQixHQUFHdmhCO1FBQ0w7UUFFQSxJQUFJUyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXl4QixnQkFBZ0IsRUFBRTtZQUM1QyxPQUFPaHpCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJ1aEIsYUFBYXhyQixTQUFTNEssWUFBWSxDQUFDNGdCLFdBQVcsSUFBSSxFQUFFO1lBQ3REO1FBQ0Y7UUFFQSxJQUFJOWdCLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRMHhCLGNBQWMsRUFBRTtZQUMxQyxPQUFPanpCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJ1aEIsYUFBYXZ1QixpQkFBaUJ5TixPQUFPOGdCLFdBQVcsRUFBRXZoQixNQUFNdWhCLFdBQVc7WUFDckU7UUFDRjtJQUNGO0lBRUEsU0FBU0MsaUJBQWlCMXFCLE9BQU8sRUFBRXhDLEtBQUs7UUFDdEMsSUFBSWl0QixjQUFjanRCLE1BQU15QixRQUFRLENBQUNpSyxLQUFLLENBQUN1aEIsV0FBVztRQUVsRCxrREFBa0Q7UUFDbEQsSUFBSSxDQUFDQSxlQUFlLENBQUNBLFlBQVloekIsTUFBTSxFQUFFO1lBQ3ZDLE9BQU91STtRQUNUO1FBRUEsSUFBSTRxQixrQkFBa0IsRUFBRSxDQUFDbHdCLE1BQU0sQ0FBQyt2QixjQUFjLG1EQUFtRDtRQUVqRyxJQUFJSSxjQUFjLEVBQUUsQ0FBQ253QixNQUFNLENBQUNzRixVQUFVLDhDQUE4QztRQUVwRixJQUFJOHFCLGlCQUFpQixFQUFFLEVBQUUsbUVBQW1FO1FBRTVGLElBQUlycEIsUUFBUSxTQUFTQTtZQUNuQixJQUFJc3BCLGlCQUFpQkgsZ0JBQWdCN2QsS0FBSztZQUMxQyxJQUFJaWUsYUFBYUgsWUFBWS91QixTQUFTLENBQUMsU0FBVWlHLENBQUM7Z0JBQ2hELE9BQU9BLEVBQUV4QixFQUFFLEtBQUt3cUI7WUFDbEI7WUFFQSxJQUFJQyxhQUFhLENBQUMsR0FBRztnQkFDbkJGLGVBQWV6b0IsSUFBSSxDQUFDd29CLFlBQVkzTCxNQUFNLENBQUM4TCxZQUFZLEVBQUUsQ0FBQyxFQUFFO1lBQzFEO1FBQ0Y7UUFFQSxNQUFPSCxZQUFZcHpCLE1BQU0sSUFBSW16QixnQkFBZ0JuekIsTUFBTSxDQUFFO1lBQ25EZ0s7UUFDRixFQUFFLHFEQUFxRDtRQUd2RCxPQUFPLEVBQUUsQ0FBQy9HLE1BQU0sQ0FBQ293QixnQkFBZ0JEO0lBQ25DO0lBRUEsU0FBU0YsY0FBYzFyQixRQUFRO1FBQzdCLElBQUlzTCxXQUFXdEwsU0FBU3NMLFFBQVE7UUFDaEN0TCxTQUFTcXJCLGNBQWMsR0FBRzMwQixNQUFNK0csV0FBVyxDQUFDLFNBQVUrdEIsV0FBVztZQUMvRCxPQUFPbGdCLFNBQVM7Z0JBQ2RwTCxNQUFNdkcsUUFBUTB4QixjQUFjO2dCQUM1QkcsYUFBYUE7WUFDZjtRQUNGLEdBQUc7WUFBQ2xnQjtTQUFTO0lBQ2Y7SUFFQW5SLGNBQWM4VixTQUFTLEdBQUcsTUFBTSxVQUFVO0lBRTFDdFcsUUFBUXF5QixtQkFBbUIsR0FBRztJQUM5QnJ5QixRQUFRc3lCLGNBQWMsR0FBRztJQUN6QnR5QixRQUFRdXlCLGtCQUFrQixHQUFHO0lBQzdCdnlCLFFBQVF3eUIsV0FBVyxHQUFHO0lBQ3RCLElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJ6d0IsS0FBSztRQUNwREEsTUFBTTB3QixlQUFlLEdBQUc7WUFBQ0M7U0FBdUI7UUFDaEQzd0IsTUFBTXVOLGNBQWMsQ0FBQzlGLElBQUksQ0FBQztZQUN4Qm5JLE9BQU87Z0JBQ0xzeEIsVUFBVTtZQUNaO1FBQ0Y7UUFDQTV3QixNQUFNcU0sYUFBYSxDQUFDNUUsSUFBSSxDQUFDb3BCO1FBQ3pCN3dCLE1BQU1pTixXQUFXLENBQUN4RixJQUFJLENBQUNxcEI7UUFDdkI5d0IsTUFBTWdOLDJCQUEyQixDQUFDdkYsSUFBSSxDQUFDc3BCO0lBQ3pDO0lBRUEsSUFBSUoseUJBQXlCLFNBQVNBLHVCQUF1QnZ4QixLQUFLLEVBQUVqQixJQUFJO1FBQ3RFLElBQUlrRyxXQUFXbEcsS0FBS2tHLFFBQVEsRUFDeEJzUCxTQUFTeFYsS0FBS3dWLE1BQU07UUFDeEIsSUFBSWhFLFdBQVd0TCxTQUFTc0wsUUFBUTtRQUVoQyxJQUFJcWhCLGdCQUFnQixTQUFTQSxjQUFjeG9CLENBQUMsRUFBRW1MLE1BQU07WUFDbEQsSUFBSXNkLGVBQWU7WUFFbkIsSUFBSXpvQixFQUFFakUsSUFBSSxLQUFLLGNBQWM7Z0JBQzNCLDZEQUE2RDtnQkFDN0QsSUFBSWlFLEVBQUUwb0IsT0FBTyxJQUFJMW9CLEVBQUUwb0IsT0FBTyxDQUFDcjBCLE1BQU0sR0FBRyxHQUFHO29CQUNyQztnQkFDRjtnQkFFQW8wQixlQUFlO1lBQ2pCO1lBRUEsSUFBSUUsa0JBQWtCQyxlQUFlemQ7WUFDckMsSUFBSTBkLGlCQUFpQkYsZ0JBQWdCNXJCLEdBQUcsQ0FBQyxTQUFVNEIsQ0FBQztnQkFDbEQsT0FBTztvQkFBQ0EsRUFBRXhCLEVBQUU7b0JBQUV3QixFQUFFNk0sVUFBVTtpQkFBQztZQUM3QjtZQUNBLElBQUlzZCxVQUFVTCxlQUFlOWMsS0FBS29kLEtBQUssQ0FBQy9vQixFQUFFMG9CLE9BQU8sQ0FBQyxFQUFFLENBQUNJLE9BQU8sSUFBSTlvQixFQUFFOG9CLE9BQU87WUFDekUsSUFBSUU7WUFDSixJQUFJQztZQUVKLElBQUlDLGNBQWMsU0FBU0E7Z0JBQ3pCam5CLE9BQU9rbkIsb0JBQW9CLENBQUNIO2dCQUM1QkEsTUFBTTtnQkFDTjdoQixTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVF1eUIsa0JBQWtCO2dCQUNsQztZQUNGO1lBRUEsSUFBSXFCLGVBQWUsU0FBU0E7Z0JBQzFCbm5CLE9BQU9rbkIsb0JBQW9CLENBQUNIO2dCQUM1QkEsTUFBTTtnQkFDTjdoQixTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVFzeUIsY0FBYztvQkFDNUJnQixTQUFTRztnQkFDWDtZQUNGO1lBRUEsSUFBSUksMkNBQTJDLFNBQVNBLHlDQUF5Q0MsVUFBVTtnQkFDekdMLG9CQUFvQks7Z0JBRXBCLElBQUksQ0FBQ04sS0FBSztvQkFDUkEsTUFBTS9tQixPQUFPc25CLHFCQUFxQixDQUFDSDtnQkFDckM7WUFDRjtZQUVBLElBQUlJLG9CQUFvQjtnQkFDdEJDLE9BQU87b0JBQ0xDLFdBQVc7b0JBQ1hDLGFBQWEsU0FBU0EsWUFBWTNwQixDQUFDO3dCQUNqQyxPQUFPcXBCLHlDQUF5Q3JwQixFQUFFOG9CLE9BQU87b0JBQzNEO29CQUNBYyxTQUFTO29CQUNUQyxXQUFXLFNBQVNBLFVBQVU3cEIsQ0FBQzt3QkFDN0J4RyxTQUFTMkksbUJBQW1CLENBQUMsYUFBYXFuQixrQkFBa0JDLEtBQUssQ0FBQ0UsV0FBVzt3QkFDN0Vud0IsU0FBUzJJLG1CQUFtQixDQUFDLFdBQVdxbkIsa0JBQWtCQyxLQUFLLENBQUNJLFNBQVM7d0JBQ3pFWDtvQkFDRjtnQkFDRjtnQkFDQVksT0FBTztvQkFDTEosV0FBVztvQkFDWEMsYUFBYSxTQUFTQSxZQUFZM3BCLENBQUM7d0JBQ2pDLElBQUlBLEVBQUUrcEIsVUFBVSxFQUFFOzRCQUNoQi9wQixFQUFFZ3FCLGNBQWM7NEJBQ2hCaHFCLEVBQUVpcUIsZUFBZTt3QkFDbkI7d0JBRUFaLHlDQUF5Q3JwQixFQUFFMG9CLE9BQU8sQ0FBQyxFQUFFLENBQUNJLE9BQU87d0JBQzdELE9BQU87b0JBQ1Q7b0JBQ0FjLFNBQVM7b0JBQ1RDLFdBQVcsU0FBU0EsVUFBVTdwQixDQUFDO3dCQUM3QnhHLFNBQVMySSxtQkFBbUIsQ0FBQ3FuQixrQkFBa0JNLEtBQUssQ0FBQ0osU0FBUyxFQUFFRixrQkFBa0JNLEtBQUssQ0FBQ0gsV0FBVzt3QkFDbkdud0IsU0FBUzJJLG1CQUFtQixDQUFDcW5CLGtCQUFrQk0sS0FBSyxDQUFDRixPQUFPLEVBQUVKLGtCQUFrQk0sS0FBSyxDQUFDSCxXQUFXO3dCQUNqR1Q7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlnQixTQUFTekIsZUFBZWUsa0JBQWtCTSxLQUFLLEdBQUdOLGtCQUFrQkMsS0FBSztZQUM3RSxJQUFJVSxxQkFBcUJ0b0IsMEJBQTBCO2dCQUNqREcsU0FBUztZQUNYLElBQUk7WUFDSnhJLFNBQVMwSSxnQkFBZ0IsQ0FBQ2dvQixPQUFPUixTQUFTLEVBQUVRLE9BQU9QLFdBQVcsRUFBRVE7WUFDaEUzd0IsU0FBUzBJLGdCQUFnQixDQUFDZ29CLE9BQU9OLE9BQU8sRUFBRU0sT0FBT0wsU0FBUyxFQUFFTTtZQUM1RGhqQixTQUFTO2dCQUNQcEwsTUFBTXZHLFFBQVFxeUIsbUJBQW1CO2dCQUNqQ2xoQixVQUFVd0UsT0FBT2hPLEVBQUU7Z0JBQ25CaXRCLGFBQWFqZixPQUFPSyxVQUFVO2dCQUM5QnFkLGdCQUFnQkE7Z0JBQ2hCQyxTQUFTQTtZQUNYO1FBQ0Y7UUFFQSxPQUFPO1lBQUNseUI7WUFBTztnQkFDYnl6QixhQUFhLFNBQVNBLFlBQVlycUIsQ0FBQztvQkFDakMsT0FBT0EsRUFBRXlVLE9BQU8sTUFBTStULGNBQWN4b0IsR0FBR21MO2dCQUN6QztnQkFDQW1mLGNBQWMsU0FBU0EsYUFBYXRxQixDQUFDO29CQUNuQyxPQUFPQSxFQUFFeVUsT0FBTyxNQUFNK1QsY0FBY3hvQixHQUFHbUw7Z0JBQ3pDO2dCQUNBclUsT0FBTztvQkFDTGdKLFFBQVE7Z0JBQ1Y7Z0JBQ0F5cUIsV0FBVztnQkFDWDVuQixNQUFNO1lBQ1I7U0FBRTtJQUNKO0lBRUFzbEIsaUJBQWlCMXZCLFVBQVUsR0FBRztJQUU5QixTQUFTOHZCLFVBQVV2aUIsS0FBSyxFQUFFUyxNQUFNO1FBQzlCLElBQUlBLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRQyxJQUFJLEVBQUU7WUFDaEMsT0FBT3hCLFNBQVM7Z0JBQ2Q2ekIsZ0JBQWdCO29CQUNkMEMsY0FBYyxDQUFDO2dCQUNqQjtZQUNGLEdBQUcxa0I7UUFDTDtRQUVBLElBQUlTLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRd3lCLFdBQVcsRUFBRTtZQUN2QyxPQUFPL3pCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJnaUIsZ0JBQWdCO29CQUNkMEMsY0FBYyxDQUFDO2dCQUNqQjtZQUNGO1FBQ0Y7UUFFQSxJQUFJamtCLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRcXlCLG1CQUFtQixFQUFFO1lBQy9DLElBQUlpQixVQUFVdmlCLE9BQU91aUIsT0FBTyxFQUN4Qm5pQixXQUFXSixPQUFPSSxRQUFRLEVBQzFCeWpCLGNBQWM3akIsT0FBTzZqQixXQUFXLEVBQ2hDdkIsaUJBQWlCdGlCLE9BQU9zaUIsY0FBYztZQUMxQyxPQUFPNTBCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJnaUIsZ0JBQWdCN3pCLFNBQVMsQ0FBQyxHQUFHNlIsTUFBTWdpQixjQUFjLEVBQUU7b0JBQ2pEMkMsUUFBUTNCO29CQUNSRCxnQkFBZ0JBO29CQUNoQnVCLGFBQWFBO29CQUNiTSxrQkFBa0IvakI7Z0JBQ3BCO1lBQ0Y7UUFDRjtRQUVBLElBQUlKLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRc3lCLGNBQWMsRUFBRTtZQUMxQyxJQUFJNkMsV0FBV3BrQixPQUFPdWlCLE9BQU87WUFFN0IsSUFBSThCLHdCQUF3QjlrQixNQUFNZ2lCLGNBQWMsRUFDNUMyQyxTQUFTRyxzQkFBc0JILE1BQU0sRUFDckNJLGVBQWVELHNCQUFzQlIsV0FBVyxFQUNoRFUseUJBQXlCRixzQkFBc0IvQixjQUFjLEVBQzdEa0Msa0JBQWtCRCwyQkFBMkIsS0FBSyxJQUFJLEVBQUUsR0FBR0E7WUFFL0QsSUFBSUUsU0FBU0wsV0FBV0Y7WUFDeEIsSUFBSVEsbUJBQW1CRCxTQUFTSDtZQUNoQyxJQUFJSyxrQkFBa0IsQ0FBQztZQUV2QkgsZ0JBQWdCN3lCLE9BQU8sQ0FBQyxTQUFVa0MsS0FBSztnQkFDckMsSUFBSSt3QixXQUFXL3dCLEtBQUssQ0FBQyxFQUFFLEVBQ25CZ3hCLGNBQWNoeEIsS0FBSyxDQUFDLEVBQUU7Z0JBQzFCOHdCLGVBQWUsQ0FBQ0MsU0FBUyxHQUFHeGYsS0FBS0UsR0FBRyxDQUFDdWYsY0FBY0EsY0FBY0gsa0JBQWtCO1lBQ3JGO1lBRUEsT0FBT2gzQixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCZ2lCLGdCQUFnQjd6QixTQUFTLENBQUMsR0FBRzZSLE1BQU1naUIsY0FBYyxFQUFFO29CQUNqRDBDLGNBQWN2MkIsU0FBUyxDQUFDLEdBQUc2UixNQUFNZ2lCLGNBQWMsQ0FBQzBDLFlBQVksRUFBRSxDQUFDLEdBQUdVO2dCQUNwRTtZQUNGO1FBQ0Y7UUFFQSxJQUFJM2tCLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRdXlCLGtCQUFrQixFQUFFO1lBQzlDLE9BQU85ekIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmdpQixnQkFBZ0I3ekIsU0FBUyxDQUFDLEdBQUc2UixNQUFNZ2lCLGNBQWMsRUFBRTtvQkFDakQyQyxRQUFRO29CQUNSQyxrQkFBa0I7Z0JBQ3BCO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSW5DLGdDQUFnQyxTQUFTL2pCLDRCQUE0QjNJLFFBQVE7UUFDL0UsSUFBSXFMLGNBQWNyTCxTQUFTcUwsV0FBVyxFQUNsQ21rQixrQkFBa0J4dkIsU0FBU3d2QixlQUFlLEVBQzFDamtCLFdBQVd2TCxTQUFTdUwsUUFBUSxFQUM1QjBnQixpQkFBaUJqc0IsU0FBU2lLLEtBQUssQ0FBQ2dpQixjQUFjO1FBQ2xELElBQUl2Z0IsY0FBY3RPLGFBQWE0QztRQUMvQnFMLFlBQVloUCxPQUFPLENBQUMsU0FBVWlULE1BQU07WUFDbEMsSUFBSVcsWUFBWTdMLGdCQUFnQmtMLE9BQU9rZ0IsZUFBZSxLQUFLLE9BQU8sUUFBUXIzQixXQUFXcTNCLG9CQUFvQixPQUFPLFFBQVFyM0IsV0FBVztZQUNuSW1YLE9BQU9XLFNBQVMsR0FBR0E7WUFDbkJYLE9BQU9qVixLQUFLLEdBQUc0eEIsZUFBZTBDLFlBQVksQ0FBQ3JmLE9BQU9oTyxFQUFFLENBQUMsSUFBSWdPLE9BQU90TixhQUFhLElBQUlzTixPQUFPalYsS0FBSztZQUM3RmlWLE9BQU9tZ0IsVUFBVSxHQUFHeEQsZUFBZTRDLGdCQUFnQixLQUFLdmYsT0FBT2hPLEVBQUU7WUFFakUsSUFBSTJPLFdBQVc7Z0JBQ2JYLE9BQU8rYyxlQUFlLEdBQUczd0IsZUFBZTZQLFdBQVc4Z0IsZUFBZSxFQUFFO29CQUNsRXJzQixVQUFVMEw7b0JBQ1Y0RCxRQUFRQTtnQkFDVjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVNtZCxjQUFjenNCLFFBQVE7UUFDN0IsSUFBSXhELFVBQVV3RCxTQUFTeEQsT0FBTyxFQUMxQjhPLFdBQVd0TCxTQUFTc0wsUUFBUSxFQUM1Qm9rQix3QkFBd0IxdkIsU0FBUzJ2QixlQUFlLEVBQ2hEQSxrQkFBa0JELDBCQUEwQixLQUFLLElBQUksT0FBT0EsdUJBQzVEM3VCLFVBQVVmLFNBQVNlLE9BQU87UUFDOUJ4RSxrQkFBa0JDLFNBQVM7WUFBQztTQUFvQixFQUFFO1FBQ2xELElBQUlvekIscUJBQXFCeHlCLGFBQWF1eUI7UUFDdEM3eEIsdUJBQXVCO1lBQ3JCLElBQUk4eEIsc0JBQXNCO2dCQUN4QnRrQixTQUFTO29CQUNQcEwsTUFBTXZHLFFBQVF3eUIsV0FBVztnQkFDM0I7WUFDRjtRQUNGLEdBQUc7WUFBQ3ByQjtTQUFRO1FBQ1osSUFBSTh1QixnQkFBZ0JuNUIsTUFBTStHLFdBQVcsQ0FBQztZQUNwQyxPQUFPNk4sU0FBUztnQkFDZHBMLE1BQU12RyxRQUFRd3lCLFdBQVc7WUFDM0I7UUFDRixHQUFHO1lBQUM3Z0I7U0FBUztRQUNiM1UsT0FBTzBCLE1BQU0sQ0FBQzJILFVBQVU7WUFDdEI2dkIsZUFBZUE7UUFDakI7SUFDRjtJQUVBLFNBQVM5QyxlQUFlemQsTUFBTTtRQUM1QixJQUFJd2dCLGNBQWMsRUFBRTtRQUVwQixJQUFJQyxnQkFBZ0IsU0FBU0EsY0FBY3pnQixNQUFNO1lBQy9DLElBQUlBLE9BQU92TyxPQUFPLElBQUl1TyxPQUFPdk8sT0FBTyxDQUFDdkksTUFBTSxFQUFFO2dCQUMzQzhXLE9BQU92TyxPQUFPLENBQUNHLEdBQUcsQ0FBQzZ1QjtZQUNyQjtZQUVBRCxZQUFZMXNCLElBQUksQ0FBQ2tNO1FBQ25CO1FBRUF5Z0IsY0FBY3pnQjtRQUNkLE9BQU93Z0I7SUFDVDtJQUVBLElBQUlFLGFBQWE7UUFDZnpELFVBQVU7UUFDVjBELEtBQUs7SUFDUDtJQUNBLElBQUlDLG9CQUFvQixTQUFTQSxrQkFBa0J2MEIsS0FBSztRQUN0REEsTUFBTW9OLGlCQUFpQixDQUFDM0YsSUFBSSxDQUFDK3NCO1FBQzdCeDBCLE1BQU15TixXQUFXLENBQUNoRyxJQUFJLENBQUMrc0I7UUFDdkJ4MEIsTUFBTXFOLG1CQUFtQixDQUFDNUYsSUFBSSxDQUFDK3NCO1FBQy9CeDBCLE1BQU1zTixtQkFBbUIsQ0FBQzdGLElBQUksQ0FBQytzQjtRQUMvQngwQixNQUFNdU4sY0FBYyxDQUFDOUYsSUFBSSxDQUFDLFNBQVVySSxLQUFLLEVBQUVqQixJQUFJO1lBQzdDLElBQUltRyxTQUFTbkcsS0FBS21HLE1BQU07WUFDeEIsT0FBTztnQkFBQ2xGO2dCQUFPO29CQUNiRSxPQUFPN0MsU0FBUyxDQUFDLEdBQUc0M0IsWUFBWTt3QkFDOUIvZ0IsTUFBTWhQLE9BQU91UCxTQUFTLEdBQUc7d0JBQ3pCblYsT0FBTzRGLE9BQU8wUCxVQUFVLEdBQUc7b0JBQzdCO2dCQUNGO2FBQUU7UUFDSjtRQUNBaFUsTUFBTTBOLFlBQVksQ0FBQ2pHLElBQUksQ0FBQyxTQUFVckksS0FBSyxFQUFFd0QsS0FBSztZQUM1QyxJQUFJc0osT0FBT3RKLE1BQU1zSixJQUFJO1lBQ3JCLE9BQU87Z0JBQUM5TTtnQkFBTztvQkFDYkUsT0FBTzdDLFNBQVMsQ0FBQyxHQUFHNDNCLFlBQVk7d0JBQzlCL2dCLE1BQU1wSCxLQUFLNUgsTUFBTSxDQUFDdVAsU0FBUyxHQUFHO3dCQUM5Qm5WLE9BQU93TixLQUFLNUgsTUFBTSxDQUFDMFAsVUFBVSxHQUFHO29CQUNsQztnQkFDRjthQUFFO1FBQ0o7UUFDQWhVLE1BQU13TixjQUFjLENBQUMvRixJQUFJLENBQUMsU0FBVXJJLEtBQUssRUFBRXNNLEtBQUs7WUFDOUMsSUFBSXBILFNBQVNvSCxNQUFNcEgsTUFBTTtZQUN6QixPQUFPO2dCQUFDbEY7Z0JBQU87b0JBQ2JFLE9BQU83QyxTQUFTLENBQUMsR0FBRzQzQixZQUFZO3dCQUM5Qi9nQixNQUFNaFAsT0FBT3VQLFNBQVMsR0FBRzt3QkFDekJuVixPQUFPNEYsT0FBTzBQLFVBQVUsR0FBRztvQkFDN0I7Z0JBQ0Y7YUFBRTtRQUNKO0lBQ0Y7SUFDQXVnQixrQkFBa0J4ekIsVUFBVSxHQUFHO0lBRS9CLElBQUl5ekIsZUFBZSxTQUFTQSxhQUFhcDFCLEtBQUssRUFBRXlNLEtBQUs7UUFDbkQsSUFBSXhILFdBQVd3SCxNQUFNeEgsUUFBUTtRQUM3QixPQUFPO1lBQUNqRjtZQUFPO2dCQUNiRSxPQUFPO29CQUNMc3hCLFVBQVU7b0JBQ1ZseUIsT0FBTzJGLFNBQVMwTyxpQkFBaUIsR0FBRztnQkFDdEM7WUFDRjtTQUFFO0lBQ0o7SUFFQSxJQUFJMGhCLGVBQWU7UUFDakJDLFNBQVM7UUFDVEMsV0FBVztJQUNiO0lBRUEsSUFBSUMsaUJBQWlCLFNBQVNKLGFBQWFwMUIsS0FBSyxFQUFFakIsSUFBSTtRQUNwRCxJQUFJa0csV0FBV2xHLEtBQUtrRyxRQUFRO1FBQzVCLE9BQU87WUFBQ2pGO1lBQU87Z0JBQ2JFLE9BQU87b0JBQ0xvMUIsU0FBUztvQkFDVGgyQixPQUFPMkYsU0FBUzBPLGlCQUFpQixHQUFHO2dCQUN0QztZQUNGO1NBQUU7SUFDSjtJQUVBLElBQUk4aEIsaUJBQWlCLFNBQVNBLGVBQWU3MEIsS0FBSztRQUNoREEsTUFBTXlOLFdBQVcsQ0FBQ2hHLElBQUksQ0FBQ210QjtRQUN2QjUwQixNQUFNcU4sbUJBQW1CLENBQUM1RixJQUFJLENBQUNtdEI7UUFDL0I1MEIsTUFBTXNOLG1CQUFtQixDQUFDN0YsSUFBSSxDQUFDbXRCO1FBQy9CNTBCLE1BQU11TixjQUFjLENBQUM5RixJQUFJLENBQUMsU0FBVXJJLEtBQUssRUFBRXdELEtBQUs7WUFDOUMsSUFBSTBCLFNBQVMxQixNQUFNMEIsTUFBTTtZQUN6QixPQUFPO2dCQUFDbEY7Z0JBQU87b0JBQ2JFLE9BQU83QyxTQUFTLENBQUMsR0FBR2c0QixjQUFjO3dCQUNoQy8xQixPQUFPNEYsT0FBTzBQLFVBQVUsR0FBRztvQkFDN0I7Z0JBQ0Y7YUFBRTtRQUNKO1FBQ0FoVSxNQUFNME4sWUFBWSxDQUFDakcsSUFBSSxDQUFDLFNBQVVySSxLQUFLLEVBQUVzTSxLQUFLO1lBQzVDLElBQUlRLE9BQU9SLE1BQU1RLElBQUk7WUFDckIsT0FBTztnQkFBQzlNO2dCQUFPO29CQUNiRSxPQUFPN0MsU0FBUyxDQUFDLEdBQUdnNEIsY0FBYzt3QkFDaEMvMUIsT0FBT3dOLEtBQUs1SCxNQUFNLENBQUMwUCxVQUFVLEdBQUc7b0JBQ2xDO2dCQUNGO2FBQUU7UUFDSjtRQUNBaFUsTUFBTXdOLGNBQWMsQ0FBQy9GLElBQUksQ0FBQyxTQUFVckksS0FBSyxFQUFFeU0sS0FBSztZQUM5QyxJQUFJdkgsU0FBU3VILE1BQU12SCxNQUFNO1lBQ3pCLE9BQU87Z0JBQUNsRjtnQkFBTztvQkFDYkUsT0FBTzdDLFNBQVMsQ0FBQyxHQUFHZzRCLGNBQWM7d0JBQ2hDLzFCLE9BQU80RixPQUFPMFAsVUFBVSxHQUFHO29CQUM3QjtnQkFDRjthQUFFO1FBQ0o7SUFDRjtJQUNBNmdCLGVBQWU5ekIsVUFBVSxHQUFHO0lBRTVCLFNBQVMrekIsY0FBYzkwQixLQUFLO1FBQzFCQSxNQUFNbU4sYUFBYSxDQUFDMUYsSUFBSSxDQUFDMEY7UUFDekJuTixNQUFNeU4sV0FBVyxDQUFDaEcsSUFBSSxDQUFDc3RCO1FBQ3ZCLzBCLE1BQU1xTixtQkFBbUIsQ0FBQzVGLElBQUksQ0FBQ3N0QjtRQUMvQi8wQixNQUFNc04sbUJBQW1CLENBQUM3RixJQUFJLENBQUNzdEI7UUFDL0IvMEIsTUFBTXVOLGNBQWMsQ0FBQzlGLElBQUksQ0FBQzhGO1FBQzFCdk4sTUFBTTBOLFlBQVksQ0FBQ2pHLElBQUksQ0FBQ2lHO1FBQ3hCMU4sTUFBTXdOLGNBQWMsQ0FBQy9GLElBQUksQ0FBQytGO0lBQzVCO0lBQ0FzbkIsY0FBYy96QixVQUFVLEdBQUc7SUFFM0IsSUFBSW9NLGdCQUFnQixTQUFTQSxjQUFjL04sS0FBSyxFQUFFakIsSUFBSTtRQUNwRCxJQUFJa0csV0FBV2xHLEtBQUtrRyxRQUFRO1FBQzVCLE9BQU87WUFBQ2pGO1lBQU87Z0JBQ2JFLE9BQU87b0JBQ0xYLFVBQVUwRixTQUFTeU8sb0JBQW9CLEdBQUc7Z0JBQzVDO1lBQ0Y7U0FBRTtJQUNKO0lBRUEsSUFBSWlpQixpQkFBaUIsU0FBU1AsYUFBYXAxQixLQUFLLEVBQUV3RCxLQUFLO1FBQ3JELElBQUl5QixXQUFXekIsTUFBTXlCLFFBQVE7UUFDN0IsT0FBTztZQUFDakY7WUFBTztnQkFDYkUsT0FBTztvQkFDTG8xQixTQUFTO29CQUNUTSxNQUFNO29CQUNOcjJCLFVBQVUwRixTQUFTeU8sb0JBQW9CLEdBQUc7Z0JBQzVDO1lBQ0Y7U0FBRTtJQUNKO0lBRUEsSUFBSXZGLGlCQUFpQixTQUFTQSxlQUFlbk8sS0FBSyxFQUFFc00sS0FBSztRQUN2RCxJQUFJcEgsU0FBU29ILE1BQU1wSCxNQUFNO1FBQ3pCLE9BQU87WUFBQ2xGO1lBQU87Z0JBQ2JFLE9BQU87b0JBQ0xxMUIsV0FBVztvQkFDWEssTUFBTTF3QixPQUFPNFAsY0FBYyxHQUFHNVAsT0FBTzRQLGNBQWMsR0FBRyxZQUFZMVg7b0JBQ2xFbUMsVUFBVTJGLE9BQU95UCxhQUFhLEdBQUc7b0JBQ2pDclYsT0FBTzRGLE9BQU8wUCxVQUFVLEdBQUc7Z0JBQzdCO1lBQ0Y7U0FBRTtJQUNKO0lBRUEsSUFBSXRHLGVBQWUsU0FBU0EsYUFBYXRPLEtBQUssRUFBRXlNLEtBQUs7UUFDbkQsSUFBSUssT0FBT0wsTUFBTUssSUFBSTtRQUNyQixPQUFPO1lBQUM5TTtZQUFPO2dCQUNiRSxPQUFPO29CQUNMcTFCLFdBQVc7b0JBQ1hLLE1BQU05b0IsS0FBSzVILE1BQU0sQ0FBQzRQLGNBQWMsR0FBRztvQkFDbkN2VixVQUFVdU4sS0FBSzVILE1BQU0sQ0FBQ3lQLGFBQWEsR0FBRztvQkFDdENyVixPQUFPd04sS0FBSzVILE1BQU0sQ0FBQzBQLFVBQVUsR0FBRztnQkFDbEM7WUFDRjtTQUFFO0lBQ0o7SUFFQSxJQUFJeEcsaUJBQWlCLFNBQVNBLGVBQWVwTyxLQUFLLEVBQUUyTSxLQUFLO1FBQ3ZELElBQUl6SCxTQUFTeUgsTUFBTXpILE1BQU07UUFDekIsT0FBTztZQUFDbEY7WUFBTztnQkFDYkUsT0FBTztvQkFDTHExQixXQUFXO29CQUNYSyxNQUFNMXdCLE9BQU80UCxjQUFjLEdBQUc1UCxPQUFPNFAsY0FBYyxHQUFHLFlBQVkxWDtvQkFDbEVtQyxVQUFVMkYsT0FBT3lQLGFBQWEsR0FBRztvQkFDakNyVixPQUFPNEYsT0FBTzBQLFVBQVUsR0FBRztnQkFDN0I7WUFDRjtTQUFFO0lBQ0o7SUFFQWhXLFFBQVFxeUIsbUJBQW1CLEdBQUc7SUFDOUJyeUIsUUFBUXN5QixjQUFjLEdBQUc7SUFDekJ0eUIsUUFBUXV5QixrQkFBa0IsR0FBRztJQUM3QnZ5QixRQUFRd3lCLFdBQVcsR0FBRztJQUN0QixTQUFTeUUsY0FBY2oxQixLQUFLO1FBQzFCQSxNQUFNcU0sYUFBYSxDQUFDNUUsSUFBSSxDQUFDeXRCO1FBQ3pCbDFCLE1BQU1tTixhQUFhLENBQUMxRixJQUFJLENBQUMwdEI7UUFDekJuMUIsTUFBTXVOLGNBQWMsQ0FBQzlGLElBQUksQ0FBQzJ0QjtRQUMxQnAxQixNQUFNeU4sV0FBVyxDQUFDaEcsSUFBSSxDQUFDZ0c7SUFDekI7SUFDQXduQixjQUFjbDBCLFVBQVUsR0FBRztJQUUzQixJQUFJbzBCLGtCQUFrQixTQUFTaG9CLGNBQWMvTixLQUFLLEVBQUVqQixJQUFJO1FBQ3RELElBQUlrRyxXQUFXbEcsS0FBS2tHLFFBQVE7UUFDNUIsSUFBSWd4QixzQkFBc0JoeEIsU0FBU3dJLGNBQWMsQ0FBQ3RILEdBQUcsQ0FBQyxTQUFVakIsTUFBTTtZQUNwRSxJQUFJZ3hCO1lBRUosSUFBSWp4QixTQUFTaUssS0FBSyxDQUFDaW5CLFVBQVUsQ0FBQ3ZDLFlBQVksQ0FBQzF1QixPQUFPcUIsRUFBRSxDQUFDLEVBQUUsT0FBT3RCLFNBQVNpSyxLQUFLLENBQUNpbkIsVUFBVSxDQUFDdkMsWUFBWSxDQUFDMXVCLE9BQU9xQixFQUFFLENBQUMsR0FBRyxNQUFNLHFEQUFxRDtZQUM3SywrREFBK0Q7WUFDL0QsNEVBQTRFO1lBRTVFLElBQUksQ0FBQzJ2Qix3QkFBd0JqeEIsU0FBU2lLLEtBQUssQ0FBQ2dpQixjQUFjLEtBQUssT0FBTyxLQUFLLElBQUlnRixzQkFBc0JwQyxnQkFBZ0IsRUFBRSxPQUFPN3VCLFNBQVNpSyxLQUFLLENBQUNpbkIsVUFBVSxDQUFDQyxXQUFXLENBQUNseEIsT0FBT3FCLEVBQUUsQ0FBQyxHQUFHO1lBQ2pMLElBQUksT0FBT3JCLE9BQU81RixLQUFLLEtBQUssVUFBVSxPQUFPNEYsT0FBTzVGLEtBQUssR0FBRztZQUM1RCxPQUFPNEYsT0FBTzVGLEtBQUs7UUFDckI7UUFDQSxPQUFPO1lBQUNVO1lBQU87Z0JBQ2JFLE9BQU87b0JBQ0xvMUIsU0FBUztvQkFDVFcscUJBQXFCQSxvQkFBb0JycUIsSUFBSSxDQUFDO2dCQUNoRDtZQUNGO1NBQUU7SUFDSjtJQUVBLElBQUlvcUIsbUJBQW1CLFNBQVM3bkIsZUFBZW5PLEtBQUssRUFBRXdELEtBQUs7UUFDekQsSUFBSTBCLFNBQVMxQixNQUFNMEIsTUFBTTtRQUN6QixPQUFPO1lBQUNsRjtZQUFPO2dCQUNidUcsSUFBSSxpQkFBaUJyQixPQUFPcUIsRUFBRTtnQkFDOUJyRyxPQUFPO29CQUNMc3hCLFVBQVU7b0JBQ1YsZ0ZBQWdGO29CQUNoRjZFLFlBQVksVUFBVW54QixPQUFPaUgsdUJBQXVCO2dCQUN0RDtZQUNGO1NBQUU7SUFDSjtJQUVBLElBQUlrQyxjQUFjLFNBQVNBLFlBQVlyTyxLQUFLLEVBQUVzTSxLQUFLO1FBQ2pELElBQUkxRixNQUFNMEYsTUFBTTFGLEdBQUc7UUFFbkIsSUFBSUEsSUFBSXdELFVBQVUsRUFBRTtZQUNsQixPQUFPO2dCQUFDcEs7Z0JBQU87b0JBQ2JFLE9BQU87d0JBQ0xtMkIsWUFBWSxTQUFVenZCLENBQUFBLElBQUlxTixLQUFLLENBQUN4VyxNQUFNLEdBQUc7b0JBQzNDO2dCQUNGO2FBQUU7UUFDSjtRQUVBLE9BQU87WUFBQ3VDO1lBQU8sQ0FBQztTQUFFO0lBQ3BCO0lBRUEsU0FBUzgxQixVQUFVNW1CLEtBQUssRUFBRVMsTUFBTSxFQUFFQyxhQUFhLEVBQUUzSyxRQUFRO1FBQ3ZELElBQUkwSyxPQUFPeEssSUFBSSxLQUFLdkcsUUFBUUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU94QixTQUFTO2dCQUNkODRCLFlBQVk7b0JBQ1Z2QyxjQUFjLENBQUM7Z0JBQ2pCO1lBQ0YsR0FBRzFrQjtRQUNMO1FBRUEsSUFBSVMsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVF3eUIsV0FBVyxFQUFFO1lBQ3ZDLE9BQU8vekIsU0FBUyxDQUFDLEdBQUc2UixPQUFPO2dCQUN6QmluQixZQUFZO29CQUNWdkMsY0FBYyxDQUFDO2dCQUNqQjtZQUNGO1FBQ0Y7UUFFQSxJQUFJamtCLE9BQU94SyxJQUFJLEtBQUt2RyxRQUFRcXlCLG1CQUFtQixFQUFFO1lBQy9DLElBQUlsaEIsV0FBV0osT0FBT0ksUUFBUSxFQUMxQmtpQixpQkFBaUJ0aUIsT0FBT3NpQixjQUFjO1lBQzFDLElBQUl1QixjQUFjOEMsZ0JBQWdCdm1CO1lBRWxDLElBQUl5akIsZ0JBQWdCcDJCLFdBQVc7Z0JBQzdCLElBQUlnNUIsY0FBY254QixTQUFTd0ksY0FBYyxDQUFDMU4sTUFBTSxDQUFDLFNBQVV3MkIsR0FBRyxFQUFFcnhCLE1BQU07b0JBQ3BFLElBQUl1UjtvQkFFSixPQUFPcFosU0FBUyxDQUFDLEdBQUdrNUIsS0FBTTlmLENBQUFBLFlBQVksQ0FBQyxHQUFHQSxTQUFTLENBQUN2UixPQUFPcUIsRUFBRSxDQUFDLEdBQUcrdkIsZ0JBQWdCcHhCLE9BQU9xQixFQUFFLEdBQUdrUSxTQUFRO2dCQUN2RyxHQUFHLENBQUM7Z0JBQ0osSUFBSStmLFlBQVl2eEIsU0FBU3dJLGNBQWMsQ0FBQzFOLE1BQU0sQ0FBQyxTQUFVdzJCLEdBQUcsRUFBRXJ4QixNQUFNO29CQUNsRSxJQUFJc3FCO29CQUVKLE9BQU9ueUIsU0FBUyxDQUFDLEdBQUdrNUIsS0FBTS9HLENBQUFBLFlBQVksQ0FBQyxHQUFHQSxTQUFTLENBQUN0cUIsT0FBT3FCLEVBQUUsQ0FBQyxHQUFHckIsT0FBTzNGLFFBQVEsRUFBRWl3QixTQUFRO2dCQUM1RixHQUFHLENBQUM7Z0JBQ0osSUFBSWlILFlBQVl4eEIsU0FBU3dJLGNBQWMsQ0FBQzFOLE1BQU0sQ0FBQyxTQUFVdzJCLEdBQUcsRUFBRXJ4QixNQUFNO29CQUNsRSxJQUFJdXFCO29CQUVKLE9BQU9weUIsU0FBUyxDQUFDLEdBQUdrNUIsS0FBTTlHLENBQUFBLFlBQVksQ0FBQyxHQUFHQSxTQUFTLENBQUN2cUIsT0FBT3FCLEVBQUUsQ0FBQyxHQUFHckIsT0FBTzFGLFFBQVEsRUFBRWl3QixTQUFRO2dCQUM1RixHQUFHLENBQUM7Z0JBQ0osSUFBSWlILHFCQUFxQnpFLGVBQWU5ckIsR0FBRyxDQUFDLFNBQVVzRyxLQUFLO29CQUN6RCxJQUFJOG5CLFdBQVc5bkIsS0FBSyxDQUFDLEVBQUU7b0JBQ3ZCLE9BQU87d0JBQUM4bkI7d0JBQVUrQixnQkFBZ0IvQjtxQkFBVTtnQkFDOUM7Z0JBQ0EsT0FBT2wzQixTQUFTLENBQUMsR0FBRzZSLE9BQU87b0JBQ3pCaW5CLFlBQVk5NEIsU0FBUyxDQUFDLEdBQUc2UixNQUFNaW5CLFVBQVUsRUFBRTt3QkFDekNDLGFBQWFBO3dCQUNiSSxXQUFXQTt3QkFDWEMsV0FBV0E7d0JBQ1hDLG9CQUFvQkE7d0JBQ3BCbEQsYUFBYUE7b0JBQ2Y7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLE9BQU90a0I7WUFDVDtRQUNGO1FBRUEsSUFBSVMsT0FBT3hLLElBQUksS0FBS3ZHLFFBQVFzeUIsY0FBYyxFQUFFO1lBQzFDLElBQUlnQixVQUFVdmlCLE9BQU91aUIsT0FBTztZQUM1QixJQUFJMkIsU0FBUzNrQixNQUFNZ2lCLGNBQWMsQ0FBQzJDLE1BQU07WUFFeEMsSUFBSThDLG9CQUFvQnpuQixNQUFNaW5CLFVBQVUsRUFDcENsQyxlQUFlMEMsa0JBQWtCbkQsV0FBVyxFQUM1Q29ELGFBQWFELGtCQUFrQkgsU0FBUyxFQUN4Q0ssYUFBYUYsa0JBQWtCRixTQUFTLEVBQ3hDSyx3QkFBd0JILGtCQUFrQkQsa0JBQWtCLEVBQzVESyxzQkFBc0JELDBCQUEwQixLQUFLLElBQUksRUFBRSxHQUFHQTtZQUVsRSxJQUFJMUMsU0FBU2xDLFVBQVUyQjtZQUN2QixJQUFJUSxtQkFBbUJELFNBQVNIO1lBQ2hDLElBQUlLLGtCQUFrQixDQUFDO1lBRXZCeUMsb0JBQW9CejFCLE9BQU8sQ0FBQyxTQUFVcUwsS0FBSztnQkFDekMsSUFBSTRuQixXQUFXNW5CLEtBQUssQ0FBQyxFQUFFLEVBQ25CNm5CLGNBQWM3bkIsS0FBSyxDQUFDLEVBQUU7Z0JBQzFCMm5CLGVBQWUsQ0FBQ0MsU0FBUyxHQUFHeGYsS0FBS0MsR0FBRyxDQUFDRCxLQUFLRSxHQUFHLENBQUMyaEIsVUFBVSxDQUFDckMsU0FBUyxFQUFFQyxjQUFjQSxjQUFjSCxtQkFBbUJ3QyxVQUFVLENBQUN0QyxTQUFTO1lBQ3pJO1lBRUEsT0FBT2wzQixTQUFTLENBQUMsR0FBRzZSLE9BQU87Z0JBQ3pCaW5CLFlBQVk5NEIsU0FBUyxDQUFDLEdBQUc2UixNQUFNaW5CLFVBQVUsRUFBRTtvQkFDekN2QyxjQUFjdjJCLFNBQVMsQ0FBQyxHQUFHNlIsTUFBTWluQixVQUFVLENBQUN2QyxZQUFZLEVBQUUsQ0FBQyxHQUFHVTtnQkFDaEU7WUFDRjtRQUNGO1FBRUEsSUFBSTNrQixPQUFPeEssSUFBSSxLQUFLdkcsUUFBUXV5QixrQkFBa0IsRUFBRTtZQUM5QyxPQUFPOXpCLFNBQVMsQ0FBQyxHQUFHNlIsT0FBTztnQkFDekJpbkIsWUFBWTk0QixTQUFTLENBQUMsR0FBRzZSLE1BQU1pbkIsVUFBVSxFQUFFO29CQUN6Q0MsYUFBYSxDQUFDO29CQUNkSSxXQUFXLENBQUM7b0JBQ1pDLFdBQVcsQ0FBQztnQkFDZDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVNILGdCQUFnQnZtQixRQUFRO1FBQy9CLElBQUlpbkI7UUFFSixJQUFJMTNCLFFBQVEsQ0FBQzAzQix3QkFBd0JwMEIsU0FBU3EwQixjQUFjLENBQUMsaUJBQWlCbG5CLFNBQVEsS0FBTSxPQUFPLEtBQUssSUFBSWluQixzQkFBc0JFLFdBQVc7UUFFN0ksSUFBSTUzQixVQUFVbEMsV0FBVztZQUN2QixPQUFPa0M7UUFDVDtJQUNGO0lBRUFsRSxTQUFRMnRCLHlCQUF5QixHQUFHQTtJQUNwQzN0QixTQUFRd0QsT0FBTyxHQUFHQTtJQUNsQnhELFNBQVFnRSxhQUFhLEdBQUdBO0lBQ3hCaEUsU0FBUW9qQixnQkFBZ0IsR0FBR0E7SUFDM0JwakIsU0FBUWlxQixnQkFBZ0IsR0FBR0E7SUFDM0JqcUIsU0FBUTBELGVBQWUsR0FBR0E7SUFDMUIxRCxTQUFRNkQsYUFBYSxHQUFHQTtJQUN4QjdELFNBQVFvRyxpQkFBaUIsR0FBR0E7SUFDNUJwRyxTQUFRaUssVUFBVSxHQUFHQTtJQUNyQmpLLFNBQVE4RyxnQkFBZ0IsR0FBR0E7SUFDM0I5RyxTQUFRZ0csU0FBUyxHQUFHQTtJQUNwQmhHLFNBQVF1RixjQUFjLEdBQUdBO0lBQ3pCdkYsU0FBUTRKLFlBQVksR0FBR0E7SUFDdkI1SixTQUFRMEYsV0FBVyxHQUFHQTtJQUN0QjFGLFNBQVF1SCxtQkFBbUIsR0FBR0E7SUFDOUJ2SCxTQUFRKzVCLGlCQUFpQixHQUFHQTtJQUM1Qi81QixTQUFROEgsZ0JBQWdCLEdBQUdBO0lBQzNCOUgsU0FBUXE2QixjQUFjLEdBQUdBO0lBQ3pCcjZCLFNBQVFtMUIsY0FBYyxHQUFHQTtJQUN6Qm4xQixTQUFRdWEsV0FBVyxHQUFHQTtJQUN0QnZhLFNBQVF3ZCxVQUFVLEdBQUdBO0lBQ3JCeGQsU0FBUXM2QixhQUFhLEdBQUdBO0lBQ3hCdDZCLFNBQVFpSCxZQUFZLEdBQUdBO0lBQ3ZCakgsU0FBUXdmLGVBQWUsR0FBR0E7SUFDMUJ4ZixTQUFReTZCLGFBQWEsR0FBR0E7SUFDeEJ6NkIsU0FBUWlpQixVQUFVLEdBQUdBO0lBQ3JCamlCLFNBQVEySCxzQkFBc0IsR0FBR0E7SUFDakMzSCxTQUFRK3JCLGFBQWEsR0FBR0E7SUFDeEIvckIsU0FBUWkyQixnQkFBZ0IsR0FBR0E7SUFDM0JqMkIsU0FBUXV3QixZQUFZLEdBQUdBO0lBQ3ZCdndCLFNBQVF1ekIsV0FBVyxHQUFHQTtJQUN0QnZ6QixTQUFRcW9CLFNBQVMsR0FBR0E7SUFDcEJyb0IsU0FBUTBXLFFBQVEsR0FBR0E7SUFFbkJsVyxPQUFPdTdCLGNBQWMsQ0FBQy83QixVQUFTLGNBQWM7UUFBRXFCLE9BQU87SUFBSztBQUU3RCxJQUNBLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRfYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYmxlL2Rpc3QvcmVhY3QtdGFibGUuZGV2ZWxvcG1lbnQuanM/ZTI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuUmVhY3RUYWJsZSA9IHt9LCBnbG9iYWwuUmVhY3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCkgeyAndXNlIHN0cmljdCc7XG5cbiAgUmVhY3QgPSBSZWFjdCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVhY3QsICdkZWZhdWx0JykgPyBSZWFjdFsnZGVmYXVsdCddIDogUmVhY3Q7XG5cbiAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblxuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG5cbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgdmFyIHJlbmRlckVyciA9ICdSZW5kZXJlciBFcnJvciDimJ3vuI8nO1xuICB2YXIgYWN0aW9ucyA9IHtcbiAgICBpbml0OiAnaW5pdCdcbiAgfTtcbiAgdmFyIGRlZmF1bHRSZW5kZXJlciA9IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJlcihfcmVmKSB7XG4gICAgdmFyIF9yZWYkdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICB2YWx1ZSA9IF9yZWYkdmFsdWUgPT09IHZvaWQgMCA/ICcnIDogX3JlZiR2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHZhciBlbXB0eVJlbmRlcmVyID0gZnVuY3Rpb24gZW1wdHlSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgXCJcXHhBMFwiKTtcbiAgfTtcbiAgdmFyIGRlZmF1bHRDb2x1bW4gPSB7XG4gICAgQ2VsbDogZGVmYXVsdFJlbmRlcmVyLFxuICAgIHdpZHRoOiAxNTAsXG4gICAgbWluV2lkdGg6IDAsXG4gICAgbWF4V2lkdGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG5cbiAgZnVuY3Rpb24gbWVyZ2VQcm9wcygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcExpc3QgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwcm9wTGlzdFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcExpc3QucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywgbmV4dCkge1xuICAgICAgdmFyIHN0eWxlID0gbmV4dC5zdHlsZSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBuZXh0LmNsYXNzTmFtZSxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UobmV4dCwgW1wic3R5bGVcIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gICAgICBwcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcywge30sIHJlc3QpO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBwcm9wcy5zdHlsZSA/IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSB8fCB7fSwge30sIHN0eWxlIHx8IHt9KSA6IHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSA/IHByb3BzLmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSA6IGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSA9PT0gJycpIHtcbiAgICAgICAgZGVsZXRlIHByb3BzLmNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVByb3BHZXR0ZXIocHJldlByb3BzLCB1c2VyUHJvcHMsIG1ldGEpIHtcbiAgICAvLyBIYW5kbGUgYSBsYW1iZGEsIHBhc3MgaXQgdGhlIHByZXZpb3VzIHByb3BzXG4gICAgaWYgKHR5cGVvZiB1c2VyUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYW5kbGVQcm9wR2V0dGVyKHt9LCB1c2VyUHJvcHMocHJldlByb3BzLCBtZXRhKSk7XG4gICAgfSAvLyBIYW5kbGUgYW4gYXJyYXksIG1lcmdlIGVhY2ggaXRlbSBhcyBzZXBhcmF0ZSBwcm9wc1xuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh1c2VyUHJvcHMpKSB7XG4gICAgICByZXR1cm4gbWVyZ2VQcm9wcy5hcHBseSh2b2lkIDAsIFtwcmV2UHJvcHNdLmNvbmNhdCh1c2VyUHJvcHMpKTtcbiAgICB9IC8vIEhhbmRsZSBhbiBvYmplY3QgYnkgZGVmYXVsdCwgbWVyZ2UgdGhlIHR3byBvYmplY3RzXG5cblxuICAgIHJldHVybiBtZXJnZVByb3BzKHByZXZQcm9wcywgdXNlclByb3BzKTtcbiAgfVxuXG4gIHZhciBtYWtlUHJvcEdldHRlciA9IGZ1bmN0aW9uIG1ha2VQcm9wR2V0dGVyKGhvb2tzLCBtZXRhKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodXNlclByb3BzKSB7XG4gICAgICBpZiAodXNlclByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNlclByb3BzID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXS5jb25jYXQoaG9va3MsIFt1c2VyUHJvcHNdKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVByb3BHZXR0ZXIocHJldiwgbmV4dCwgX2V4dGVuZHMoe30sIG1ldGEsIHtcbiAgICAgICAgICB1c2VyUHJvcHM6IHVzZXJQcm9wc1xuICAgICAgICB9KSk7XG4gICAgICB9LCB7fSk7XG4gICAgfTtcbiAgfTtcbiAgdmFyIHJlZHVjZUhvb2tzID0gZnVuY3Rpb24gcmVkdWNlSG9va3MoaG9va3MsIGluaXRpYWwsIG1ldGEsIGFsbG93VW5kZWZpbmVkKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBob29rcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0KHByZXYsIG1ldGEpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICghYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8obmV4dCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBUYWJsZTogQSByZWR1Y2VyIGhvb2sg4pid77iPIGp1c3QgcmV0dXJuZWQgdW5kZWZpbmVkISBUaGlzIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgfSwgaW5pdGlhbCk7XG4gIH07XG4gIHZhciBsb29wSG9va3MgPSBmdW5jdGlvbiBsb29wSG9va3MoaG9va3MsIGNvbnRleHQsIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBob29rKGNvbnRleHQsIG1ldGEpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhob29rLCBuZXh0VmFsdWUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgVGFibGU6IEEgbG9vcC10eXBlIGhvb2sg4pid77iPIGp1c3QgcmV0dXJuZWQgYSB2YWx1ZSEgVGhpcyBpcyBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBiZWZvcmVzLCBwbHVnaW5OYW1lLCBhZnRlcnMpIHtcbiAgICBpZiAoIGFmdGVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmaW5pbmcgcGx1Z2lucyBpbiB0aGUgXFxcImFmdGVyXFxcIiBzZWN0aW9uIG9mIGVuc3VyZVBsdWdpbk9yZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgKHNlZSBwbHVnaW4gXCIgKyBwbHVnaW5OYW1lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5JbmRleCA9IHBsdWdpbnMuZmluZEluZGV4KGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHJldHVybiBwbHVnaW4ucGx1Z2luTmFtZSA9PT0gcGx1Z2luTmFtZTtcbiAgICB9KTtcblxuICAgIGlmIChwbHVnaW5JbmRleCA9PT0gLTEpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBsdWdpbiBcXFwiXCIgKyBwbHVnaW5OYW1lICsgXCJcXFwiIHdhcyBub3QgZm91bmQgaW4gdGhlIHBsdWdpbiBsaXN0IVxcblRoaXMgdXN1YWxseSBtZWFucyB5b3UgbmVlZCB0byBuZWVkIHRvIG5hbWUgeW91ciBwbHVnaW4gaG9vayBieSBzZXR0aW5nIHRoZSAncGx1Z2luTmFtZScgcHJvcGVydHkgb2YgdGhlIGhvb2sgZnVuY3Rpb24sIGVnOlxcblxcbiAgXCIgKyBwbHVnaW5OYW1lICsgXCIucGx1Z2luTmFtZSA9ICdcIiArIHBsdWdpbk5hbWUgKyBcIidcXG5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChiZWZvcmUpIHtcbiAgICAgIHZhciBiZWZvcmVJbmRleCA9IHBsdWdpbnMuZmluZEluZGV4KGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5wbHVnaW5OYW1lID09PSBiZWZvcmU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGJlZm9yZUluZGV4ID4gLTEgJiYgYmVmb3JlSW5kZXggPiBwbHVnaW5JbmRleCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IFRoZSBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW4gaG9vayBtdXN0IGJlIHBsYWNlZCBhZnRlciB0aGUgXCIgKyBiZWZvcmUgKyBcIiBwbHVnaW4gaG9vayFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCkge1xuICAgIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIob2xkKSA6IHVwZGF0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlR2V0TGF0ZXN0KG9iaikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICByZWYuY3VycmVudCA9IG9iajtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbiAgfSAvLyBTU1IgaGFzIGlzc3VlcyB3aXRoIHVzZUxheW91dEVmZmVjdCBzdGlsbCwgc28gdXNlIHVzZUVmZmVjdCBkdXJpbmcgU1NSXG5cbiAgdmFyIHNhZmVVc2VMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuICBmdW5jdGlvbiB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZuLCBkZXBzKSB7XG4gICAgdmFyIG1vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHNhZmVVc2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuXG4gICAgICBtb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBkZXBzKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VBc3luY0RlYm91bmNlKGRlZmF1bHRGbiwgZGVmYXVsdFdhaXQpIHtcbiAgICBpZiAoZGVmYXVsdFdhaXQgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdFdhaXQgPSAwO1xuICAgIH1cblxuICAgIHZhciBkZWJvdW5jZVJlZiA9IFJlYWN0LnVzZVJlZih7fSk7XG4gICAgdmFyIGdldERlZmF1bHRGbiA9IHVzZUdldExhdGVzdChkZWZhdWx0Rm4pO1xuICAgIHZhciBnZXREZWZhdWx0V2FpdCA9IHVzZUdldExhdGVzdChkZWZhdWx0V2FpdCk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX2xlbjIsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgX2tleTIsXG4gICAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmb3IgKF9sZW4yID0gX2FyZ3MyLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBfYXJnczJbX2tleTJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZVJlZi5jdXJyZW50LnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IGRlYm91bmNlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdEZuKCkuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAucmVzb2x2ZS5jYWxsKF9jb250ZXh0LnQwLCBfY29udGV4dC50MSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnJlamVjdChfY29udGV4dC50Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDksIDEyLCAxNV1dKTtcbiAgICAgICAgICAgICAgICB9KSksIGdldERlZmF1bHRXYWl0KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCksIFtnZXREZWZhdWx0Rm4sIGdldERlZmF1bHRXYWl0XSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZVJlbmRlcmVyKGluc3RhbmNlLCBjb2x1bW4sIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCB1c2VyUHJvcHMpIHtcbiAgICAgIGlmICh1c2VyUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICB1c2VyUHJvcHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIENvbXAgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBjb2x1bW5bdHlwZV0gOiB0eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhjb2x1bW4pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVuZGVyRXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsZXhSZW5kZXIoQ29tcCwgX2V4dGVuZHMoe30sIGluc3RhbmNlLCB7XG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9LCBtZXRhLCB7fSwgdXNlclByb3BzKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RDb21wb25lbnQoQ29tcCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXAsIHByb3BzKSA6IENvbXA7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlYWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcG9uZW50KTtcbiAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gICAgfSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rQ29sdW1uU3RydWN0dXJlKGNvbHVtbnMsIHBhcmVudCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4gPSBfZXh0ZW5kcyh7fSwgY29sdW1uLCB7XG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgIH0pO1xuICAgICAgYXNzaWduQ29sdW1uQWNjZXNzb3IoY29sdW1uKTtcblxuICAgICAgaWYgKGNvbHVtbi5jb2x1bW5zKSB7XG4gICAgICAgIGNvbHVtbi5jb2x1bW5zID0gbGlua0NvbHVtblN0cnVjdHVyZShjb2x1bW4uY29sdW1ucywgY29sdW1uLCBkZXB0aCArIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sdW1uO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsYXR0ZW5Db2x1bW5zKGNvbHVtbnMpIHtcbiAgICByZXR1cm4gZmxhdHRlbkJ5KGNvbHVtbnMsICdjb2x1bW5zJyk7XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduQ29sdW1uQWNjZXNzb3IoY29sdW1uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgZm9yIHN0cmluZyBhY2Nlc3NvclxuICAgIHZhciBpZCA9IGNvbHVtbi5pZCxcbiAgICAgICAgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgIEhlYWRlciA9IGNvbHVtbi5IZWFkZXI7XG5cbiAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgaWQgPSBpZCB8fCBhY2Nlc3NvcjtcbiAgICAgIHZhciBhY2Nlc3NvclBhdGggPSBhY2Nlc3Nvci5zcGxpdCgnLicpO1xuXG4gICAgICBhY2Nlc3NvciA9IGZ1bmN0aW9uIGFjY2Vzc29yKHJvdykge1xuICAgICAgICByZXR1cm4gZ2V0Qnkocm93LCBhY2Nlc3NvclBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlkICYmIHR5cGVvZiBIZWFkZXIgPT09ICdzdHJpbmcnICYmIEhlYWRlcikge1xuICAgICAgaWQgPSBIZWFkZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpZCAmJiBjb2x1bW4uY29sdW1ucykge1xuICAgICAgY29uc29sZS5lcnJvcihjb2x1bW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbHVtbiBJRCAob3IgdW5pcXVlIFwiSGVhZGVyXCIgdmFsdWUpIGlzIHJlcXVpcmVkIScpO1xuICAgIH1cblxuICAgIGlmICghaWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoY29sdW1uKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjb2x1bW4gSUQgKG9yIHN0cmluZyBhY2Nlc3NvcikgaXMgcmVxdWlyZWQhJyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGFjY2Vzc29yOiBhY2Nlc3NvclxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW47XG4gIH1cbiAgZnVuY3Rpb24gZGVjb3JhdGVDb2x1bW4oY29sdW1uLCB1c2VyRGVmYXVsdENvbHVtbikge1xuICAgIGlmICghdXNlckRlZmF1bHRDb2x1bW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oY29sdW1uLCBfZXh0ZW5kcyh7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSBmYWxsYmFjayBoZWFkZXIsIGp1c3QgaW4gY2FzZVxuICAgICAgSGVhZGVyOiBlbXB0eVJlbmRlcmVyLFxuICAgICAgRm9vdGVyOiBlbXB0eVJlbmRlcmVyXG4gICAgfSwgZGVmYXVsdENvbHVtbiwge30sIHVzZXJEZWZhdWx0Q29sdW1uLCB7fSwgY29sdW1uKSk7XG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIHtcbiAgICAgIG9yaWdpbmFsV2lkdGg6IGNvbHVtbi53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW47XG4gIH0gLy8gQnVpbGQgdGhlIGhlYWRlciBncm91cHMgZnJvbSB0aGUgYm90dG9tIHVwXG5cbiAgZnVuY3Rpb24gbWFrZUhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBkZWZhdWx0Q29sdW1uLCBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcykge1xuICAgIGlmIChhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyA9PT0gdm9pZCAwKSB7XG4gICAgICBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoZWFkZXJHcm91cHMgPSBbXTtcbiAgICB2YXIgc2NhbkNvbHVtbnMgPSBhbGxDb2x1bW5zO1xuICAgIHZhciB1aWQgPSAwO1xuXG4gICAgdmFyIGdldFVJRCA9IGZ1bmN0aW9uIGdldFVJRCgpIHtcbiAgICAgIHJldHVybiB1aWQrKztcbiAgICB9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgICAgdmFyIGhlYWRlckdyb3VwID0ge1xuICAgICAgICBoZWFkZXJzOiBbXVxuICAgICAgfTsgLy8gVGhlIHBhcmVudCBjb2x1bW5zIHdlJ3JlIGdvaW5nIHRvIHNjYW4gbmV4dFxuXG4gICAgICB2YXIgcGFyZW50Q29sdW1ucyA9IFtdO1xuICAgICAgdmFyIGhhc1BhcmVudHMgPSBzY2FuQ29sdW1ucy5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnBhcmVudDtcbiAgICAgIH0pOyAvLyBTY2FuIGVhY2ggY29sdW1uIGZvciBwYXJlbnRzXG5cbiAgICAgIHNjYW5Db2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG4gICAgICAgIHZhciBsYXRlc3RQYXJlbnRDb2x1bW4gPSBbXS5jb25jYXQocGFyZW50Q29sdW1ucykucmV2ZXJzZSgpWzBdO1xuICAgICAgICB2YXIgbmV3UGFyZW50O1xuXG4gICAgICAgIGlmIChoYXNQYXJlbnRzKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbHVtbiBoYXMgYSBwYXJlbnQsIGFkZCBpdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoY29sdW1uLnBhcmVudCkge1xuICAgICAgICAgICAgbmV3UGFyZW50ID0gX2V4dGVuZHMoe30sIGNvbHVtbi5wYXJlbnQsIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxJZDogY29sdW1uLnBhcmVudC5pZCxcbiAgICAgICAgICAgICAgaWQ6IGNvbHVtbi5wYXJlbnQuaWQgKyBcIl9cIiArIGdldFVJRCgpLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBbY29sdW1uXVxuICAgICAgICAgICAgfSwgYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoY29sdW1uKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG90aGVyIGNvbHVtbnMgaGF2ZSBwYXJlbnRzLCB3ZSdsbCBuZWVkIHRvIGFkZCBhIHBsYWNlIGhvbGRlciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbElkID0gY29sdW1uLmlkICsgXCJfcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgICAgIG5ld1BhcmVudCA9IGRlY29yYXRlQ29sdW1uKF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxJZDogb3JpZ2luYWxJZCxcbiAgICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCArIFwiX3BsYWNlaG9sZGVyX1wiICsgZ2V0VUlEKCksXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyT2Y6IGNvbHVtbixcbiAgICAgICAgICAgICAgaGVhZGVyczogW2NvbHVtbl1cbiAgICAgICAgICAgIH0sIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKGNvbHVtbikpLCBkZWZhdWx0Q29sdW1uKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSByZXN1bHRpbmcgcGFyZW50IGNvbHVtbnMgYXJlIHRoZSBzYW1lLCBqdXN0IGFkZFxuICAgICAgICAgIC8vIHRoZSBjb2x1bW4gYW5kIGluY3JlbWVudCB0aGUgaGVhZGVyIHNwYW5cblxuXG4gICAgICAgICAgaWYgKGxhdGVzdFBhcmVudENvbHVtbiAmJiBsYXRlc3RQYXJlbnRDb2x1bW4ub3JpZ2luYWxJZCA9PT0gbmV3UGFyZW50Lm9yaWdpbmFsSWQpIHtcbiAgICAgICAgICAgIGxhdGVzdFBhcmVudENvbHVtbi5oZWFkZXJzLnB1c2goY29sdW1uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Q29sdW1ucy5wdXNoKG5ld1BhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyR3JvdXAuaGVhZGVycy5wdXNoKGNvbHVtbik7XG4gICAgICB9KTtcbiAgICAgIGhlYWRlckdyb3Vwcy5wdXNoKGhlYWRlckdyb3VwKTsgLy8gU3RhcnQgc2Nhbm5pbmcgdGhlIHBhcmVudCBjb2x1bW5zXG5cbiAgICAgIHNjYW5Db2x1bW5zID0gcGFyZW50Q29sdW1ucztcbiAgICB9O1xuXG4gICAgd2hpbGUgKHNjYW5Db2x1bW5zLmxlbmd0aCkge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyR3JvdXBzLnJldmVyc2UoKTtcbiAgfVxuICB2YXIgcGF0aE9iakNhY2hlID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRCeShvYmosIHBhdGgsIGRlZikge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVLZXkgPSB0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJyA/IHBhdGggOiBKU09OLnN0cmluZ2lmeShwYXRoKTtcblxuICAgIHZhciBwYXRoT2JqID0gcGF0aE9iakNhY2hlLmdldChjYWNoZUtleSkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhPYmogPSBtYWtlUGF0aEFycmF5KHBhdGgpO1xuICAgICAgcGF0aE9iakNhY2hlLnNldChjYWNoZUtleSwgcGF0aE9iaik7XG4gICAgICByZXR1cm4gcGF0aE9iajtcbiAgICB9KCk7XG5cbiAgICB2YXIgdmFsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IHBhdGhPYmoucmVkdWNlKGZ1bmN0aW9uIChjdXJzb3IsIHBhdGhQYXJ0KSB7XG4gICAgICAgIHJldHVybiBjdXJzb3JbcGF0aFBhcnRdO1xuICAgICAgfSwgb2JqKTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyA/IHZhbCA6IGRlZjtcbiAgfVxuICBmdW5jdGlvbiBnZXRGaXJzdERlZmluZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkJ5KGFyciwga2V5KSB7XG4gICAgdmFyIGZsYXQgPSBbXTtcblxuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gcmVjdXJzZShhcnIpIHtcbiAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmICghZFtrZXldKSB7XG4gICAgICAgICAgZmxhdC5wdXNoKGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2UoZFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlY3Vyc2UoYXJyKTtcbiAgICByZXR1cm4gZmxhdDtcbiAgfVxuICBmdW5jdGlvbiBleHBhbmRSb3dzKHJvd3MsIF9yZWYpIHtcbiAgICB2YXIgbWFudWFsRXhwYW5kZWRLZXkgPSBfcmVmLm1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBleHBhbmRlZCA9IF9yZWYuZXhwYW5kZWQsXG4gICAgICAgIF9yZWYkZXhwYW5kU3ViUm93cyA9IF9yZWYuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9yZWYkZXhwYW5kU3ViUm93cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkZXhwYW5kU3ViUm93cztcbiAgICB2YXIgZXhwYW5kZWRSb3dzID0gW107XG5cbiAgICB2YXIgaGFuZGxlUm93ID0gZnVuY3Rpb24gaGFuZGxlUm93KHJvdywgYWRkVG9FeHBhbmRlZFJvd3MpIHtcbiAgICAgIGlmIChhZGRUb0V4cGFuZGVkUm93cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFkZFRvRXhwYW5kZWRSb3dzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcm93LmlzRXhwYW5kZWQgPSByb3cub3JpZ2luYWwgJiYgcm93Lm9yaWdpbmFsW21hbnVhbEV4cGFuZGVkS2V5XSB8fCBleHBhbmRlZFtyb3cuaWRdO1xuICAgICAgcm93LmNhbkV4cGFuZCA9IHJvdy5zdWJSb3dzICYmICEhcm93LnN1YlJvd3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYWRkVG9FeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgZXhwYW5kZWRSb3dzLnB1c2gocm93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdy5zdWJSb3dzICYmIHJvdy5zdWJSb3dzLmxlbmd0aCAmJiByb3cuaXNFeHBhbmRlZCkge1xuICAgICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUm93KHJvdywgZXhwYW5kU3ViUm93cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGhhbmRsZVJvdyhyb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiBleHBhbmRlZFJvd3M7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmlsdGVyTWV0aG9kKGZpbHRlciwgdXNlckZpbHRlclR5cGVzLCBmaWx0ZXJUeXBlcykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZpbHRlcikgfHwgdXNlckZpbHRlclR5cGVzW2ZpbHRlcl0gfHwgZmlsdGVyVHlwZXNbZmlsdGVyXSB8fCBmaWx0ZXJUeXBlcy50ZXh0O1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoYXV0b1JlbW92ZSwgdmFsdWUsIGNvbHVtbikge1xuICAgIHJldHVybiBhdXRvUmVtb3ZlID8gYXV0b1JlbW92ZSh2YWx1ZSwgY29sdW1uKSA6IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgZnVuY3Rpb24gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC1UYWJsZTogWW91IGhhdmUgbm90IGNhbGxlZCBwcmVwYXJlUm93KHJvdykgb25lIG9yIG1vcmUgcm93cyB5b3UgYXJlIGF0dGVtcHRpbmcgdG8gcmVuZGVyLicpO1xuICB9XG4gIHZhciBwYXNzaXZlU3VwcG9ydGVkID0gbnVsbDtcbiAgZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICAgIC8vIG1lbW9pemUgc3VwcG9ydCB0byBhdm9pZCBhZGRpbmcgbXVsdGlwbGUgdGVzdCBldmVudHNcbiAgICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gICAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXNzaXZlU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICAgIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICB9IC8vXG5cbiAgdmFyIHJlT3BlbkJyYWNrZXQgPSAvXFxbL2c7XG4gIHZhciByZUNsb3NlQnJhY2tldCA9IC9cXF0vZztcblxuICBmdW5jdGlvbiBtYWtlUGF0aEFycmF5KG9iaikge1xuICAgIHJldHVybiBmbGF0dGVuRGVlcChvYmopIC8vIHJlbW92ZSBhbGwgcGVyaW9kcyBpbiBwYXJ0c1xuICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZCkucmVwbGFjZSgnLicsICdfJyk7XG4gICAgfSkgLy8gam9pbiBwYXJ0cyB1c2luZyBwZXJpb2RcbiAgICAuam9pbignLicpIC8vIHJlcGxhY2UgYnJhY2tldHMgd2l0aCBwZXJpb2RzXG4gICAgLnJlcGxhY2UocmVPcGVuQnJhY2tldCwgJy4nKS5yZXBsYWNlKHJlQ2xvc2VCcmFja2V0LCAnJykgLy8gc3BsaXQgaXQgYmFjayBvdXQgb24gcGVyaW9kc1xuICAgIC5zcGxpdCgnLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyLCBuZXdBcnIpIHtcbiAgICBpZiAobmV3QXJyID09PSB2b2lkIDApIHtcbiAgICAgIG5ld0FyciA9IFtdO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBuZXdBcnIucHVzaChhcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBmbGF0dGVuRGVlcChhcnJbaV0sIG5ld0Fycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIHZhciBkZWZhdWx0R2V0VGFibGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUYWJsZVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHJvbGU6ICd0YWJsZSdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRUYWJsZUJvZHlQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUYWJsZUJvZHlQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICByb2xlOiAncm93Z3JvdXAnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0SGVhZGVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZi5jb2x1bW47XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJoZWFkZXJfXCIgKyBjb2x1bW4uaWQsXG4gICAgICBjb2xTcGFuOiBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnQsXG4gICAgICByb2xlOiAnY29sdW1uaGVhZGVyJ1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEZvb3RlclByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEZvb3RlclByb3BzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMi5jb2x1bW47XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJmb290ZXJfXCIgKyBjb2x1bW4uaWQsXG4gICAgICBjb2xTcGFuOiBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnRcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRIZWFkZXJHcm91cFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGluZGV4ID0gX3JlZjMuaW5kZXg7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJoZWFkZXJHcm91cF9cIiArIGluZGV4LFxuICAgICAgcm9sZTogJ3JvdydcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRGb290ZXJHcm91cFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHMocHJvcHMsIF9yZWY0KSB7XG4gICAgdmFyIGluZGV4ID0gX3JlZjQuaW5kZXg7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJmb290ZXJHcm91cF9cIiArIGluZGV4XG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Um93UHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Um93UHJvcHMocHJvcHMsIF9yZWY1KSB7XG4gICAgdmFyIHJvdyA9IF9yZWY1LnJvdztcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcInJvd19cIiArIHJvdy5pZCxcbiAgICAgIHJvbGU6ICdyb3cnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Q2VsbFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldENlbGxQcm9wcyhwcm9wcywgX3JlZjYpIHtcbiAgICB2YXIgY2VsbCA9IF9yZWY2LmNlbGw7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJjZWxsX1wiICsgY2VsbC5yb3cuaWQgKyBcIl9cIiArIGNlbGwuY29sdW1uLmlkLFxuICAgICAgcm9sZTogJ2NlbGwnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VEZWZhdWx0UGx1Z2luSG9va3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZU9wdGlvbnM6IFtdLFxuICAgICAgc3RhdGVSZWR1Y2VyczogW10sXG4gICAgICB1c2VDb250cm9sbGVkU3RhdGU6IFtdLFxuICAgICAgY29sdW1uczogW10sXG4gICAgICBjb2x1bW5zRGVwczogW10sXG4gICAgICBhbGxDb2x1bW5zOiBbXSxcbiAgICAgIGFsbENvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGFjY2Vzc1ZhbHVlOiBbXSxcbiAgICAgIG1hdGVyaWFsaXplZENvbHVtbnM6IFtdLFxuICAgICAgbWF0ZXJpYWxpemVkQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgdXNlSW5zdGFuY2VBZnRlckRhdGE6IFtdLFxuICAgICAgdmlzaWJsZUNvbHVtbnM6IFtdLFxuICAgICAgdmlzaWJsZUNvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGhlYWRlckdyb3VwczogW10sXG4gICAgICBoZWFkZXJHcm91cHNEZXBzOiBbXSxcbiAgICAgIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9uczogW10sXG4gICAgICB1c2VJbnN0YW5jZTogW10sXG4gICAgICBwcmVwYXJlUm93OiBbXSxcbiAgICAgIGdldFRhYmxlUHJvcHM6IFtkZWZhdWx0R2V0VGFibGVQcm9wc10sXG4gICAgICBnZXRUYWJsZUJvZHlQcm9wczogW2RlZmF1bHRHZXRUYWJsZUJvZHlQcm9wc10sXG4gICAgICBnZXRIZWFkZXJHcm91cFByb3BzOiBbZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHNdLFxuICAgICAgZ2V0Rm9vdGVyR3JvdXBQcm9wczogW2RlZmF1bHRHZXRGb290ZXJHcm91cFByb3BzXSxcbiAgICAgIGdldEhlYWRlclByb3BzOiBbZGVmYXVsdEdldEhlYWRlclByb3BzXSxcbiAgICAgIGdldEZvb3RlclByb3BzOiBbZGVmYXVsdEdldEZvb3RlclByb3BzXSxcbiAgICAgIGdldFJvd1Byb3BzOiBbZGVmYXVsdEdldFJvd1Byb3BzXSxcbiAgICAgIGdldENlbGxQcm9wczogW2RlZmF1bHRHZXRDZWxsUHJvcHNdLFxuICAgICAgdXNlRmluYWxJbnN0YW5jZTogW11cbiAgICB9O1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEhpZGRlbkNvbHVtbnMgPSAncmVzZXRIaWRkZW5Db2x1bW5zJztcbiAgYWN0aW9ucy50b2dnbGVIaWRlQ29sdW1uID0gJ3RvZ2dsZUhpZGVDb2x1bW4nO1xuICBhY3Rpb25zLnNldEhpZGRlbkNvbHVtbnMgPSAnc2V0SGlkZGVuQ29sdW1ucyc7XG4gIGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMgPSAndG9nZ2xlSGlkZUFsbENvbHVtbnMnO1xuICB2YXIgdXNlQ29sdW1uVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVzZUNvbHVtblZpc2liaWxpdHkoaG9va3MpIHtcbiAgICBob29rcy5nZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMucHVzaCh1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMpO1xuICAgIGhvb2tzLmhlYWRlckdyb3Vwc0RlcHMucHVzaChmdW5jdGlvbiAoZGVwcywgX3JlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLmhpZGRlbkNvbHVtbnNdKTtcbiAgICB9KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlKTtcbiAgfTtcbiAgdXNlQ29sdW1uVmlzaWJpbGl0eS5wbHVnaW5OYW1lID0gJ3VzZUNvbHVtblZpc2liaWxpdHknO1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlSGlkZGVuKCFlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGNvbHVtbi5pc1Zpc2libGUsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBDb2x1bW4gVmlzaWJsZSdcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBpbnN0YW5jZS50b2dnbGVIaWRlQWxsQ29sdW1ucyghZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiAhaW5zdGFuY2UuYWxsQ29sdW1uc0hpZGRlbiAmJiAhaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGgsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgQ29sdW1ucyBIaWRkZW4nLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogIWluc3RhbmNlLmFsbENvbHVtbnNIaWRkZW4gJiYgaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGhcbiAgICB9XTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1ucykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBoaWRkZW5Db2x1bW5zOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuaGlkZGVuQ29sdW1ucyB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4pIHtcbiAgICAgIHZhciBzaG91bGQgPSB0eXBlb2YgYWN0aW9uLnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGFjdGlvbi52YWx1ZSA6ICFzdGF0ZS5oaWRkZW5Db2x1bW5zLmluY2x1ZGVzKGFjdGlvbi5jb2x1bW5JZCk7XG4gICAgICB2YXIgaGlkZGVuQ29sdW1ucyA9IHNob3VsZCA/IFtdLmNvbmNhdChzdGF0ZS5oaWRkZW5Db2x1bW5zLCBbYWN0aW9uLmNvbHVtbklkXSkgOiBzdGF0ZS5oaWRkZW5Db2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZCAhPT0gYWN0aW9uLmNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGhpZGRlbkNvbHVtbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRIaWRkZW5Db2x1bW5zKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uYWxVcGRhdGUoYWN0aW9uLnZhbHVlLCBzdGF0ZS5oaWRkZW5Db2x1bW5zKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUhpZGVBbGxDb2x1bW5zKSB7XG4gICAgICB2YXIgc2hvdWxkQWxsID0gdHlwZW9mIGFjdGlvbi52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBhY3Rpb24udmFsdWUgOiAhc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGg7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IHNob3VsZEFsbCA/IGluc3RhbmNlLmFsbENvbHVtbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgIH0pIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBoZWFkZXJzID0gaW5zdGFuY2UuaGVhZGVycyxcbiAgICAgICAgaGlkZGVuQ29sdW1ucyA9IGluc3RhbmNlLnN0YXRlLmhpZGRlbkNvbHVtbnM7XG4gICAgdmFyIGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG5cbiAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSA7XG5cbiAgICB2YXIgaGFuZGxlQ29sdW1uID0gZnVuY3Rpb24gaGFuZGxlQ29sdW1uKGNvbHVtbiwgcGFyZW50VmlzaWJsZSkge1xuICAgICAgY29sdW1uLmlzVmlzaWJsZSA9IHBhcmVudFZpc2libGUgJiYgIWhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIHZhciB0b3RhbFZpc2libGVIZWFkZXJDb3VudCA9IDA7XG5cbiAgICAgIGlmIChjb2x1bW4uaGVhZGVycyAmJiBjb2x1bW4uaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY29sdW1uLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViQ29sdW1uKSB7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ICs9IGhhbmRsZUNvbHVtbihzdWJDb2x1bW4sIGNvbHVtbi5pc1Zpc2libGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gY29sdW1uLmlzVmlzaWJsZSA/IDEgOiAwO1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSB0b3RhbFZpc2libGVIZWFkZXJDb3VudDtcbiAgICAgIHJldHVybiB0b3RhbFZpc2libGVIZWFkZXJDb3VudDtcbiAgICB9O1xuXG4gICAgdmFyIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gMDtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YkhlYWRlcikge1xuICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ICs9IGhhbmRsZUNvbHVtbihzdWJIZWFkZXIsIHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgY29sdW1ucyA9IGluc3RhbmNlLmNvbHVtbnMsXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBoaWRkZW5Db2x1bW5zID0gaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEhpID0gaW5zdGFuY2UuYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgICAgYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRIaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRIaTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBhbGxDb2x1bW5zSGlkZGVuID0gYWxsQ29sdW1ucy5sZW5ndGggPT09IGhpZGRlbkNvbHVtbnMubGVuZ3RoO1xuICAgIHZhciB0b2dnbGVIaWRlQ29sdW1uID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVIaWRlQ29sdW1uLFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEhpZGRlbkNvbHVtbnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlSGlkZUFsbENvbHVtbnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4udG9nZ2xlSGlkZGVuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4sXG4gICAgICAgICAgY29sdW1uSWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb2x1bW4uZ2V0VG9nZ2xlSGlkZGVuUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUhpZGRlblByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGdldEF1dG9SZXNldEhpZGRlbkNvbHVtbnMgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0SGlkZGVuQ29sdW1ucygpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGNvbHVtbnNdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBhbGxDb2x1bW5zSGlkZGVuOiBhbGxDb2x1bW5zSGlkZGVuLFxuICAgICAgdG9nZ2xlSGlkZUNvbHVtbjogdG9nZ2xlSGlkZUNvbHVtbixcbiAgICAgIHNldEhpZGRlbkNvbHVtbnM6IHNldEhpZGRlbkNvbHVtbnMsXG4gICAgICB0b2dnbGVIaWRlQWxsQ29sdW1uczogdG9nZ2xlSGlkZUFsbENvbHVtbnMsXG4gICAgICBnZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzOiBnZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGVmYXVsdEluaXRpYWxTdGF0ZSA9IHt9O1xuICB2YXIgZGVmYXVsdENvbHVtbkluc3RhbmNlID0ge307XG5cbiAgdmFyIGRlZmF1bHRSZWR1Y2VyID0gZnVuY3Rpb24gZGVmYXVsdFJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgcHJldlN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0U3ViUm93cyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRTdWJSb3dzKHJvdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcm93LnN1YlJvd3MgfHwgW107XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSb3dJZCA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gXCJcIiArIChwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXgpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0VXNlQ29udHJvbGxlZFN0YXRlID0gZnVuY3Rpb24gZGVmYXVsdFVzZUNvbnRyb2xsZWRTdGF0ZShkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhwcm9wcykge1xuICAgIHZhciBfcHJvcHMkaW5pdGlhbFN0YXRlID0gcHJvcHMuaW5pdGlhbFN0YXRlLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSBfcHJvcHMkaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbFN0YXRlIDogX3Byb3BzJGluaXRpYWxTdGF0ZSxcbiAgICAgICAgX3Byb3BzJGRlZmF1bHRDb2x1bW4gPSBwcm9wcy5kZWZhdWx0Q29sdW1uLFxuICAgICAgICBkZWZhdWx0Q29sdW1uID0gX3Byb3BzJGRlZmF1bHRDb2x1bW4gPT09IHZvaWQgMCA/IGRlZmF1bHRDb2x1bW5JbnN0YW5jZSA6IF9wcm9wcyRkZWZhdWx0Q29sdW1uLFxuICAgICAgICBfcHJvcHMkZ2V0U3ViUm93cyA9IHByb3BzLmdldFN1YlJvd3MsXG4gICAgICAgIGdldFN1YlJvd3MgPSBfcHJvcHMkZ2V0U3ViUm93cyA9PT0gdm9pZCAwID8gZGVmYXVsdEdldFN1YlJvd3MgOiBfcHJvcHMkZ2V0U3ViUm93cyxcbiAgICAgICAgX3Byb3BzJGdldFJvd0lkID0gcHJvcHMuZ2V0Um93SWQsXG4gICAgICAgIGdldFJvd0lkID0gX3Byb3BzJGdldFJvd0lkID09PSB2b2lkIDAgPyBkZWZhdWx0R2V0Um93SWQgOiBfcHJvcHMkZ2V0Um93SWQsXG4gICAgICAgIF9wcm9wcyRzdGF0ZVJlZHVjZXIgPSBwcm9wcy5zdGF0ZVJlZHVjZXIsXG4gICAgICAgIHN0YXRlUmVkdWNlciA9IF9wcm9wcyRzdGF0ZVJlZHVjZXIgPT09IHZvaWQgMCA/IGRlZmF1bHRSZWR1Y2VyIDogX3Byb3BzJHN0YXRlUmVkdWNlcixcbiAgICAgICAgX3Byb3BzJHVzZUNvbnRyb2xsZWRTID0gcHJvcHMudXNlQ29udHJvbGxlZFN0YXRlLFxuICAgICAgICB1c2VDb250cm9sbGVkU3RhdGUgPSBfcHJvcHMkdXNlQ29udHJvbGxlZFMgPT09IHZvaWQgMCA/IGRlZmF1bHRVc2VDb250cm9sbGVkU3RhdGUgOiBfcHJvcHMkdXNlQ29udHJvbGxlZFMsXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiaW5pdGlhbFN0YXRlXCIsIFwiZGVmYXVsdENvbHVtblwiLCBcImdldFN1YlJvd3NcIiwgXCJnZXRSb3dJZFwiLCBcInN0YXRlUmVkdWNlclwiLCBcInVzZUNvbnRyb2xsZWRTdGF0ZVwiXSk7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgZGVmYXVsdENvbHVtbjogZGVmYXVsdENvbHVtbixcbiAgICAgIGdldFN1YlJvd3M6IGdldFN1YlJvd3MsXG4gICAgICBnZXRSb3dJZDogZ2V0Um93SWQsXG4gICAgICBzdGF0ZVJlZHVjZXI6IHN0YXRlUmVkdWNlcixcbiAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZTogdXNlQ29udHJvbGxlZFN0YXRlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXNlVGFibGUgPSBmdW5jdGlvbiB1c2VUYWJsZShwcm9wcykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgcHJvcHNcbiAgICBwcm9wcyA9IGFwcGx5RGVmYXVsdHMocHJvcHMpOyAvLyBBZGQgY29yZSBwbHVnaW5zXG5cbiAgICBwbHVnaW5zID0gW3VzZUNvbHVtblZpc2liaWxpdHldLmNvbmNhdChwbHVnaW5zKTsgLy8gQ3JlYXRlIHRoZSB0YWJsZSBpbnN0YW5jZVxuXG4gICAgdmFyIGluc3RhbmNlUmVmID0gUmVhY3QudXNlUmVmKHt9KTsgLy8gQ3JlYXRlIGEgZ2V0dGVyIGZvciB0aGUgaW5zdGFuY2UgKGhlbHBzIGF2b2lkIGEgbG90IG9mIHBvdGVudGlhbCBtZW1vcnkgbGVha3MpXG5cbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2VSZWYuY3VycmVudCk7IC8vIEFzc2lnbiB0aGUgcHJvcHMsIHBsdWdpbnMgYW5kIGhvb2tzIHRvIHRoZSBpbnN0YW5jZVxuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHBsdWdpbnM6IHBsdWdpbnMsXG4gICAgICBob29rczogbWFrZURlZmF1bHRQbHVnaW5Ib29rcygpXG4gICAgfSkpOyAvLyBBbGxvdyBwbHVnaW5zIHRvIHJlZ2lzdGVyIGhvb2tzIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG5cbiAgICBwbHVnaW5zLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHBsdWdpbihnZXRJbnN0YW5jZSgpLmhvb2tzKTtcbiAgICB9KTsgLy8gQ29uc3VtZSBhbGwgaG9va3MgYW5kIG1ha2UgYSBnZXR0ZXIgZm9yIHRoZW1cblxuICAgIHZhciBnZXRIb29rcyA9IHVzZUdldExhdGVzdChnZXRJbnN0YW5jZSgpLmhvb2tzKTtcbiAgICBnZXRJbnN0YW5jZSgpLmdldEhvb2tzID0gZ2V0SG9va3M7XG4gICAgZGVsZXRlIGdldEluc3RhbmNlKCkuaG9va3M7IC8vIEFsbG93IHVzZU9wdGlvbnMgaG9va3MgdG8gbW9kaWZ5IHRoZSBvcHRpb25zIGNvbWluZyBpbnRvIHRoZSB0YWJsZVxuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCByZWR1Y2VIb29rcyhnZXRIb29rcygpLnVzZU9wdGlvbnMsIGFwcGx5RGVmYXVsdHMocHJvcHMpKSk7XG5cbiAgICB2YXIgX2dldEluc3RhbmNlID0gZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgZGF0YSA9IF9nZXRJbnN0YW5jZS5kYXRhLFxuICAgICAgICB1c2VyQ29sdW1ucyA9IF9nZXRJbnN0YW5jZS5jb2x1bW5zLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSBfZ2V0SW5zdGFuY2UuaW5pdGlhbFN0YXRlLFxuICAgICAgICBkZWZhdWx0Q29sdW1uID0gX2dldEluc3RhbmNlLmRlZmF1bHRDb2x1bW4sXG4gICAgICAgIGdldFN1YlJvd3MgPSBfZ2V0SW5zdGFuY2UuZ2V0U3ViUm93cyxcbiAgICAgICAgZ2V0Um93SWQgPSBfZ2V0SW5zdGFuY2UuZ2V0Um93SWQsXG4gICAgICAgIHN0YXRlUmVkdWNlciA9IF9nZXRJbnN0YW5jZS5zdGF0ZVJlZHVjZXIsXG4gICAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZSA9IF9nZXRJbnN0YW5jZS51c2VDb250cm9sbGVkU3RhdGU7IC8vIFNldHVwIHVzZXIgcmVkdWNlciByZWZcblxuXG4gICAgdmFyIGdldFN0YXRlUmVkdWNlciA9IHVzZUdldExhdGVzdChzdGF0ZVJlZHVjZXIpOyAvLyBCdWlsZCB0aGUgcmVkdWNlclxuXG4gICAgdmFyIHJlZHVjZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgLy8gRGV0ZWN0IGludmFsaWQgYWN0aW9uc1xuICAgICAgaWYgKCFhY3Rpb24udHlwZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gQWN0aW9uIPCfkYYnKTtcbiAgICAgIH0gLy8gUmVkdWNlIHRoZSBzdGF0ZSBmcm9tIGFsbCBwbHVnaW4gcmVkdWNlcnNcblxuXG4gICAgICByZXR1cm4gW10uY29uY2F0KGdldEhvb2tzKCkuc3RhdGVSZWR1Y2VycywgQXJyYXkuaXNBcnJheShnZXRTdGF0ZVJlZHVjZXIoKSkgPyBnZXRTdGF0ZVJlZHVjZXIoKSA6IFtnZXRTdGF0ZVJlZHVjZXIoKV0pLnJlZHVjZShmdW5jdGlvbiAocywgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihzLCBhY3Rpb24sIHN0YXRlLCBnZXRJbnN0YW5jZSgpKSB8fCBzO1xuICAgICAgfSwgc3RhdGUpO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0U3RhdGVSZWR1Y2VyLCBnZXRJbnN0YW5jZV0pOyAvLyBTdGFydCB0aGUgcmVkdWNlclxuXG4gICAgdmFyIF9SZWFjdCR1c2VSZWR1Y2VyID0gUmVhY3QudXNlUmVkdWNlcihyZWR1Y2VyLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VyKGluaXRpYWxTdGF0ZSwge1xuICAgICAgICB0eXBlOiBhY3Rpb25zLmluaXRcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgICAgICByZWR1Y2VyU3RhdGUgPSBfUmVhY3QkdXNlUmVkdWNlclswXSxcbiAgICAgICAgZGlzcGF0Y2ggPSBfUmVhY3QkdXNlUmVkdWNlclsxXTsgLy8gQWxsb3cgdGhlIHVzZXIgdG8gY29udHJvbCB0aGUgZmluYWwgc3RhdGUgd2l0aCBob29rc1xuXG5cbiAgICB2YXIgc3RhdGUgPSByZWR1Y2VIb29rcyhbXS5jb25jYXQoZ2V0SG9va3MoKS51c2VDb250cm9sbGVkU3RhdGUsIFt1c2VDb250cm9sbGVkU3RhdGVdKSwgcmVkdWNlclN0YXRlLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oZ2V0SW5zdGFuY2UoKSwge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgfSk7IC8vIERlY29yYXRlIEFsbCB0aGUgY29sdW1uc1xuXG4gICAgdmFyIGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaW5rQ29sdW1uU3RydWN0dXJlKHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuY29sdW1ucywgdXNlckNvbHVtbnMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pKTtcbiAgICB9LCBbZ2V0SG9va3MsIGdldEluc3RhbmNlLCB1c2VyQ29sdW1uc10uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuY29sdW1uc0RlcHMsIFtdLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pKSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5jb2x1bW5zID0gY29sdW1uczsgLy8gR2V0IHRoZSBmbGF0IGxpc3Qgb2YgYWxsIGNvbHVtbnMgYW5kIGFsbG93IGhvb2tzIHRvIGRlY29yYXRlXG4gICAgLy8gdGhvc2UgY29sdW1ucyAoYW5kIHRyaWdnZXIgdGhpcyBtZW1vaXphdGlvbiB2aWEgZGVwcylcblxuICAgIHZhciBhbGxDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVkdWNlSG9va3MoZ2V0SG9va3MoKS5hbGxDb2x1bW5zLCBmbGF0dGVuQ29sdW1ucyhjb2x1bW5zKSwge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSkubWFwKGFzc2lnbkNvbHVtbkFjY2Vzc29yKTtcbiAgICB9LCBbY29sdW1ucywgZ2V0SG9va3MsIGdldEluc3RhbmNlXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5hbGxDb2x1bW5zRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmFsbENvbHVtbnMgPSBhbGxDb2x1bW5zOyAvLyBBY2Nlc3MgdGhlIHJvdyBtb2RlbCB1c2luZyBpbml0aWFsIGNvbHVtbnNcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgIHZhciBmbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIHJvd3NCeUlkID0ge307XG4gICAgICB2YXIgYWxsQ29sdW1uc1F1ZXVlID0gW10uY29uY2F0KGFsbENvbHVtbnMpO1xuXG4gICAgICB3aGlsZSAoYWxsQ29sdW1uc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1uc1F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGFjY2Vzc1Jvd3NGb3JDb2x1bW4oe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgICBmbGF0Um93czogZmxhdFJvd3MsXG4gICAgICAgICAgcm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgIGdldFJvd0lkOiBnZXRSb3dJZCxcbiAgICAgICAgICBnZXRTdWJSb3dzOiBnZXRTdWJSb3dzLFxuICAgICAgICAgIGFjY2Vzc1ZhbHVlSG9va3M6IGdldEhvb2tzKCkuYWNjZXNzVmFsdWUsXG4gICAgICAgICAgZ2V0SW5zdGFuY2U6IGdldEluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgfSwgW2FsbENvbHVtbnMsIGRhdGEsIGdldFJvd0lkLCBnZXRTdWJSb3dzLCBnZXRIb29rcywgZ2V0SW5zdGFuY2VdKSxcbiAgICAgICAgcm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBmbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzFdLFxuICAgICAgICByb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCB7XG4gICAgICByb3dzOiByb3dzLFxuICAgICAgaW5pdGlhbFJvd3M6IFtdLmNvbmNhdChyb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiByb3dzQnlJZCAvLyBtYXRlcmlhbGl6ZWRDb2x1bW5zLFxuXG4gICAgfSk7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlSW5zdGFuY2VBZnRlckRhdGEsIGdldEluc3RhbmNlKCkpOyAvLyBHZXQgdGhlIGZsYXQgbGlzdCBvZiBhbGwgY29sdW1ucyBBRlRFUiB0aGUgcm93c1xuICAgIC8vIGhhdmUgYmVlbiBhY2Nlc3MsIGFuZCBhbGxvdyBob29rcyB0byBkZWNvcmF0ZVxuICAgIC8vIHRob3NlIGNvbHVtbnMgKGFuZCB0cmlnZ2VyIHRoaXMgbWVtb2l6YXRpb24gdmlhIGRlcHMpXG5cbiAgICB2YXIgdmlzaWJsZUNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLnZpc2libGVDb2x1bW5zLCBhbGxDb2x1bW5zLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlQ29sdW1uKGQsIGRlZmF1bHRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgfSwgW2dldEhvb2tzLCBhbGxDb2x1bW5zLCBnZXRJbnN0YW5jZSwgZGVmYXVsdENvbHVtbl0uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudmlzaWJsZUNvbHVtbnNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpOyAvLyBDb21iaW5lIG5ldyB2aXNpYmxlIGNvbHVtbnMgd2l0aCBhbGwgY29sdW1uc1xuXG4gICAgYWxsQ29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbHVtbnMgPSBbXS5jb25jYXQodmlzaWJsZUNvbHVtbnMpO1xuICAgICAgYWxsQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgaWYgKCFjb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH0sIFthbGxDb2x1bW5zLCB2aXNpYmxlQ29sdW1uc10pO1xuICAgIGdldEluc3RhbmNlKCkuYWxsQ29sdW1ucyA9IGFsbENvbHVtbnM7XG5cbiAgICB7XG4gICAgICB2YXIgZHVwbGljYXRlQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSkgIT09IGk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGR1cGxpY2F0ZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhhbGxDb2x1bW5zKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGNvbHVtbnMgd2VyZSBmb3VuZCB3aXRoIGlkczogXFxcIlwiICsgZHVwbGljYXRlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSkuam9pbignLCAnKSArIFwiXFxcIiBpbiB0aGUgY29sdW1ucyBhcnJheSBhYm92ZVwiKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgdGhlIGhlYWRlckdyb3Vwc1xuXG5cbiAgICB2YXIgaGVhZGVyR3JvdXBzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVkdWNlSG9va3MoZ2V0SG9va3MoKS5oZWFkZXJHcm91cHMsIG1ha2VIZWFkZXJHcm91cHModmlzaWJsZUNvbHVtbnMsIGRlZmF1bHRDb2x1bW4pLCBnZXRJbnN0YW5jZSgpKTtcbiAgICB9LCBbZ2V0SG9va3MsIHZpc2libGVDb2x1bW5zLCBkZWZhdWx0Q29sdW1uLCBnZXRJbnN0YW5jZV0uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuaGVhZGVyR3JvdXBzRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3VwczsgLy8gR2V0IHRoZSBmaXJzdCBsZXZlbCBvZiBoZWFkZXJzXG5cbiAgICB2YXIgaGVhZGVycyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5sZW5ndGggPyBoZWFkZXJHcm91cHNbMF0uaGVhZGVycyA6IFtdO1xuICAgIH0sIFtoZWFkZXJHcm91cHNdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmhlYWRlcnMgPSBoZWFkZXJzOyAvLyBQcm92aWRlIGEgZmxhdCBoZWFkZXIgbGlzdCBmb3IgdXRpbGl0aWVzXG5cbiAgICBnZXRJbnN0YW5jZSgpLmZsYXRIZWFkZXJzID0gaGVhZGVyR3JvdXBzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBoZWFkZXJHcm91cCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChhbGwsIGhlYWRlckdyb3VwLmhlYWRlcnMpO1xuICAgIH0sIFtdKTtcbiAgICBsb29wSG9va3MoZ2V0SG9va3MoKS51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMsIGdldEluc3RhbmNlKCkpOyAvLyBGaWx0ZXIgY29sdW1ucyBkb3duIHRvIHZpc2libGUgb25lc1xuXG4gICAgdmFyIHZpc2libGVDb2x1bW5zRGVwID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5pc1Zpc2libGU7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5pZDtcbiAgICB9KS5zb3J0KCkuam9pbignXycpO1xuICAgIHZpc2libGVDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlzVmlzaWJsZTtcbiAgICAgIH0pO1xuICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbdmlzaWJsZUNvbHVtbnMsIHZpc2libGVDb2x1bW5zRGVwXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS52aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zOyAvLyBIZWFkZXIgVmlzaWJpbGl0eSBpcyBuZWVkZWQgYnkgdGhpcyBwb2ludFxuXG4gICAgdmFyIF9jYWxjdWxhdGVIZWFkZXJXaWR0aCA9IGNhbGN1bGF0ZUhlYWRlcldpZHRocyhoZWFkZXJzKSxcbiAgICAgICAgdG90YWxDb2x1bW5zTWluV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGhbMF0sXG4gICAgICAgIHRvdGFsQ29sdW1uc1dpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoWzFdLFxuICAgICAgICB0b3RhbENvbHVtbnNNYXhXaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aFsyXTtcblxuICAgIGdldEluc3RhbmNlKCkudG90YWxDb2x1bW5zTWluV2lkdGggPSB0b3RhbENvbHVtbnNNaW5XaWR0aDtcbiAgICBnZXRJbnN0YW5jZSgpLnRvdGFsQ29sdW1uc1dpZHRoID0gdG90YWxDb2x1bW5zV2lkdGg7XG4gICAgZ2V0SW5zdGFuY2UoKS50b3RhbENvbHVtbnNNYXhXaWR0aCA9IHRvdGFsQ29sdW1uc01heFdpZHRoO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUluc3RhbmNlLCBnZXRJbnN0YW5jZSgpKSAvLyBFYWNoIG1hdGVyaWFsaXplZCBoZWFkZXIgbmVlZHMgdG8gYmUgYXNzaWduZWQgYSByZW5kZXIgZnVuY3Rpb24gYW5kIG90aGVyXG4gICAgLy8gcHJvcCBnZXR0ZXIgcHJvcGVydGllcyBoZXJlLlxuICAgIDtcbiAgICBbXS5jb25jYXQoZ2V0SW5zdGFuY2UoKS5mbGF0SGVhZGVycywgZ2V0SW5zdGFuY2UoKS5hbGxDb2x1bW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIHJlbmRlcmluZyBwb3dlclxuICAgICAgY29sdW1uLnJlbmRlciA9IG1ha2VSZW5kZXJlcihnZXRJbnN0YW5jZSgpLCBjb2x1bW4pOyAvLyBHaXZlIGNvbHVtbnMvaGVhZGVycyBhIGRlZmF1bHQgZ2V0SGVhZGVyUHJvcHNcblxuICAgICAgY29sdW1uLmdldEhlYWRlclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRIZWFkZXJQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pOyAvLyBHaXZlIGNvbHVtbnMvaGVhZGVycyBhIGRlZmF1bHQgZ2V0Rm9vdGVyUHJvcHNcblxuICAgICAgY29sdW1uLmdldEZvb3RlclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRGb290ZXJQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVyR3JvdXBzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyR3JvdXAsIGkpIHtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBhbnkgaGVhZGVycyBhbmQgaGVhZGVyR3JvdXBzIHRoYXQgZG9uJ3QgaGF2ZSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgaGVhZGVyR3JvdXAuaGVhZGVycyA9IGhlYWRlckdyb3VwLmhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIHJlY3Vyc2UoaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2UoY29sdW1uLmhlYWRlcnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5pc1Zpc2libGU7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChjb2x1bW4uaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2UoY29sdW1uLmhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb2x1bW4uaXNWaXNpYmxlO1xuICAgICAgICB9KTsgLy8gR2l2ZSBoZWFkZXJHcm91cHMgZ2V0Um93UHJvcHNcblxuICAgICAgICBpZiAoaGVhZGVyR3JvdXAuaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXJHcm91cC5nZXRIZWFkZXJHcm91cFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRIZWFkZXJHcm91cFByb3BzLCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIGhlYWRlckdyb3VwOiBoZWFkZXJHcm91cCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGVhZGVyR3JvdXAuZ2V0Rm9vdGVyR3JvdXBQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0Rm9vdGVyR3JvdXBQcm9wcywge1xuICAgICAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgICAgICBoZWFkZXJHcm91cDogaGVhZGVyR3JvdXAsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSwgW2hlYWRlckdyb3VwcywgZ2V0SW5zdGFuY2UsIGdldEhvb2tzXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5mb290ZXJHcm91cHMgPSBbXS5jb25jYXQoZ2V0SW5zdGFuY2UoKS5oZWFkZXJHcm91cHMpLnJldmVyc2UoKTsgLy8gVGhlIHByZXBhcmVSb3cgZnVuY3Rpb24gaXMgYWJzb2x1dGVseSBuZWNlc3NhcnkgYW5kIE1VU1QgYmUgY2FsbGVkIG9uXG4gICAgLy8gYW55IHJvd3MgdGhlIHVzZXIgd2lzaGVzIHRvIGJlIGRpc3BsYXllZC5cblxuICAgIGdldEluc3RhbmNlKCkucHJlcGFyZVJvdyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJvdy5nZXRSb3dQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0Um93UHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIHJvdzogcm93XG4gICAgICB9KTsgLy8gQnVpbGQgdGhlIHZpc2libGUgY2VsbHMgZm9yIGVhY2ggcm93XG5cbiAgICAgIHJvdy5hbGxDZWxscyA9IGFsbENvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTsgLy8gR2l2ZSBlYWNoIGNlbGwgYSBnZXRDZWxsUHJvcHMgYmFzZVxuXG4gICAgICAgIGNlbGwuZ2V0Q2VsbFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRDZWxsUHJvcHMsIHtcbiAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICBjZWxsOiBjZWxsXG4gICAgICAgIH0pOyAvLyBHaXZlIGVhY2ggY2VsbCBhIHJlbmRlcmVyIGZ1bmN0aW9uIChzdXBwb3J0cyBtdWx0aXBsZSByZW5kZXJlcnMpXG5cbiAgICAgICAgY2VsbC5yZW5kZXIgPSBtYWtlUmVuZGVyZXIoZ2V0SW5zdGFuY2UoKSwgY29sdW1uLCB7XG4gICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgY2VsbDogY2VsbCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgfSk7XG4gICAgICByb3cuY2VsbHMgPSB2aXNpYmxlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gcm93LmFsbENlbGxzLmZpbmQoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICByZXR1cm4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gbmVlZCB0byBhcHBseSBhbnkgcm93IHNwZWNpZmljIGhvb2tzICh1c2VFeHBhbmRlZCByZXF1aXJlcyB0aGlzKVxuXG4gICAgICBsb29wSG9va3MoZ2V0SG9va3MoKS5wcmVwYXJlUm93LCByb3csIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0SW5zdGFuY2UsIGFsbENvbHVtbnMsIHZpc2libGVDb2x1bW5zXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5nZXRUYWJsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRUYWJsZVByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIGdldEluc3RhbmNlKCkuZ2V0VGFibGVCb2R5UHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRhYmxlQm9keVByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUZpbmFsSW5zdGFuY2UsIGdldEluc3RhbmNlKCkpO1xuICAgIHJldHVybiBnZXRJbnN0YW5jZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUhlYWRlcldpZHRocyhoZWFkZXJzLCBsZWZ0KSB7XG4gICAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgICAgbGVmdCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHN1bVRvdGFsTWluV2lkdGggPSAwO1xuICAgIHZhciBzdW1Ub3RhbFdpZHRoID0gMDtcbiAgICB2YXIgc3VtVG90YWxNYXhXaWR0aCA9IDA7XG4gICAgdmFyIHN1bVRvdGFsRmxleFdpZHRoID0gMDtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgdmFyIHN1YkhlYWRlcnMgPSBoZWFkZXIuaGVhZGVycztcbiAgICAgIGhlYWRlci50b3RhbExlZnQgPSBsZWZ0O1xuXG4gICAgICBpZiAoc3ViSGVhZGVycyAmJiBzdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgX2NhbGN1bGF0ZUhlYWRlcldpZHRoMiA9IGNhbGN1bGF0ZUhlYWRlcldpZHRocyhzdWJIZWFkZXJzLCBsZWZ0KSxcbiAgICAgICAgICAgIHRvdGFsTWluV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzBdLFxuICAgICAgICAgICAgdG90YWxXaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aDJbMV0sXG4gICAgICAgICAgICB0b3RhbE1heFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlsyXSxcbiAgICAgICAgICAgIHRvdGFsRmxleFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlszXTtcblxuICAgICAgICBoZWFkZXIudG90YWxNaW5XaWR0aCA9IHRvdGFsTWluV2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbFdpZHRoID0gdG90YWxXaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWF4V2lkdGggPSB0b3RhbE1heFdpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxGbGV4V2lkdGggPSB0b3RhbEZsZXhXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlci50b3RhbE1pbldpZHRoID0gaGVhZGVyLm1pbldpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxXaWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGhlYWRlci5taW5XaWR0aCwgaGVhZGVyLndpZHRoKSwgaGVhZGVyLm1heFdpZHRoKTtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWF4V2lkdGggPSBoZWFkZXIubWF4V2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbEZsZXhXaWR0aCA9IGhlYWRlci5jYW5SZXNpemUgPyBoZWFkZXIudG90YWxXaWR0aCA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkZXIuaXNWaXNpYmxlKSB7XG4gICAgICAgIGxlZnQgKz0gaGVhZGVyLnRvdGFsV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsTWluV2lkdGggKz0gaGVhZGVyLnRvdGFsTWluV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsV2lkdGggKz0gaGVhZGVyLnRvdGFsV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsTWF4V2lkdGggKz0gaGVhZGVyLnRvdGFsTWF4V2lkdGg7XG4gICAgICAgIHN1bVRvdGFsRmxleFdpZHRoICs9IGhlYWRlci50b3RhbEZsZXhXaWR0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW3N1bVRvdGFsTWluV2lkdGgsIHN1bVRvdGFsV2lkdGgsIHN1bVRvdGFsTWF4V2lkdGgsIHN1bVRvdGFsRmxleFdpZHRoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2Vzc1Jvd3NGb3JDb2x1bW4oX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICByb3dzID0gX3JlZi5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IF9yZWYuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gX3JlZi5yb3dzQnlJZCxcbiAgICAgICAgY29sdW1uID0gX3JlZi5jb2x1bW4sXG4gICAgICAgIGdldFJvd0lkID0gX3JlZi5nZXRSb3dJZCxcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9yZWYuZ2V0U3ViUm93cyxcbiAgICAgICAgYWNjZXNzVmFsdWVIb29rcyA9IF9yZWYuYWNjZXNzVmFsdWVIb29rcyxcbiAgICAgICAgZ2V0SW5zdGFuY2UgPSBfcmVmLmdldEluc3RhbmNlO1xuXG4gICAgLy8gQWNjZXNzIHRoZSByb3cncyBkYXRhIGNvbHVtbi1ieS1jb2x1bW5cbiAgICAvLyBXZSBkbyBpdCB0aGlzIHdheSBzbyB3ZSBjYW4gaW5jcmVtZW50YWxseSBhZGQgbWF0ZXJpYWxpemVkXG4gICAgLy8gY29sdW1ucyBhZnRlciB0aGUgZmlyc3QgcGFzcyBhbmQgYXZvaWQgZXhjZXNzaXZlIGxvb3BpbmdcbiAgICB2YXIgYWNjZXNzUm93ID0gZnVuY3Rpb24gYWNjZXNzUm93KG9yaWdpbmFsUm93LCByb3dJbmRleCwgZGVwdGgsIHBhcmVudCwgcGFyZW50Um93cykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCByZWZlcmVuY2UgYXJvdW5kXG4gICAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbFJvdztcbiAgICAgIHZhciBpZCA9IGdldFJvd0lkKG9yaWdpbmFsUm93LCByb3dJbmRleCwgcGFyZW50KTtcbiAgICAgIHZhciByb3cgPSByb3dzQnlJZFtpZF07IC8vIElmIHRoZSByb3cgaGFzbid0IGJlZW4gY3JlYXRlZCwgbGV0J3MgbWFrZSBpdFxuXG4gICAgICBpZiAoIXJvdykge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9yaWdpbmFsOiBvcmlnaW5hbCxcbiAgICAgICAgICBpbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgIGNlbGxzOiBbe31dIC8vIFRoaXMgaXMgYSBkdW1teSBjZWxsXG5cbiAgICAgICAgfTsgLy8gT3ZlcnJpZGUgY29tbW9uIGFycmF5IGZ1bmN0aW9ucyAoYW5kIHRoZSBkdW1teSBjZWxsJ3MgZ2V0Q2VsbFByb3BzIGZ1bmN0aW9uKVxuICAgICAgICAvLyB0byBzaG93IGFuIGVycm9yIGlmIGl0IGlzIGFjY2Vzc2VkIHdpdGhvdXQgY2FsbGluZyBwcmVwYXJlUm93XG5cbiAgICAgICAgcm93LmNlbGxzLm1hcCA9IHVucHJlcGFyZWRBY2Nlc3NXYXJuaW5nO1xuICAgICAgICByb3cuY2VsbHMuZmlsdGVyID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxscy5mb3JFYWNoID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxsc1swXS5nZXRDZWxsUHJvcHMgPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZzsgLy8gQ3JlYXRlIHRoZSBjZWxscyBhbmQgdmFsdWVzXG5cbiAgICAgICAgcm93LnZhbHVlcyA9IHt9OyAvLyBQdXNoIHRoaXMgcm93IGludG8gdGhlIHBhcmVudFJvd3MgYXJyYXlcblxuICAgICAgICBwYXJlbnRSb3dzLnB1c2gocm93KTsgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG5cbiAgICAgICAgZmxhdFJvd3MucHVzaChyb3cpOyAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGJ5IGl0cyBJRFxuXG4gICAgICAgIHJvd3NCeUlkW2lkXSA9IHJvdzsgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG5cbiAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IGdldFN1YlJvd3Mob3JpZ2luYWxSb3csIHJvd0luZGV4KTsgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuXG4gICAgICAgIGlmIChyb3cub3JpZ2luYWxTdWJSb3dzKSB7XG4gICAgICAgICAgdmFyIHN1YlJvd3MgPSBbXTtcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NSb3coZCwgaSwgZGVwdGggKyAxLCByb3csIHN1YlJvd3MpO1xuICAgICAgICAgIH0pOyAvLyBLZWVwIHRoZSBuZXcgc3ViUm93cyBhcnJheSBvbiB0aGUgcm93XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHN1YlJvd3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJvdyBleGlzdHMsIHRoZW4gaXQncyBhbHJlYWR5IGJlZW4gYWNjZXNzZWRcbiAgICAgICAgLy8gS2VlcCByZWN1cnNpbmcsIGJ1dCBkb24ndCB3b3JyeSBhYm91dCBwYXNzaW5nIHRoZVxuICAgICAgICAvLyBhY2N1bWxhdG9yIGFycmF5ICh0aG9zZSByb3dzIGFscmVhZHkgZXhpc3QpXG4gICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBhY2Nlc3NSb3coZCwgaSwgZGVwdGggKyAxLCByb3cpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlIGNvbHVtbiBoYXMgYW4gYWNjZXNzb3IsIHVzZSBpdCB0byBnZXQgYSB2YWx1ZVxuXG5cbiAgICAgIGlmIChjb2x1bW4uYWNjZXNzb3IpIHtcbiAgICAgICAgcm93LnZhbHVlc1tjb2x1bW4uaWRdID0gY29sdW1uLmFjY2Vzc29yKG9yaWdpbmFsUm93LCByb3dJbmRleCwgcm93LCBwYXJlbnRSb3dzLCBkYXRhKTtcbiAgICAgIH0gLy8gQWxsb3cgcGx1Z2lucyB0byBtYW5pcHVsYXRlIHRoZSBjb2x1bW4gdmFsdWVcblxuXG4gICAgICByb3cudmFsdWVzW2NvbHVtbi5pZF0gPSByZWR1Y2VIb29rcyhhY2Nlc3NWYWx1ZUhvb2tzLCByb3cudmFsdWVzW2NvbHVtbi5pZF0sIHtcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luYWxSb3csIHJvd0luZGV4KSB7XG4gICAgICByZXR1cm4gYWNjZXNzUm93KG9yaWdpbmFsUm93LCByb3dJbmRleCwgMCwgdW5kZWZpbmVkLCByb3dzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRFeHBhbmRlZCA9ICdyZXNldEV4cGFuZGVkJztcbiAgYWN0aW9ucy50b2dnbGVSb3dFeHBhbmRlZCA9ICd0b2dnbGVSb3dFeHBhbmRlZCc7XG4gIGFjdGlvbnMudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gJ3RvZ2dsZUFsbFJvd3NFeHBhbmRlZCc7XG4gIHZhciB1c2VFeHBhbmRlZCA9IGZ1bmN0aW9uIHVzZUV4cGFuZGVkKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzXTtcbiAgICBob29rcy5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzXTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQxKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDEpO1xuICAgIGhvb2tzLnByZXBhcmVSb3cucHVzaChwcmVwYXJlUm93KTtcbiAgfTtcbiAgdXNlRXhwYW5kZWQucGx1Z2luTmFtZSA9ICd1c2VFeHBhbmRlZCc7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIFJvd3MgRXhwYW5kZWQnXG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIHJvdyA9IF9yZWYyLnJvdztcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICByb3cudG9nZ2xlUm93RXhwYW5kZWQoKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFJvdyBFeHBhbmRlZCdcbiAgICB9XTtcbiAgfTsgLy8gUmVkdWNlclxuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQxKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGV4cGFuZGVkOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEV4cGFuZGVkKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGV4cGFuZGVkOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZXhwYW5kZWQgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkO1xuICAgICAgdmFyIGlzQWxsUm93c0V4cGFuZGVkID0gT2JqZWN0LmtleXMocm93c0J5SWQpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoc3RhdGUuZXhwYW5kZWQpLmxlbmd0aDtcbiAgICAgIHZhciBleHBhbmRBbGwgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNBbGxSb3dzRXhwYW5kZWQ7XG5cbiAgICAgIGlmIChleHBhbmRBbGwpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIGV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGV4cGFuZGVkOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkKSB7XG4gICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgc2V0RXhwYW5kZWQgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgZXhpc3RzID0gc3RhdGUuZXhwYW5kZWRbaWRdO1xuICAgICAgdmFyIHNob3VsZEV4aXN0ID0gdHlwZW9mIHNldEV4cGFuZGVkICE9PSAndW5kZWZpbmVkJyA/IHNldEV4cGFuZGVkIDogIWV4aXN0cztcblxuICAgICAgaWYgKCFleGlzdHMgJiYgc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZXhwYW5kZWQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5leHBhbmRlZCwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbaWRdID0gdHJ1ZSwgX2V4dGVuZHMyKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0cyAmJiAhc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRleHBhbmRlZCA9IHN0YXRlLmV4cGFuZGVkLFxuICAgICAgICAgICAgXyA9IF9zdGF0ZSRleHBhbmRlZFtpZF0sXG4gICAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3N0YXRlJGV4cGFuZGVkLCBbaWRdLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogcmVzdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQxKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgX2luc3RhbmNlJG1hbnVhbEV4cGFuID0gaW5zdGFuY2UubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbEV4cGFuID09PSB2b2lkIDAgPyAnZXhwYW5kZWQnIDogX2luc3RhbmNlJG1hbnVhbEV4cGFuLFxuICAgICAgICBfaW5zdGFuY2UkcGFnaW5hdGVFeHAgPSBpbnN0YW5jZS5wYWdpbmF0ZUV4cGFuZGVkUm93cyxcbiAgICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3MgPSBfaW5zdGFuY2UkcGFnaW5hdGVFeHAgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkcGFnaW5hdGVFeHAsXG4gICAgICAgIF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9IGluc3RhbmNlLmV4cGFuZFN1YlJvd3MsXG4gICAgICAgIGV4cGFuZFN1YlJvd3MgPSBfaW5zdGFuY2UkZXhwYW5kU3ViUm8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkZXhwYW5kU3ViUm8sXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRFeCA9IGluc3RhbmNlLmF1dG9SZXNldEV4cGFuZGVkLFxuICAgICAgICBhdXRvUmVzZXRFeHBhbmRlZCA9IF9pbnN0YW5jZSRhdXRvUmVzZXRFeCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRFeCxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGV4cGFuZGVkID0gaW5zdGFuY2Uuc3RhdGUuZXhwYW5kZWQsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VTb3J0QnknLCAndXNlR3JvdXBCeScsICd1c2VQaXZvdENvbHVtbnMnLCAndXNlR2xvYmFsRmlsdGVyJ10sICd1c2VFeHBhbmRlZCcpO1xuICAgIHZhciBnZXRBdXRvUmVzZXRFeHBhbmRlZCA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRFeHBhbmRlZCk7XG4gICAgdmFyIGlzQWxsUm93c0V4cGFuZGVkID0gQm9vbGVhbihPYmplY3Qua2V5cyhyb3dzQnlJZCkubGVuZ3RoICYmIE9iamVjdC5rZXlzKGV4cGFuZGVkKS5sZW5ndGgpO1xuXG4gICAgaWYgKGlzQWxsUm93c0V4cGFuZGVkKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocm93c0J5SWQpLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiAhZXhwYW5kZWRbaWRdO1xuICAgICAgfSkpIHtcbiAgICAgICAgaXNBbGxSb3dzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIEJ5cGFzcyBhbnkgZWZmZWN0cyBmcm9tIGZpcmluZyB3aGVuIHRoaXMgY2hhbmdlc1xuXG5cbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRFeHBhbmRlZCgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0RXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBkYXRhXSk7XG4gICAgdmFyIHRvZ2dsZVJvd0V4cGFuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGV4cGFuZGVkUm93cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRSb3dzKHJvd3MsIHtcbiAgICAgICAgICBtYW51YWxFeHBhbmRlZEtleTogbWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkLFxuICAgICAgICAgIGV4cGFuZFN1YlJvd3M6IGV4cGFuZFN1YlJvd3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH0sIFtwYWdpbmF0ZUV4cGFuZGVkUm93cywgcm93cywgbWFudWFsRXhwYW5kZWRLZXksIGV4cGFuZGVkLCBleHBhbmRTdWJSb3dzXSk7XG4gICAgdmFyIGV4cGFuZGVkRGVwdGggPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaW5kRXhwYW5kZWREZXB0aChleHBhbmRlZCk7XG4gICAgfSwgW2V4cGFuZGVkXSk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICB2YXIgZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHByZUV4cGFuZGVkUm93czogcm93cyxcbiAgICAgIGV4cGFuZGVkUm93czogZXhwYW5kZWRSb3dzLFxuICAgICAgcm93czogZXhwYW5kZWRSb3dzLFxuICAgICAgZXhwYW5kZWREZXB0aDogZXhwYW5kZWREZXB0aCxcbiAgICAgIGlzQWxsUm93c0V4cGFuZGVkOiBpc0FsbFJvd3NFeHBhbmRlZCxcbiAgICAgIHRvZ2dsZVJvd0V4cGFuZGVkOiB0b2dnbGVSb3dFeHBhbmRlZCxcbiAgICAgIHRvZ2dsZUFsbFJvd3NFeHBhbmRlZDogdG9nZ2xlQWxsUm93c0V4cGFuZGVkLFxuICAgICAgZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHM6IGdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93KHJvdywgX3JlZjMpIHtcbiAgICB2YXIgZ2V0SG9va3MgPSBfcmVmMy5pbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcblxuICAgIHJvdy50b2dnbGVSb3dFeHBhbmRlZCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVSb3dFeHBhbmRlZChyb3cuaWQsIHNldCk7XG4gICAgfTtcblxuICAgIHJvdy5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICByb3c6IHJvd1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEV4cGFuZGVkRGVwdGgoZXhwYW5kZWQpIHtcbiAgICB2YXIgbWF4RGVwdGggPSAwO1xuICAgIE9iamVjdC5rZXlzKGV4cGFuZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXhEZXB0aDtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcm93cyA9IHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiBTdHJpbmcocm93VmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoU3RyaW5nKGZpbHRlclZhbHVlKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByb3dzO1xuICB9O1xuXG4gIHRleHQuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbDtcbiAgfTtcblxuICB2YXIgZXhhY3RUZXh0ID0gZnVuY3Rpb24gZXhhY3RUZXh0KHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlICE9PSB1bmRlZmluZWQgPyBTdHJpbmcocm93VmFsdWUpLnRvTG93ZXJDYXNlKCkgPT09IFN0cmluZyhmaWx0ZXJWYWx1ZSkudG9Mb3dlckNhc2UoKSA6IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdFRleHQuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbDtcbiAgfTtcblxuICB2YXIgZXhhY3RUZXh0Q2FzZSA9IGZ1bmN0aW9uIGV4YWN0VGV4dENhc2Uocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhyb3dWYWx1ZSkgPT09IFN0cmluZyhmaWx0ZXJWYWx1ZSkgOiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhhY3RUZXh0Q2FzZS5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlLmluY2x1ZGVzKGZpbHRlclZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzQWxsID0gZnVuY3Rpb24gaW5jbHVkZXNBbGwocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgJiYgcm93VmFsdWUubGVuZ3RoICYmIGZpbHRlclZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gcm93VmFsdWUuaW5jbHVkZXModmFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsIHx8ICF2YWwubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlc1NvbWUgPSBmdW5jdGlvbiBpbmNsdWRlc1NvbWUocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgJiYgcm93VmFsdWUubGVuZ3RoICYmIGZpbHRlclZhbHVlLnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiByb3dWYWx1ZS5pbmNsdWRlcyh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsIHx8ICF2YWwubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlc1ZhbHVlID0gZnVuY3Rpb24gaW5jbHVkZXNWYWx1ZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiBmaWx0ZXJWYWx1ZS5pbmNsdWRlcyhyb3dWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpbmNsdWRlc1ZhbHVlLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGV4YWN0ID0gZnVuY3Rpb24gZXhhY3Qocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgPT09IGZpbHRlclZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhhY3QuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG4gIH07XG5cbiAgdmFyIGVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuICAgICAgICByZXR1cm4gcm93VmFsdWUgPT0gZmlsdGVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBlcXVhbHMuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGw7XG4gIH07XG5cbiAgdmFyIGJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICB2YXIgX3JlZiA9IGZpbHRlclZhbHVlIHx8IFtdLFxuICAgICAgICBtaW4gPSBfcmVmWzBdLFxuICAgICAgICBtYXggPSBfcmVmWzFdO1xuXG4gICAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ251bWJlcicgPyBtaW4gOiAtSW5maW5pdHk7XG4gICAgbWF4ID0gdHlwZW9mIG1heCA9PT0gJ251bWJlcicgPyBtYXggOiBJbmZpbml0eTtcblxuICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgIHZhciB0ZW1wID0gbWluO1xuICAgICAgbWluID0gbWF4O1xuICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBiZXR3ZWVuLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgdHlwZW9mIHZhbFswXSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbFsxXSAhPT0gJ251bWJlcic7XG4gIH07XG5cbiAgdmFyIGZpbHRlclR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGV4YWN0VGV4dDogZXhhY3RUZXh0LFxuICAgIGV4YWN0VGV4dENhc2U6IGV4YWN0VGV4dENhc2UsXG4gICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgIGluY2x1ZGVzQWxsOiBpbmNsdWRlc0FsbCxcbiAgICBpbmNsdWRlc1NvbWU6IGluY2x1ZGVzU29tZSxcbiAgICBpbmNsdWRlc1ZhbHVlOiBpbmNsdWRlc1ZhbHVlLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBlcXVhbHM6IGVxdWFscyxcbiAgICBiZXR3ZWVuOiBiZXR3ZWVuXG4gIH0pO1xuXG4gIGFjdGlvbnMucmVzZXRGaWx0ZXJzID0gJ3Jlc2V0RmlsdGVycyc7XG4gIGFjdGlvbnMuc2V0RmlsdGVyID0gJ3NldEZpbHRlcic7XG4gIGFjdGlvbnMuc2V0QWxsRmlsdGVycyA9ICdzZXRBbGxGaWx0ZXJzJztcbiAgdmFyIHVzZUZpbHRlcnMgPSBmdW5jdGlvbiB1c2VGaWx0ZXJzKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkMik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQyKTtcbiAgfTtcbiAgdXNlRmlsdGVycy5wbHVnaW5OYW1lID0gJ3VzZUZpbHRlcnMnO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkMihzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBmaWx0ZXJzOiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEZpbHRlcnMpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZmlsdGVyczogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmZpbHRlcnMgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRGaWx0ZXIpIHtcbiAgICAgIHZhciBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGFjdGlvbi5maWx0ZXJWYWx1ZTtcbiAgICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcztcbiAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LVRhYmxlOiBDb3VsZCBub3QgZmluZCBhIGNvbHVtbiB3aXRoIGlkOiBcIiArIGNvbHVtbklkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChjb2x1bW4uZmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMgfHwge30sIGZpbHRlclR5cGVzKTtcbiAgICAgIHZhciBwcmV2aW91c2ZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKGZpbHRlclZhbHVlLCBwcmV2aW91c2ZpbHRlciAmJiBwcmV2aW91c2ZpbHRlci52YWx1ZSk7IC8vXG5cbiAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlck1ldGhvZC5hdXRvUmVtb3ZlLCBuZXdGaWx0ZXIsIGNvbHVtbikpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCAhPT0gY29sdW1uSWQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aW91c2ZpbHRlcikge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW5JZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGZpbHRlcnM6IFtdLmNvbmNhdChzdGF0ZS5maWx0ZXJzLCBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH1dKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEFsbEZpbHRlcnMpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gYWN0aW9uLmZpbHRlcnM7XG4gICAgICB2YXIgX2FsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIF91c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcztcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgLy8gRmlsdGVyIG91dCB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGZpbHRlcnM6IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVycywgc3RhdGUuZmlsdGVycykuZmlsdGVyKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgY29sdW1uID0gX2FsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGZpbHRlci5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoY29sdW1uLmZpbHRlciwgX3VzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyTWV0aG9kLmF1dG9SZW1vdmUsIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkMihpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcyxcbiAgICAgICAgbWFudWFsRmlsdGVycyA9IGluc3RhbmNlLm1hbnVhbEZpbHRlcnMsXG4gICAgICAgIF9pbnN0YW5jZSRkZWZhdWx0Q2FuRiA9IGluc3RhbmNlLmRlZmF1bHRDYW5GaWx0ZXIsXG4gICAgICAgIGRlZmF1bHRDYW5GaWx0ZXIgPSBfaW5zdGFuY2UkZGVmYXVsdENhbkYgPT09IHZvaWQgMCA/IGZhbHNlIDogX2luc3RhbmNlJGRlZmF1bHRDYW5GLFxuICAgICAgICBkaXNhYmxlRmlsdGVycyA9IGluc3RhbmNlLmRpc2FibGVGaWx0ZXJzLFxuICAgICAgICBmaWx0ZXJzID0gaW5zdGFuY2Uuc3RhdGUuZmlsdGVycyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEZpID0gaW5zdGFuY2UuYXV0b1Jlc2V0RmlsdGVycyxcbiAgICAgICAgYXV0b1Jlc2V0RmlsdGVycyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRGaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRGaTtcbiAgICB2YXIgc2V0RmlsdGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEZpbHRlcixcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICBmaWx0ZXJWYWx1ZTogZmlsdGVyVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBzZXRBbGxGaWx0ZXJzID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpbHRlcnMpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRBbGxGaWx0ZXJzLFxuICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGlkID0gY29sdW1uLmlkLFxuICAgICAgICAgIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGNvbHVtbkRlZmF1bHRDYW5GaWx0ZXIgPSBjb2x1bW4uZGVmYXVsdENhbkZpbHRlcixcbiAgICAgICAgICBjb2x1bW5EaXNhYmxlRmlsdGVycyA9IGNvbHVtbi5kaXNhYmxlRmlsdGVyczsgLy8gRGV0ZXJtaW5lIGlmIGEgY29sdW1uIGlzIGZpbHRlcmFibGVcblxuICAgICAgY29sdW1uLmNhbkZpbHRlciA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRpc2FibGVGaWx0ZXJzID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVGaWx0ZXJzID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRlZmF1bHRDYW5GaWx0ZXIsIGRlZmF1bHRDYW5GaWx0ZXIsIGZhbHNlKTsgLy8gUHJvdmlkZSB0aGUgY29sdW1uIGEgd2F5IG9mIHVwZGF0aW5nIHRoZSBmaWx0ZXIgdmFsdWVcblxuICAgICAgY29sdW1uLnNldEZpbHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcihjb2x1bW4uaWQsIHZhbCk7XG4gICAgICB9OyAvLyBQcm92aWRlIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZSB0byB0aGUgY29sdW1uIGZvclxuICAgICAgLy8gY29udmVuaWVuY2VcblxuXG4gICAgICB2YXIgZm91bmQgPSBmaWx0ZXJzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uZmlsdGVyVmFsdWUgPSBmb3VuZCAmJiBmb3VuZC52YWx1ZTtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEZpbHRlcnMgfHwgIWZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBmaWx0ZXJlZFJvd3NCeUlkID0ge307IC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuXG4gICAgICB2YXIgZmlsdGVyUm93cyA9IGZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyZWRSb3dzID0gcm93cztcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gZmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKGZpbHRlcmVkU29GYXIsIF9yZWYpIHtcbiAgICAgICAgICB2YXIgY29sdW1uSWQgPSBfcmVmLmlkLFxuICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlsdGVycyBjb2x1bW5cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkU29GYXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb2x1bW4ucHJlRmlsdGVyZWRSb3dzID0gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGNvbHVtbi5maWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICAgICAgaWYgKCFmaWx0ZXJNZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2NvbHVtbi5maWx0ZXInIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6IFwiICsgY29sdW1uLmlkICsgXCIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkU29GYXI7XG4gICAgICAgICAgfSAvLyBQYXNzIHRoZSByb3dzLCBpZCwgZmlsdGVyVmFsdWUgYW5kIGNvbHVtbiB0byB0aGUgZmlsdGVyTWV0aG9kXG4gICAgICAgICAgLy8gdG8gZ2V0IHRoZSBmaWx0ZXJlZCByb3dzIGJhY2tcblxuXG4gICAgICAgICAgY29sdW1uLmZpbHRlcmVkUm93cyA9IGZpbHRlck1ldGhvZChmaWx0ZXJlZFNvRmFyLCBbY29sdW1uSWRdLCBmaWx0ZXJWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbi5maWx0ZXJlZFJvd3M7XG4gICAgICAgIH0sIHJvd3MpOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXG4gICAgICAgIC8vIFdlIHRlY2huaWNhbGx5IGNvdWxkIGRvIHRoaXMgcmVjdXJzaXZlbHkgaW4gdGhlIGFib3ZlIGxvb3AsXG4gICAgICAgIC8vIGJ1dCB0aGF0IHdvdWxkIHNldmVyZWx5IGhpbmRlciB0aGUgQVBJIGZvciB0aGUgdXNlciwgc2luY2UgdGhleVxuICAgICAgICAvLyB3b3VsZCBiZSByZXF1aXJlZCB0byBkbyB0aGF0IHJlY3Vyc2lvbiBpbiBzb21lIHNjZW5hcmlvc1xuXG4gICAgICAgIGZpbHRlcmVkUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBmaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG5cbiAgICAgICAgICBpZiAoIXJvdy5zdWJSb3dzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93LnN1YlJvd3MgPSByb3cuc3ViUm93cyAmJiByb3cuc3ViUm93cy5sZW5ndGggPiAwID8gZmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKSA6IHJvdy5zdWJSb3dzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBbZmlsdGVyUm93cyhyb3dzKSwgZmlsdGVyZWRGbGF0Um93cywgZmlsdGVyZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEZpbHRlcnMsIGZpbHRlcnMsIHJvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgYWxsQ29sdW1ucywgdXNlckZpbHRlclR5cGVzXSksXG4gICAgICAgIGZpbHRlcmVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIGZpbHRlcmVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXTtcblxuICAgIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTm93IHRoYXQgZWFjaCBmaWx0ZXJlZCBjb2x1bW4gaGFzIGl0J3MgcGFydGlhbGx5IGZpbHRlcmVkIHJvd3MsXG4gICAgICAvLyBsZXRzIGFzc2lnbiB0aGUgZmluYWwgZmlsdGVyZWQgcm93cyB0byBhbGwgb2YgdGhlIG90aGVyIGNvbHVtbnNcbiAgICAgIHZhciBub25GaWx0ZXJlZENvbHVtbnMgPSBhbGxDb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiAhZmlsdGVycy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gVGhpcyBlc3NlbnRpYWxseSBlbmFibGVzIGZhY2V0ZWQgZmlsdGVyIG9wdGlvbnMgdG8gYmUgYnVpbHQgZWFzaWx5XG4gICAgICAvLyB1c2luZyBldmVyeSBjb2x1bW4ncyBwcmVGaWx0ZXJlZFJvd3MgdmFsdWVcblxuICAgICAgbm9uRmlsdGVyZWRDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBjb2x1bW4ucHJlRmlsdGVyZWRSb3dzID0gZmlsdGVyZWRSb3dzO1xuICAgICAgICBjb2x1bW4uZmlsdGVyZWRSb3dzID0gZmlsdGVyZWRSb3dzO1xuICAgICAgfSk7XG4gICAgfSwgW2ZpbHRlcmVkUm93cywgZmlsdGVycywgYWxsQ29sdW1uc10pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRGaWx0ZXJzID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEZpbHRlcnMpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEZpbHRlcnMoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEZpbHRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW51YWxGaWx0ZXJzID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVGaWx0ZXJlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVGaWx0ZXJlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHByZUZpbHRlcmVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZmlsdGVyZWRSb3dzOiBmaWx0ZXJlZFJvd3MsXG4gICAgICBmaWx0ZXJlZEZsYXRSb3dzOiBmaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgZmlsdGVyZWRSb3dzQnlJZDogZmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGZpbHRlcmVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBmaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGZpbHRlcmVkUm93c0J5SWQsXG4gICAgICBzZXRGaWx0ZXI6IHNldEZpbHRlcixcbiAgICAgIHNldEFsbEZpbHRlcnM6IHNldEFsbEZpbHRlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRHbG9iYWxGaWx0ZXIgPSAncmVzZXRHbG9iYWxGaWx0ZXInO1xuICBhY3Rpb25zLnNldEdsb2JhbEZpbHRlciA9ICdzZXRHbG9iYWxGaWx0ZXInO1xuICB2YXIgdXNlR2xvYmFsRmlsdGVyID0gZnVuY3Rpb24gdXNlR2xvYmFsRmlsdGVyKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkMyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQzKTtcbiAgfTtcbiAgdXNlR2xvYmFsRmlsdGVyLnBsdWdpbk5hbWUgPSAndXNlR2xvYmFsRmlsdGVyJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJDMoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRHbG9iYWxGaWx0ZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZ2xvYmFsRmlsdGVyIHx8IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEdsb2JhbEZpbHRlcikge1xuICAgICAgdmFyIGZpbHRlclZhbHVlID0gYWN0aW9uLmZpbHRlclZhbHVlO1xuICAgICAgdmFyIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLnVzZXJGaWx0ZXJUeXBlcztcbiAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoaW5zdGFuY2UuZ2xvYmFsRmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMgfHwge30sIGZpbHRlclR5cGVzKTtcbiAgICAgIHZhciBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKGZpbHRlclZhbHVlLCBzdGF0ZS5nbG9iYWxGaWx0ZXIpOyAvL1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJNZXRob2QuYXV0b1JlbW92ZSwgbmV3RmlsdGVyKSkge1xuICAgICAgICB2YXIgZ2xvYmFsRmlsdGVyID0gc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICAgICAgc3RhdGVXaXRob3V0R2xvYmFsRmlsdGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc3RhdGUsIFtcImdsb2JhbEZpbHRlclwiXSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlV2l0aG91dEdsb2JhbEZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBnbG9iYWxGaWx0ZXI6IG5ld0ZpbHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkMyhpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcyxcbiAgICAgICAgZ2xvYmFsRmlsdGVyID0gaW5zdGFuY2UuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBtYW51YWxHbG9iYWxGaWx0ZXIgPSBpbnN0YW5jZS5tYW51YWxHbG9iYWxGaWx0ZXIsXG4gICAgICAgIGdsb2JhbEZpbHRlclZhbHVlID0gaW5zdGFuY2Uuc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0R2wgPSBpbnN0YW5jZS5hdXRvUmVzZXRHbG9iYWxGaWx0ZXIsXG4gICAgICAgIGF1dG9SZXNldEdsb2JhbEZpbHRlciA9IF9pbnN0YW5jZSRhdXRvUmVzZXRHbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRHbCxcbiAgICAgICAgZGlzYWJsZUdsb2JhbEZpbHRlciA9IGluc3RhbmNlLmRpc2FibGVHbG9iYWxGaWx0ZXI7XG4gICAgdmFyIHNldEdsb2JhbEZpbHRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChmaWx0ZXJWYWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEdsb2JhbEZpbHRlcixcbiAgICAgICAgZmlsdGVyVmFsdWU6IGZpbHRlclZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTsgLy8gVE9ETzogQ3JlYXRlIGEgZmlsdGVyIGNhY2hlIGZvciBpbmNyZW1lbnRhbCBoaWdoIHNwZWVkIG11bHRpLWZpbHRlcmluZ1xuICAgIC8vIFRoaXMgZ2V0cyBwcmV0dHkgY29tcGxpY2F0ZWQgcHJldHR5IGZhc3QsIHNpbmNlIHlvdSBoYXZlIHRvIG1haW50YWluIGFcbiAgICAvLyBjYWNoZSBmb3IgZWFjaCByb3cgZ3JvdXAgKHRvcC1sZXZlbCByb3dzLCBhbmQgZWFjaCByb3cncyByZWN1cnNpdmUgc3Vicm93cylcbiAgICAvLyBUaGlzIHdvdWxkIG1ha2UgbXVsdGktZmlsdGVyaW5nIGEgbG90IGZhc3RlciB0aG91Z2guIFRvbyBmYXI/XG5cbiAgICB2YXIgX1JlYWN0JHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtYW51YWxHbG9iYWxGaWx0ZXIgfHwgdHlwZW9mIGdsb2JhbEZpbHRlclZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgZmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChnbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICBpZiAoIWZpbHRlck1ldGhvZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkICdnbG9iYWxGaWx0ZXInIG9wdGlvbi5cIik7XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgICAgfVxuXG4gICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgY29sdW1uRGlzYWJsZUdsb2JhbEZpbHRlciA9IGNvbHVtbi5kaXNhYmxlR2xvYmFsRmlsdGVyO1xuICAgICAgICBjb2x1bW4uY2FuRmlsdGVyID0gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRpc2FibGVHbG9iYWxGaWx0ZXIgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUdsb2JhbEZpbHRlciA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZpbHRlcmFibGVDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMuY2FuRmlsdGVyID09PSB0cnVlO1xuICAgICAgfSk7IC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuXG4gICAgICB2YXIgZmlsdGVyUm93cyA9IGZ1bmN0aW9uIGZpbHRlclJvd3MoZmlsdGVyZWRSb3dzKSB7XG4gICAgICAgIGZpbHRlcmVkUm93cyA9IGZpbHRlck1ldGhvZChmaWx0ZXJlZFJvd3MsIGZpbHRlcmFibGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkO1xuICAgICAgICB9KSwgZ2xvYmFsRmlsdGVyVmFsdWUpO1xuICAgICAgICBmaWx0ZXJlZFJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgZmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgZmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIHJvdy5zdWJSb3dzID0gcm93LnN1YlJvd3MgJiYgcm93LnN1YlJvd3MubGVuZ3RoID8gZmlsdGVyUm93cyhyb3cuc3ViUm93cykgOiByb3cuc3ViUm93cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFJvd3M7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gW2ZpbHRlclJvd3Mocm93cyksIGZpbHRlcmVkRmxhdFJvd3MsIGZpbHRlcmVkUm93c0J5SWRdO1xuICAgIH0sIFttYW51YWxHbG9iYWxGaWx0ZXIsIGdsb2JhbEZpbHRlclZhbHVlLCBnbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcywgYWxsQ29sdW1ucywgcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBkaXNhYmxlR2xvYmFsRmlsdGVyXSksXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRHbG9iYWxGaWx0ZXIgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0R2xvYmFsRmlsdGVyKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRHbG9iYWxGaWx0ZXIoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbEdsb2JhbEZpbHRlciA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiByb3dzLFxuICAgICAgcHJlR2xvYmFsRmlsdGVyZWRGbGF0Um93czogZmxhdFJvd3MsXG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3NCeUlkOiByb3dzQnlJZCxcbiAgICAgIGdsb2JhbEZpbHRlcmVkUm93czogZ2xvYmFsRmlsdGVyZWRSb3dzLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRGbGF0Um93czogZ2xvYmFsRmlsdGVyZWRGbGF0Um93cyxcbiAgICAgIGdsb2JhbEZpbHRlcmVkUm93c0J5SWQ6IGdsb2JhbEZpbHRlcmVkUm93c0J5SWQsXG4gICAgICByb3dzOiBnbG9iYWxGaWx0ZXJlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ2xvYmFsRmlsdGVyZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBnbG9iYWxGaWx0ZXJlZFJvd3NCeUlkLFxuICAgICAgc2V0R2xvYmFsRmlsdGVyOiBzZXRHbG9iYWxGaWx0ZXIsXG4gICAgICBkaXNhYmxlR2xvYmFsRmlsdGVyOiBkaXNhYmxlR2xvYmFsRmlsdGVyXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdW0odmFsdWVzLCBhZ2dyZWdhdGVkVmFsdWVzKSB7XG4gICAgLy8gSXQncyBmYXN0ZXIgdG8ganVzdCBhZGQgdGhlIGFnZ3JlZ2F0aW9ucyB0b2dldGhlciBpbnN0ZWFkIG9mXG4gICAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICAgIHJldHVybiBhZ2dyZWdhdGVkVmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBuZXh0KSB7XG4gICAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0ID09PSAnbnVtYmVyJyA/IG5leHQgOiAwKTtcbiAgICB9LCAwKTtcbiAgfVxuICBmdW5jdGlvbiBtaW4odmFsdWVzKSB7XG4gICAgdmFyIG1pbiA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBmdW5jdGlvbiBtYXgodmFsdWVzKSB7XG4gICAgdmFyIG1heCA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBmdW5jdGlvbiBtaW5NYXgodmFsdWVzKSB7XG4gICAgdmFyIG1pbiA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhciBtYXggPSB2YWx1ZXNbMF0gfHwgMDtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWUpO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWluICsgXCIuLlwiICsgbWF4O1xuICB9XG4gIGZ1bmN0aW9uIGF2ZXJhZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIHN1bShudWxsLCB2YWx1ZXMpIC8gdmFsdWVzLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBtZWRpYW4odmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgdmFyIG51bXMgPSBbXS5jb25jYXQodmFsdWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiB1bmlxdWUodmFsdWVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpLnZhbHVlcygpKTtcbiAgfVxuICBmdW5jdGlvbiB1bmlxdWVDb3VudCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpLnNpemU7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgYWdncmVnYXRpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzdW06IHN1bSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBtaW5NYXg6IG1pbk1heCxcbiAgICBhdmVyYWdlOiBhdmVyYWdlLFxuICAgIG1lZGlhbjogbWVkaWFuLFxuICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgIHVuaXF1ZUNvdW50OiB1bmlxdWVDb3VudCxcbiAgICBjb3VudDogY291bnRcbiAgfSk7XG5cbiAgdmFyIGVtcHR5QXJyYXkgPSBbXTtcbiAgdmFyIGVtcHR5T2JqZWN0ID0ge307IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLnJlc2V0R3JvdXBCeSA9ICdyZXNldEdyb3VwQnknO1xuICBhY3Rpb25zLnNldEdyb3VwQnkgPSAnc2V0R3JvdXBCeSc7XG4gIGFjdGlvbnMudG9nZ2xlR3JvdXBCeSA9ICd0b2dnbGVHcm91cEJ5JztcbiAgdmFyIHVzZUdyb3VwQnkgPSBmdW5jdGlvbiB1c2VHcm91cEJ5KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gW2RlZmF1bHRHZXRHcm91cEJ5VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDQpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeV0pO1xuICAgIH0pO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zLnB1c2godmlzaWJsZUNvbHVtbnMpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNCk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMSk7XG4gIH07XG4gIHVzZUdyb3VwQnkucGx1Z2luTmFtZSA9ICd1c2VHcm91cEJ5JztcblxuICB2YXIgZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRHcm91cEJ5VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGhlYWRlciA9IF9yZWYyLmhlYWRlcjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBoZWFkZXIuY2FuR3JvdXBCeSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBoZWFkZXIudG9nZ2xlR3JvdXBCeSgpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogaGVhZGVyLmNhbkdyb3VwQnkgPyAncG9pbnRlcicgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBHcm91cEJ5J1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDQoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZ3JvdXBCeTogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRHcm91cEJ5KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5ncm91cEJ5IHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0R3JvdXBCeSkge1xuICAgICAgdmFyIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncm91cEJ5OiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUdyb3VwQnkpIHtcbiAgICAgIHZhciBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBzZXRHcm91cEJ5ID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJlc29sdmVkR3JvdXBCeSA9IHR5cGVvZiBzZXRHcm91cEJ5ICE9PSAndW5kZWZpbmVkJyA/IHNldEdyb3VwQnkgOiAhc3RhdGUuZ3JvdXBCeS5pbmNsdWRlcyhjb2x1bW5JZCk7XG5cbiAgICAgIGlmIChyZXNvbHZlZEdyb3VwQnkpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGdyb3VwQnk6IFtdLmNvbmNhdChzdGF0ZS5ncm91cEJ5LCBbY29sdW1uSWRdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncm91cEJ5OiBzdGF0ZS5ncm91cEJ5LmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zKGNvbHVtbnMsIF9yZWYzKSB7XG4gICAgdmFyIGdyb3VwQnkgPSBfcmVmMy5pbnN0YW5jZS5zdGF0ZS5ncm91cEJ5O1xuICAgIC8vIFNvcnQgZ3JvdXBlZCBjb2x1bW5zIHRvIHRoZSBzdGFydCBvZiB0aGUgY29sdW1uIGxpc3RcbiAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XG4gICAgdmFyIGdyb3VwQnlDb2x1bW5zID0gZ3JvdXBCeS5tYXAoZnVuY3Rpb24gKGcpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICByZXR1cm4gY29sLmlkID09PSBnO1xuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHZhciBub25Hcm91cEJ5Q29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgIHJldHVybiAhZ3JvdXBCeS5pbmNsdWRlcyhjb2wuaWQpO1xuICAgIH0pO1xuICAgIGNvbHVtbnMgPSBbXS5jb25jYXQoZ3JvdXBCeUNvbHVtbnMsIG5vbkdyb3VwQnlDb2x1bW5zKTtcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzR3JvdXBlZCA9IGdyb3VwQnkuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIGNvbHVtbi5ncm91cGVkSW5kZXggPSBncm91cEJ5LmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHZhciBkZWZhdWx0VXNlckFnZ3JlZ2F0aW9ucyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDQoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IGluc3RhbmNlLmZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgX2luc3RhbmNlJGdyb3VwQnlGbiA9IGluc3RhbmNlLmdyb3VwQnlGbixcbiAgICAgICAgZ3JvdXBCeUZuID0gX2luc3RhbmNlJGdyb3VwQnlGbiA9PT0gdm9pZCAwID8gZGVmYXVsdEdyb3VwQnlGbiA6IF9pbnN0YW5jZSRncm91cEJ5Rm4sXG4gICAgICAgIG1hbnVhbEdyb3VwQnkgPSBpbnN0YW5jZS5tYW51YWxHcm91cEJ5LFxuICAgICAgICBfaW5zdGFuY2UkYWdncmVnYXRpb24gPSBpbnN0YW5jZS5hZ2dyZWdhdGlvbnMsXG4gICAgICAgIHVzZXJBZ2dyZWdhdGlvbnMgPSBfaW5zdGFuY2UkYWdncmVnYXRpb24gPT09IHZvaWQgMCA/IGRlZmF1bHRVc2VyQWdncmVnYXRpb25zIDogX2luc3RhbmNlJGFnZ3JlZ2F0aW9uLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZ3JvdXBCeSA9IGluc3RhbmNlLnN0YXRlLmdyb3VwQnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRHciA9IGluc3RhbmNlLmF1dG9SZXNldEdyb3VwQnksXG4gICAgICAgIGF1dG9SZXNldEdyb3VwQnkgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0R3IgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0R3IsXG4gICAgICAgIGRpc2FibGVHcm91cEJ5ID0gaW5zdGFuY2UuZGlzYWJsZUdyb3VwQnksXG4gICAgICAgIGRlZmF1bHRDYW5Hcm91cEJ5ID0gaW5zdGFuY2UuZGVmYXVsdENhbkdyb3VwQnksXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3M7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VDb2x1bW5PcmRlcicsICd1c2VGaWx0ZXJzJ10sICd1c2VHcm91cEJ5Jyk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5Hcm91cEJ5ID0gY29sdW1uLmRlZmF1bHRHcm91cEJ5LFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVHcm91cEJ5ID0gY29sdW1uLmRpc2FibGVHcm91cEJ5O1xuICAgICAgY29sdW1uLmNhbkdyb3VwQnkgPSBhY2Nlc3NvciA/IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuR3JvdXBCeSwgY29sdW1uRGlzYWJsZUdyb3VwQnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUdyb3VwQnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoY29sdW1uLmNhbkdyb3VwQnksIGRlZmF1bHRDb2x1bW5Hcm91cEJ5LCBkZWZhdWx0Q2FuR3JvdXBCeSwgZmFsc2UpO1xuXG4gICAgICBpZiAoY29sdW1uLmNhbkdyb3VwQnkpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZUdyb3VwQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZUdyb3VwQnkoY29sdW1uLmlkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29sdW1uLkFnZ3JlZ2F0ZWQgPSBjb2x1bW4uQWdncmVnYXRlZCB8fCBjb2x1bW4uQ2VsbDtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlR3JvdXBCeSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVHcm91cEJ5LFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEdyb3VwQnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRHcm91cEJ5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgaGVhZGVyLmdldEdyb3VwQnlUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgX1JlYWN0JHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtYW51YWxHcm91cEJ5IHx8ICFncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IHRoZSBsaXN0IG9mIGZpbHRlcmVkIGNvbHVtbnMgZXhpc3RcblxuXG4gICAgICB2YXIgZXhpc3RpbmdHcm91cEJ5ID0gZ3JvdXBCeS5maWx0ZXIoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbC5pZCA9PT0gZztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gRmluZCB0aGUgY29sdW1ucyB0aGF0IGNhbiBvciBhcmUgYWdncmVnYXRpbmdcbiAgICAgIC8vIFVzZXMgZWFjaCBjb2x1bW4gdG8gYWdncmVnYXRlIHJvd3MgaW50byBhIHNpbmdsZSB2YWx1ZVxuXG4gICAgICB2YXIgYWdncmVnYXRlUm93c1RvVmFsdWVzID0gZnVuY3Rpb24gYWdncmVnYXRlUm93c1RvVmFsdWVzKGxlYWZSb3dzLCBncm91cGVkUm93cywgZGVwdGgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cEJ5XG4gICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBCeS5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IGdyb3VwZWRSb3dzWzBdID8gZ3JvdXBlZFJvd3NbMF0udmFsdWVzW2NvbHVtbi5pZF0gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcblxuXG4gICAgICAgICAgdmFyIGFnZ3JlZ2F0ZUZuID0gdHlwZW9mIGNvbHVtbi5hZ2dyZWdhdGUgPT09ICdmdW5jdGlvbicgPyBjb2x1bW4uYWdncmVnYXRlIDogdXNlckFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlXSB8fCBhZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZV07XG5cbiAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29sdW1uVmFsdWVzIHRvIGFnZ3JlZ2F0ZVxuICAgICAgICAgICAgdmFyIGdyb3VwZWRWYWx1ZXMgPSBncm91cGVkUm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuICAgICAgICAgICAgfSk7IC8vIEdldCB0aGUgY29sdW1uVmFsdWVzIHRvIGFnZ3JlZ2F0ZVxuXG4gICAgICAgICAgICB2YXIgbGVhZlZhbHVlcyA9IGxlYWZSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHZhciBjb2x1bW5WYWx1ZSA9IHJvdy52YWx1ZXNbY29sdW1uLmlkXTtcblxuICAgICAgICAgICAgICBpZiAoIWRlcHRoICYmIGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhZ2dyZWdhdGVWYWx1ZUZuID0gdHlwZW9mIGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSA6IHVzZXJBZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlXSB8fCBhZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlXTtcblxuICAgICAgICAgICAgICAgIGlmICghYWdncmVnYXRlVmFsdWVGbikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IEludmFsaWQgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlIG9wdGlvbiBmb3IgY29sdW1uIGxpc3RlZCBhYm92ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5WYWx1ZSA9IGFnZ3JlZ2F0ZVZhbHVlRm4oY29sdW1uVmFsdWUsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5WYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWVzW2NvbHVtbi5pZF0gPSBhZ2dyZWdhdGVGbihsZWFmVmFsdWVzLCBncm91cGVkVmFsdWVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IFRhYmxlOiBJbnZhbGlkIGNvbHVtbi5hZ2dyZWdhdGUgb3B0aW9uIGZvciBjb2x1bW4gbGlzdGVkIGFib3ZlXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH07XG5cbiAgICAgIHZhciBncm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBncm91cGVkUm93c0J5SWQgPSB7fTtcbiAgICAgIHZhciBvbmx5R3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgb25seUdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIG5vbkdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIG5vbkdyb3VwZWRSb3dzQnlJZCA9IHt9OyAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuXG4gICAgICB2YXIgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgbGV2ZWwsIGp1c3QgcmV0dXJuIHRoZSByb3dzXG4gICAgICAgIGlmIChkZXB0aCA9PT0gZXhpc3RpbmdHcm91cEJ5Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJvdywge1xuICAgICAgICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbklkID0gZXhpc3RpbmdHcm91cEJ5W2RlcHRoXTsgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcblxuICAgICAgICB2YXIgcm93R3JvdXBzTWFwID0gZ3JvdXBCeUZuKHJvd3MsIGNvbHVtbklkKTsgLy8gUGVmb3JtIGFnZ3JlZ2F0aW9ucyBmb3IgZWFjaCBncm91cFxuXG4gICAgICAgIHZhciBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBPYmplY3QuZW50cmllcyhyb3dHcm91cHNNYXApLm1hcChmdW5jdGlvbiAoX3JlZjQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGdyb3VwQnlWYWwgPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgZ3JvdXBlZFJvd3MgPSBfcmVmNFsxXTtcbiAgICAgICAgICB2YXIgaWQgPSBjb2x1bW5JZCArIFwiOlwiICsgZ3JvdXBCeVZhbDtcbiAgICAgICAgICBpZCA9IHBhcmVudElkID8gcGFyZW50SWQgKyBcIj5cIiArIGlkIDogaWQ7IC8vIEZpcnN0LCBSZWN1cnNlIHRvIGdyb3VwIHN1YiByb3dzIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gICAgICAgICAgdmFyIHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpOyAvLyBGbGF0dGVuIHRoZSBsZWFmIHJvd3Mgb2YgdGhlIHJvd3MgaW4gdGhpcyBncm91cFxuXG4gICAgICAgICAgdmFyIGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsICdsZWFmUm93cycpIDogZ3JvdXBlZFJvd3M7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IGFnZ3JlZ2F0ZVJvd3NUb1ZhbHVlcyhsZWFmUm93cywgZ3JvdXBlZFJvd3MsIGRlcHRoKTtcbiAgICAgICAgICB2YXIgcm93ID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgaXNHcm91cGVkOiB0cnVlLFxuICAgICAgICAgICAgZ3JvdXBCeUlEOiBjb2x1bW5JZCxcbiAgICAgICAgICAgIGdyb3VwQnlWYWw6IGdyb3VwQnlWYWwsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgIHN1YlJvd3M6IHN1YlJvd3MsXG4gICAgICAgICAgICBsZWFmUm93czogbGVhZlJvd3MsXG4gICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG5cbiAgICAgICAgICAgIGlmIChzdWJSb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHZhciBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dzKTtcbiAgICAgIGdyb3VwZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHN1YlJvdykge1xuICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcblxuICAgICAgICBpZiAoc3ViUm93LmlzR3JvdXBlZCkge1xuICAgICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQXNzaWduIHRoZSBuZXcgZGF0YVxuXG4gICAgICByZXR1cm4gW2dyb3VwZWRSb3dzLCBncm91cGVkRmxhdFJvd3MsIGdyb3VwZWRSb3dzQnlJZCwgb25seUdyb3VwZWRGbGF0Um93cywgb25seUdyb3VwZWRSb3dzQnlJZCwgbm9uR3JvdXBlZEZsYXRSb3dzLCBub25Hcm91cGVkUm93c0J5SWRdO1xuICAgIH0sIFttYW51YWxHcm91cEJ5LCBncm91cEJ5LCByb3dzLCBmbGF0Um93cywgcm93c0J5SWQsIGFsbENvbHVtbnMsIHVzZXJBZ2dyZWdhdGlvbnMsIGdyb3VwQnlGbl0pLFxuICAgICAgICBncm91cGVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBncm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZ3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bMl0sXG4gICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1szXSxcbiAgICAgICAgb25seUdyb3VwZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzRdLFxuICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1s1XSxcbiAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bNl07XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0R3JvdXBCeSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRHcm91cEJ5KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRHcm91cEJ5KCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRHcm91cEJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsR3JvdXBCeSA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlR3JvdXBlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVHcm91cGVkRmxhdFJvdzogZmxhdFJvd3MsXG4gICAgICBwcmVHcm91cGVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZ3JvdXBlZFJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZ3JvdXBlZEZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICBncm91cGVkUm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3M6IG9ubHlHcm91cGVkRmxhdFJvd3MsXG4gICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkOiBvbmx5R3JvdXBlZFJvd3NCeUlkLFxuICAgICAgbm9uR3JvdXBlZEZsYXRSb3dzOiBub25Hcm91cGVkRmxhdFJvd3MsXG4gICAgICBub25Hcm91cGVkUm93c0J5SWQ6IG5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBncm91cGVkUm93c0J5SWQsXG4gICAgICB0b2dnbGVHcm91cEJ5OiB0b2dnbGVHcm91cEJ5LFxuICAgICAgc2V0R3JvdXBCeTogc2V0R3JvdXBCeVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQxKHJvdykge1xuICAgIHJvdy5hbGxDZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuXG4gICAgICAvLyBHcm91cGVkIGNlbGxzIGFyZSBpbiB0aGUgZ3JvdXBCeSBhbmQgdGhlIHBpdm90IGNlbGwgZm9yIHRoZSByb3dcbiAgICAgIGNlbGwuaXNHcm91cGVkID0gY2VsbC5jb2x1bW4uaXNHcm91cGVkICYmIGNlbGwuY29sdW1uLmlkID09PSByb3cuZ3JvdXBCeUlEOyAvLyBQbGFjZWhvbGRlciBjZWxscyBhcmUgYW55IGNvbHVtbnMgaW4gdGhlIGdyb3VwQnkgdGhhdCBhcmUgbm90IGdyb3VwZWRcblxuICAgICAgY2VsbC5pc1BsYWNlaG9sZGVyID0gIWNlbGwuaXNHcm91cGVkICYmIGNlbGwuY29sdW1uLmlzR3JvdXBlZDsgLy8gQWdncmVnYXRlZCBjZWxscyBhcmUgbm90IGdyb3VwZWQsIG5vdCByZXBlYXRlZCwgYnV0IHN0aWxsIGhhdmUgc3ViUm93c1xuXG4gICAgICBjZWxsLmlzQWdncmVnYXRlZCA9ICFjZWxsLmlzR3JvdXBlZCAmJiAhY2VsbC5pc1BsYWNlaG9sZGVyICYmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRHcm91cEJ5Rm4ocm93cywgY29sdW1uSWQpIHtcbiAgICByZXR1cm4gcm93cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHJvdywgaSkge1xuICAgICAgLy8gVE9ETzogTWlnaHQgd2FudCB0byBpbXBsZW1lbnQgYSBrZXkgc2VyaWFsaXplciBoZXJlIHNvXG4gICAgICAvLyBpcnJlZ3VsYXIgY29sdW1uIHZhbHVlcyBjYW4gc3RpbGwgYmUgZ3JvdXBlZCBpZiBuZWVkZWQ/XG4gICAgICB2YXIgcmVzS2V5ID0gXCJcIiArIHJvdy52YWx1ZXNbY29sdW1uSWRdO1xuICAgICAgcHJldltyZXNLZXldID0gQXJyYXkuaXNBcnJheShwcmV2W3Jlc0tleV0pID8gcHJldltyZXNLZXldIDogW107XG4gICAgICBwcmV2W3Jlc0tleV0ucHVzaChyb3cpO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgdmFyIHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ207IC8vIE1peGVkIHNvcnRpbmcgaXMgc2xvdywgYnV0IHZlcnkgaW5jbHVzaXZlIG9mIG1hbnkgZWRnZSBjYXNlcy5cbiAgLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuICAvLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuXG4gIHZhciBhbHBoYW51bWVyaWMgPSBmdW5jdGlvbiBhbHBoYW51bWVyaWMocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uID0gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3dBLCByb3dCLCBjb2x1bW5JZCksXG4gICAgICAgIGEgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW5bMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW5bMV07IC8vIEZvcmNlIHRvIHN0cmluZ3MgKG9yIFwiXCIgZm9yIHVuc3VwcG9ydGVkIHR5cGVzKVxuXG5cbiAgICBhID0gdG9TdHJpbmcoYSk7XG4gICAgYiA9IHRvU3RyaW5nKGIpOyAvLyBTcGxpdCBvbiBudW1iZXIgZ3JvdXBzLCBidXQga2VlcCB0aGUgZGVsaW1pdGVyXG4gICAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuXG4gICAgYSA9IGEuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGIgPSBiLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTsgLy8gV2hpbGVcblxuICAgIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgICAgdmFyIGFhID0gYS5zaGlmdCgpO1xuICAgICAgdmFyIGJiID0gYi5zaGlmdCgpO1xuICAgICAgdmFyIGFuID0gcGFyc2VJbnQoYWEsIDEwKTtcbiAgICAgIHZhciBibiA9IHBhcnNlSW50KGJiLCAxMCk7XG4gICAgICB2YXIgY29tYm8gPSBbYW4sIGJuXS5zb3J0KCk7IC8vIEJvdGggYXJlIHN0cmluZ1xuXG4gICAgICBpZiAoaXNOYU4oY29tYm9bMF0pKSB7XG4gICAgICAgIGlmIChhYSA+IGJiKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuXG5cbiAgICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGFuKSA/IC0xIDogMTtcbiAgICAgIH0gLy8gQm90aCBhcmUgbnVtYmVyc1xuXG5cbiAgICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm4gPiBhbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIH07XG4gIGZ1bmN0aW9uIGRhdGV0aW1lKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjIgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjJbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW4yWzFdO1xuXG4gICAgYSA9IGEuZ2V0VGltZSgpO1xuICAgIGIgPSBiLmdldFRpbWUoKTtcbiAgICByZXR1cm4gY29tcGFyZUJhc2ljKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGJhc2ljKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjMgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjNbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW4zWzFdO1xuXG4gICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhhLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmcocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uNCA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNFswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjRbMV07XG5cbiAgICBhID0gYS5zcGxpdCgnJykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGIgPSBiLnNwbGl0KCcnKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICAgIHZhciBhYSA9IGEuc2hpZnQoKTtcbiAgICAgIHZhciBiYiA9IGIuc2hpZnQoKTtcbiAgICAgIHZhciBhbG93ZXIgPSBhYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGJsb3dlciA9IGJiLnRvTG93ZXJDYXNlKCk7IC8vIENhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiB1bnRpbCBjaGFyYWN0ZXJzIG1hdGNoXG5cbiAgICAgIGlmIChhbG93ZXIgPiBibG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG93ZXIgPiBhbG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBJZiBsb3dlcmNhc2UgY2hhcmFjdGVycyBhcmUgaWRlbnRpY2FsXG5cblxuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjUgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjVbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW41WzFdO1xuXG4gICAgdmFyIHJlcGxhY2VOb25OdW1lcmljID0gL1teMC05Ll0vZ2k7XG4gICAgYSA9IE51bWJlcihTdHJpbmcoYSkucmVwbGFjZShyZXBsYWNlTm9uTnVtZXJpYywgJycpKTtcbiAgICBiID0gTnVtYmVyKFN0cmluZyhiKS5yZXBsYWNlKHJlcGxhY2VOb25OdW1lcmljLCAnJykpO1xuICAgIHJldHVybiBjb21wYXJlQmFzaWMoYSwgYik7XG4gIH0gLy8gVXRpbHNcblxuICBmdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3cxLCByb3cyLCBjb2x1bW5JZCkge1xuICAgIHJldHVybiBbcm93MS52YWx1ZXNbY29sdW1uSWRdLCByb3cyLnZhbHVlc1tjb2x1bW5JZF1dO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBzb3J0VHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFscGhhbnVtZXJpYzogYWxwaGFudW1lcmljLFxuICAgIGRhdGV0aW1lOiBkYXRldGltZSxcbiAgICBiYXNpYzogYmFzaWMsXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSk7XG5cbiAgYWN0aW9ucy5yZXNldFNvcnRCeSA9ICdyZXNldFNvcnRCeSc7XG4gIGFjdGlvbnMuc2V0U29ydEJ5ID0gJ3NldFNvcnRCeSc7XG4gIGFjdGlvbnMudG9nZ2xlU29ydEJ5ID0gJ3RvZ2dsZVNvcnRCeSc7XG4gIGFjdGlvbnMuY2xlYXJTb3J0QnkgPSAnY2xlYXJTb3J0QnknO1xuICBkZWZhdWx0Q29sdW1uLnNvcnRUeXBlID0gJ2FscGhhbnVtZXJpYyc7XG4gIGRlZmF1bHRDb2x1bW4uc29ydERlc2NGaXJzdCA9IGZhbHNlO1xuICB2YXIgdXNlU29ydEJ5ID0gZnVuY3Rpb24gdXNlU29ydEJ5KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0U29ydEJ5VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldFNvcnRCeVRvZ2dsZVByb3BzXTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ1KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDUpO1xuICB9O1xuICB1c2VTb3J0QnkucGx1Z2luTmFtZSA9ICd1c2VTb3J0QnknO1xuXG4gIHZhciBkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICB2YXIgX2luc3RhbmNlJGlzTXVsdGlTb3J0ID0gaW5zdGFuY2UuaXNNdWx0aVNvcnRFdmVudCxcbiAgICAgICAgaXNNdWx0aVNvcnRFdmVudCA9IF9pbnN0YW5jZSRpc011bHRpU29ydCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgIH0gOiBfaW5zdGFuY2UkaXNNdWx0aVNvcnQ7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogY29sdW1uLmNhblNvcnQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRCeSh1bmRlZmluZWQsICFpbnN0YW5jZS5kaXNhYmxlTXVsdGlTb3J0ICYmIGlzTXVsdGlTb3J0RXZlbnQoZSkpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogY29sdW1uLmNhblNvcnQgPyAncG9pbnRlcicgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB0aXRsZTogY29sdW1uLmNhblNvcnQgPyAnVG9nZ2xlIFNvcnRCeScgOiB1bmRlZmluZWRcbiAgICB9XTtcbiAgfTsgLy8gUmVkdWNlclxuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ1KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHNvcnRCeTogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRTb3J0QnkpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuc29ydEJ5IHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY2xlYXJTb3J0QnkpIHtcbiAgICAgIHZhciBzb3J0QnkgPSBzdGF0ZS5zb3J0Qnk7XG4gICAgICB2YXIgbmV3U29ydEJ5ID0gc29ydEJ5LmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCAhPT0gYWN0aW9uLmNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNvcnRCeTogbmV3U29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0U29ydEJ5KSB7XG4gICAgICB2YXIgX3NvcnRCeSA9IGFjdGlvbi5zb3J0Qnk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNvcnRCeTogX3NvcnRCeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVNvcnRCeSkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGRlc2MgPSBhY3Rpb24uZGVzYyxcbiAgICAgICAgICBtdWx0aSA9IGFjdGlvbi5tdWx0aTtcbiAgICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgICBkaXNhYmxlTXVsdGlTb3J0ID0gaW5zdGFuY2UuZGlzYWJsZU11bHRpU29ydCxcbiAgICAgICAgICBkaXNhYmxlU29ydFJlbW92ZSA9IGluc3RhbmNlLmRpc2FibGVTb3J0UmVtb3ZlLFxuICAgICAgICAgIGRpc2FibGVNdWx0aVJlbW92ZSA9IGluc3RhbmNlLmRpc2FibGVNdWx0aVJlbW92ZSxcbiAgICAgICAgICBfaW5zdGFuY2UkbWF4TXVsdGlTb3IgPSBpbnN0YW5jZS5tYXhNdWx0aVNvcnRDb2xDb3VudCxcbiAgICAgICAgICBtYXhNdWx0aVNvcnRDb2xDb3VudCA9IF9pbnN0YW5jZSRtYXhNdWx0aVNvciA9PT0gdm9pZCAwID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiBfaW5zdGFuY2UkbWF4TXVsdGlTb3I7XG4gICAgICB2YXIgX3NvcnRCeTIgPSBzdGF0ZS5zb3J0Qnk7IC8vIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhpcyBjb2x1bW5JZFxuXG4gICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnREZXNjRmlyc3QgPSBjb2x1bW4uc29ydERlc2NGaXJzdDsgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydEJ5IGZvciB0aGlzIGNvbHVtblxuXG4gICAgICB2YXIgZXhpc3RpbmdTb3J0QnkgPSBfc29ydEJ5Mi5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IF9zb3J0QnkyLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGhhc0Rlc2NEZWZpbmVkID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB2YXIgX25ld1NvcnRCeSA9IFtdOyAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG5cbiAgICAgIHZhciBzb3J0QWN0aW9uO1xuXG4gICAgICBpZiAoIWRpc2FibGVNdWx0aVNvcnQgJiYgbXVsdGkpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nU29ydEJ5KSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggIT09IF9zb3J0QnkyLmxlbmd0aCAtIDEgfHwgX3NvcnRCeTIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1NvcnRCeSkge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9XG4gICAgICB9IC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRCeVxuXG5cbiAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJyAmJiAvLyBNdXN0IGJlIHRvZ2dsaW5nXG4gICAgICAhZGlzYWJsZVNvcnRSZW1vdmUgJiYgLy8gSWYgZGlzYWJsZVNvcnRSZW1vdmUsIGRpc2FibGUgaW4gZ2VuZXJhbFxuICAgICAgIWhhc0Rlc2NEZWZpbmVkICYmICggLy8gTXVzdCBub3QgYmUgc2V0dGluZyBkZXNjXG4gICAgICBtdWx0aSA/ICFkaXNhYmxlTXVsdGlSZW1vdmUgOiB0cnVlKSAmJiAoIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBkaXNhYmxlTXVsdGlSZW1vdmVcbiAgICAgIGV4aXN0aW5nU29ydEJ5ICYmIC8vIEZpbmFsbHksIGRldGVjdCBpZiBpdCBzaG91bGQgaW5kZWVkIGJlIHJlbW92ZWRcbiAgICAgIGV4aXN0aW5nU29ydEJ5LmRlc2MgJiYgIXNvcnREZXNjRmlyc3QgfHwgIWV4aXN0aW5nU29ydEJ5LmRlc2MgJiYgc29ydERlc2NGaXJzdCkpIHtcbiAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgIF9uZXdTb3J0QnkgPSBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiBzb3J0RGVzY0ZpcnN0XG4gICAgICAgIH1dO1xuICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICBfbmV3U29ydEJ5ID0gW10uY29uY2F0KF9zb3J0QnkyLCBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiBzb3J0RGVzY0ZpcnN0XG4gICAgICAgIH1dKTsgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXG5cbiAgICAgICAgX25ld1NvcnRCeS5zcGxpY2UoMCwgX25ld1NvcnRCeS5sZW5ndGggLSBtYXhNdWx0aVNvcnRDb2xDb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICBfbmV3U29ydEJ5ID0gX3NvcnRCeTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGQsIHtcbiAgICAgICAgICAgICAgZGVzYzogaGFzRGVzY0RlZmluZWQgPyBkZXNjIDogIWV4aXN0aW5nU29ydEJ5LmRlc2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgX25ld1NvcnRCeSA9IF9zb3J0QnkyLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBfbmV3U29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ1KGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIF9pbnN0YW5jZSRvcmRlckJ5Rm4gPSBpbnN0YW5jZS5vcmRlckJ5Rm4sXG4gICAgICAgIG9yZGVyQnlGbiA9IF9pbnN0YW5jZSRvcmRlckJ5Rm4gPT09IHZvaWQgMCA/IGRlZmF1bHRPcmRlckJ5Rm4gOiBfaW5zdGFuY2Ukb3JkZXJCeUZuLFxuICAgICAgICB1c2VyU29ydFR5cGVzID0gaW5zdGFuY2Uuc29ydFR5cGVzLFxuICAgICAgICBtYW51YWxTb3J0QnkgPSBpbnN0YW5jZS5tYW51YWxTb3J0QnksXG4gICAgICAgIGRlZmF1bHRDYW5Tb3J0ID0gaW5zdGFuY2UuZGVmYXVsdENhblNvcnQsXG4gICAgICAgIGRpc2FibGVTb3J0QnkgPSBpbnN0YW5jZS5kaXNhYmxlU29ydEJ5LFxuICAgICAgICBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBzb3J0QnkgPSBpbnN0YW5jZS5zdGF0ZS5zb3J0QnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0U28gPSBpbnN0YW5jZS5hdXRvUmVzZXRTb3J0QnksXG4gICAgICAgIGF1dG9SZXNldFNvcnRCeSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRTbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRTbztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUZpbHRlcnMnLCAndXNlR2xvYmFsRmlsdGVyJywgJ3VzZUdyb3VwQnknLCAndXNlUGl2b3RDb2x1bW5zJ10sICd1c2VTb3J0QnknKTtcbiAgICB2YXIgc2V0U29ydEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNvcnRCeSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldFNvcnRCeSxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnlcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyBVcGRhdGVzIHNvcnRpbmcgYmFzZWQgb24gYSBjb2x1bW5JZCwgZGVzYyBmbGFnIGFuZCBtdWx0aSBmbGFnXG5cbiAgICB2YXIgdG9nZ2xlU29ydEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCBkZXNjLCBtdWx0aSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVNvcnRCeSxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICBkZXNjOiBkZXNjLFxuICAgICAgICBtdWx0aTogbXVsdGlcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyB1c2UgcmVmZXJlbmNlIHRvIGF2b2lkIG1lbW9yeSBsZWFrIGluICMxNjA4XG5cbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpOyAvLyBBZGQgdGhlIGdldFNvcnRCeVRvZ2dsZVByb3BzIG1ldGhvZCB0byBjb2x1bW5zIGFuZCBoZWFkZXJzXG5cbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHZhciBhY2Nlc3NvciA9IGNvbHVtbi5hY2Nlc3NvcixcbiAgICAgICAgICBkZWZhdWx0Q29sdW1uQ2FuU29ydCA9IGNvbHVtbi5jYW5Tb3J0LFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVTb3J0QnkgPSBjb2x1bW4uZGlzYWJsZVNvcnRCeSxcbiAgICAgICAgICBpZCA9IGNvbHVtbi5pZDtcbiAgICAgIHZhciBjYW5Tb3J0ID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZVNvcnRCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlU29ydEJ5ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGRlZmF1bHRDYW5Tb3J0LCBkZWZhdWx0Q29sdW1uQ2FuU29ydCwgZmFsc2UpO1xuICAgICAgY29sdW1uLmNhblNvcnQgPSBjYW5Tb3J0O1xuXG4gICAgICBpZiAoY29sdW1uLmNhblNvcnQpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRCeSA9IGZ1bmN0aW9uIChkZXNjLCBtdWx0aSkge1xuICAgICAgICAgIHJldHVybiB0b2dnbGVTb3J0QnkoY29sdW1uLmlkLCBkZXNjLCBtdWx0aSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29sdW1uLmNsZWFyU29ydEJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IGFjdGlvbnMuY2xlYXJTb3J0QnksXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi5nZXRTb3J0QnlUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0U29ydEJ5VG9nZ2xlUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9KTtcbiAgICAgIHZhciBjb2x1bW5Tb3J0ID0gc29ydEJ5LmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uaXNTb3J0ZWQgPSAhIWNvbHVtblNvcnQ7XG4gICAgICBjb2x1bW4uc29ydGVkSW5kZXggPSBzb3J0QnkuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgICAgY29sdW1uLmlzU29ydGVkRGVzYyA9IGNvbHVtbi5pc1NvcnRlZCA/IGNvbHVtblNvcnQuZGVzYyA6IHVuZGVmaW5lZDtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbFNvcnRCeSB8fCAhc29ydEJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvcnRlZEZsYXRSb3dzID0gW107IC8vIEZpbHRlciBvdXQgc29ydEJ5cyB0aGF0IGNvcnJlc3BvbmQgdG8gbm9uIGV4aXN0aW5nIGNvbHVtbnNcblxuICAgICAgdmFyIGF2YWlsYWJsZVNvcnRCeSA9IHNvcnRCeS5maWx0ZXIoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnREYXRhID0gZnVuY3Rpb24gc29ydERhdGEocm93cykge1xuICAgICAgICAvLyBVc2UgdGhlIG9yZGVyQnlGbiB0byBjb21wb3NlIG11bHRpcGxlIHNvcnRCeSdzIHRvZ2V0aGVyLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgICAvLyBpZiBuZWVkZWQuXG4gICAgICAgIHZhciBzb3J0ZWREYXRhID0gb3JkZXJCeUZuKHJvd3MsIGF2YWlsYWJsZVNvcnRCeS5tYXAoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgICAvLyBTdXBwb3J0IGN1c3RvbSBzb3J0aW5nIG1ldGhvZHMgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgICAgdmFyIGNvbHVtbiA9IGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuaWQgPT09IHNvcnQuaWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QtVGFibGU6IENvdWxkIG5vdCBmaW5kIGEgY29sdW1uIHdpdGggaWQ6IFwiICsgc29ydC5pZCArIFwiIHdoaWxlIHNvcnRpbmdcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNvcnRUeXBlID0gY29sdW1uLnNvcnRUeXBlOyAvLyBMb29rIHVwIHNvcnRCeSBmdW5jdGlvbnMgaW4gdGhpcyBvcmRlcjpcbiAgICAgICAgICAvLyBjb2x1bW4gZnVuY3Rpb25cbiAgICAgICAgICAvLyBjb2x1bW4gc3RyaW5nIGxvb2t1cCBvbiB1c2VyIHNvcnRUeXBlXG4gICAgICAgICAgLy8gY29sdW1uIHN0cmluZyBsb29rdXAgb24gYnVpbHQtaW4gc29ydFR5cGVcbiAgICAgICAgICAvLyBkZWZhdWx0IGZ1bmN0aW9uXG4gICAgICAgICAgLy8gZGVmYXVsdCBzdHJpbmcgbG9va3VwIG9uIHVzZXIgc29ydFR5cGVcbiAgICAgICAgICAvLyBkZWZhdWx0IHN0cmluZyBsb29rdXAgb24gYnVpbHQtaW4gc29ydFR5cGVcblxuICAgICAgICAgIHZhciBzb3J0TWV0aG9kID0gaXNGdW5jdGlvbihzb3J0VHlwZSkgfHwgKHVzZXJTb3J0VHlwZXMgfHwge30pW3NvcnRUeXBlXSB8fCBzb3J0VHlwZXNbc29ydFR5cGVdO1xuXG4gICAgICAgICAgaWYgKCFzb3J0TWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC1UYWJsZTogQ291bGQgbm90IGZpbmQgYSB2YWxpZCBzb3J0VHlwZSBvZiAnXCIgKyBzb3J0VHlwZSArIFwiJyBmb3IgY29sdW1uICdcIiArIHNvcnQuaWQgKyBcIicuXCIpO1xuICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBjb3JyZWN0IHNvcnRGbi5cbiAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuXG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0TWV0aG9kKGEsIGIsIHNvcnQuaWQsIHNvcnQuZGVzYyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSksIC8vIE1hcCB0aGUgZGlyZWN0aW9uc1xuICAgICAgICBhdmFpbGFibGVTb3J0QnkubWFwKGZ1bmN0aW9uIChzb3J0KSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IGFuZCB1c2UgdGhlIHNvcnRJbnZlcnRlZCBvcHRpb25cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb2x1bW4gJiYgY29sdW1uLnNvcnRJbnZlcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnQuZGVzYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gIXNvcnQuZGVzYztcbiAgICAgICAgfSkpOyAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuXG4gICAgICAgIHNvcnRlZERhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgc29ydGVkRmxhdFJvd3MucHVzaChyb3cpO1xuXG4gICAgICAgICAgaWYgKCFyb3cuc3ViUm93cyB8fCByb3cuc3ViUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb3J0ZWREYXRhO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFtzb3J0RGF0YShyb3dzKSwgc29ydGVkRmxhdFJvd3NdO1xuICAgIH0sIFttYW51YWxTb3J0QnksIHNvcnRCeSwgcm93cywgZmxhdFJvd3MsIGFsbENvbHVtbnMsIG9yZGVyQnlGbiwgdXNlclNvcnRUeXBlc10pLFxuICAgICAgICBzb3J0ZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIHNvcnRlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV07XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0U29ydEJ5ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFNvcnRCeSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0U29ydEJ5KCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRTb3J0QnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW21hbnVhbFNvcnRCeSA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlU29ydGVkUm93czogcm93cyxcbiAgICAgIHByZVNvcnRlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHNvcnRlZFJvd3M6IHNvcnRlZFJvd3MsXG4gICAgICBzb3J0ZWRGbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzOiBzb3J0ZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxuICAgICAgc2V0U29ydEJ5OiBzZXRTb3J0QnksXG4gICAgICB0b2dnbGVTb3J0Qnk6IHRvZ2dsZVNvcnRCeVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdE9yZGVyQnlGbihhcnIsIGZ1bmNzLCBkaXJzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpLnNvcnQoZnVuY3Rpb24gKHJvd0EsIHJvd0IpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNvcnRGbiA9IGZ1bmNzW2ldO1xuICAgICAgICB2YXIgZGVzYyA9IGRpcnNbaV0gPT09IGZhbHNlIHx8IGRpcnNbaV0gPT09ICdkZXNjJztcbiAgICAgICAgdmFyIHNvcnRJbnQgPSBzb3J0Rm4ocm93QSwgcm93Qik7XG5cbiAgICAgICAgaWYgKHNvcnRJbnQgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZGVzYyA/IC1zb3J0SW50IDogc29ydEludDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyc1swXSA/IHJvd0EuaW5kZXggLSByb3dCLmluZGV4IDogcm93Qi5pbmRleCAtIHJvd0EuaW5kZXg7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGx1Z2luTmFtZSA9ICd1c2VQYWdpbmF0aW9uJzsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRQYWdlID0gJ3Jlc2V0UGFnZSc7XG4gIGFjdGlvbnMuZ290b1BhZ2UgPSAnZ290b1BhZ2UnO1xuICBhY3Rpb25zLnNldFBhZ2VTaXplID0gJ3NldFBhZ2VTaXplJztcbiAgdmFyIHVzZVBhZ2luYXRpb24gPSBmdW5jdGlvbiB1c2VQYWdpbmF0aW9uKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ2KTtcbiAgfTtcbiAgdXNlUGFnaW5hdGlvbi5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZTtcblxuICBmdW5jdGlvbiByZWR1Y2VyJDYoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgICBwYWdlSW5kZXg6IDBcbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRQYWdlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCB8fCAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuZ290b1BhZ2UpIHtcbiAgICAgIHZhciBwYWdlQ291bnQgPSBpbnN0YW5jZS5wYWdlQ291bnQsXG4gICAgICAgICAgcGFnZSA9IGluc3RhbmNlLnBhZ2U7XG4gICAgICB2YXIgbmV3UGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZShhY3Rpb24ucGFnZUluZGV4LCBzdGF0ZS5wYWdlSW5kZXgpO1xuICAgICAgdmFyIGNhbk5hdmlnYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChuZXdQYWdlSW5kZXggPiBzdGF0ZS5wYWdlSW5kZXgpIHtcbiAgICAgICAgLy8gbmV4dCBwYWdlXG4gICAgICAgIGNhbk5hdmlnYXRlID0gcGFnZUNvdW50ID09PSAtMSA/IHBhZ2UubGVuZ3RoID49IHN0YXRlLnBhZ2VTaXplIDogbmV3UGFnZUluZGV4IDwgcGFnZUNvdW50O1xuICAgICAgfSBlbHNlIGlmIChuZXdQYWdlSW5kZXggPCBzdGF0ZS5wYWdlSW5kZXgpIHtcbiAgICAgICAgLy8gcHJldiBwYWdlXG4gICAgICAgIGNhbk5hdmlnYXRlID0gbmV3UGFnZUluZGV4ID4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogbmV3UGFnZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0UGFnZVNpemUpIHtcbiAgICAgIHZhciBwYWdlU2l6ZSA9IGFjdGlvbi5wYWdlU2l6ZTtcbiAgICAgIHZhciB0b3BSb3dJbmRleCA9IHN0YXRlLnBhZ2VTaXplICogc3RhdGUucGFnZUluZGV4O1xuICAgICAgdmFyIHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDYoaW5zdGFuY2UpIHtcbiAgICB2YXIgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRQYSA9IGluc3RhbmNlLmF1dG9SZXNldFBhZ2UsXG4gICAgICAgIGF1dG9SZXNldFBhZ2UgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UGEgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UGEsXG4gICAgICAgIF9pbnN0YW5jZSRtYW51YWxFeHBhbiA9IGluc3RhbmNlLm1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBtYW51YWxFeHBhbmRlZEtleSA9IF9pbnN0YW5jZSRtYW51YWxFeHBhbiA9PT0gdm9pZCAwID8gJ2V4cGFuZGVkJyA6IF9pbnN0YW5jZSRtYW51YWxFeHBhbixcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIHVzZXJQYWdlQ291bnQgPSBpbnN0YW5jZS5wYWdlQ291bnQsXG4gICAgICAgIF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9IGluc3RhbmNlLnBhZ2luYXRlRXhwYW5kZWRSb3dzLFxuICAgICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93cyA9IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCxcbiAgICAgICAgX2luc3RhbmNlJGV4cGFuZFN1YlJvID0gaW5zdGFuY2UuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRleHBhbmRTdWJSbyxcbiAgICAgICAgX2luc3RhbmNlJHN0YXRlID0gaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgIHBhZ2VTaXplID0gX2luc3RhbmNlJHN0YXRlLnBhZ2VTaXplLFxuICAgICAgICBwYWdlSW5kZXggPSBfaW5zdGFuY2Ukc3RhdGUucGFnZUluZGV4LFxuICAgICAgICBleHBhbmRlZCA9IF9pbnN0YW5jZSRzdGF0ZS5leHBhbmRlZCxcbiAgICAgICAgZ2xvYmFsRmlsdGVyID0gX2luc3RhbmNlJHN0YXRlLmdsb2JhbEZpbHRlcixcbiAgICAgICAgZmlsdGVycyA9IF9pbnN0YW5jZSRzdGF0ZS5maWx0ZXJzLFxuICAgICAgICBncm91cEJ5ID0gX2luc3RhbmNlJHN0YXRlLmdyb3VwQnksXG4gICAgICAgIHNvcnRCeSA9IF9pbnN0YW5jZSRzdGF0ZS5zb3J0QnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICBtYW51YWxQYWdpbmF0aW9uID0gaW5zdGFuY2UubWFudWFsUGFnaW5hdGlvbjtcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUdsb2JhbEZpbHRlcicsICd1c2VGaWx0ZXJzJywgJ3VzZUdyb3VwQnknLCAndXNlU29ydEJ5JywgJ3VzZUV4cGFuZGVkJ10sICd1c2VQYWdpbmF0aW9uJyk7XG4gICAgdmFyIGdldEF1dG9SZXNldFBhZ2UgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0UGFnZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UGFnZSgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0UGFnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbFBhZ2luYXRpb24gPyBudWxsIDogZGF0YSwgZ2xvYmFsRmlsdGVyLCBmaWx0ZXJzLCBncm91cEJ5LCBzb3J0QnldKTtcbiAgICB2YXIgcGFnZUNvdW50ID0gbWFudWFsUGFnaW5hdGlvbiA/IHVzZXJQYWdlQ291bnQgOiBNYXRoLmNlaWwocm93cy5sZW5ndGggLyBwYWdlU2l6ZSk7XG4gICAgdmFyIHBhZ2VPcHRpb25zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFnZUNvdW50ID4gMCA/IFtdLmNvbmNhdChuZXcgQXJyYXkocGFnZUNvdW50KSkuZmlsbChudWxsKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KSA6IFtdO1xuICAgIH0sIFtwYWdlQ291bnRdKTtcbiAgICB2YXIgcGFnZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhZ2U7XG5cbiAgICAgIGlmIChtYW51YWxQYWdpbmF0aW9uKSB7XG4gICAgICAgIHBhZ2UgPSByb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgICAgICB2YXIgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplO1xuICAgICAgICBwYWdlID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBhbmRSb3dzKHBhZ2UsIHtcbiAgICAgICAgbWFudWFsRXhwYW5kZWRLZXk6IG1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgIGV4cGFuZFN1YlJvd3M6IGV4cGFuZFN1YlJvd3NcbiAgICAgIH0pO1xuICAgIH0sIFtleHBhbmRTdWJSb3dzLCBleHBhbmRlZCwgbWFudWFsRXhwYW5kZWRLZXksIG1hbnVhbFBhZ2luYXRpb24sIHBhZ2VJbmRleCwgcGFnZVNpemUsIHBhZ2luYXRlRXhwYW5kZWRSb3dzLCByb3dzXSk7XG4gICAgdmFyIGNhblByZXZpb3VzUGFnZSA9IHBhZ2VJbmRleCA+IDA7XG4gICAgdmFyIGNhbk5leHRQYWdlID0gcGFnZUNvdW50ID09PSAtMSA/IHBhZ2UubGVuZ3RoID49IHBhZ2VTaXplIDogcGFnZUluZGV4IDwgcGFnZUNvdW50IC0gMTtcbiAgICB2YXIgZ290b1BhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuZ290b1BhZ2UsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4XG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgcHJldmlvdXNQYWdlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdvdG9QYWdlKGZ1bmN0aW9uIChvbGQpIHtcbiAgICAgICAgcmV0dXJuIG9sZCAtIDE7XG4gICAgICB9KTtcbiAgICB9LCBbZ290b1BhZ2VdKTtcbiAgICB2YXIgbmV4dFBhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ290b1BhZ2UoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICByZXR1cm4gb2xkICsgMTtcbiAgICAgIH0pO1xuICAgIH0sIFtnb3RvUGFnZV0pO1xuICAgIHZhciBzZXRQYWdlU2l6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlU2l6ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldFBhZ2VTaXplLFxuICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHBhZ2VPcHRpb25zOiBwYWdlT3B0aW9ucyxcbiAgICAgIHBhZ2VDb3VudDogcGFnZUNvdW50LFxuICAgICAgcGFnZTogcGFnZSxcbiAgICAgIGNhblByZXZpb3VzUGFnZTogY2FuUHJldmlvdXNQYWdlLFxuICAgICAgY2FuTmV4dFBhZ2U6IGNhbk5leHRQYWdlLFxuICAgICAgZ290b1BhZ2U6IGdvdG9QYWdlLFxuICAgICAgcHJldmlvdXNQYWdlOiBwcmV2aW91c1BhZ2UsXG4gICAgICBuZXh0UGFnZTogbmV4dFBhZ2UsXG4gICAgICBzZXRQYWdlU2l6ZTogc2V0UGFnZVNpemVcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRQaXZvdCA9ICdyZXNldFBpdm90JztcbiAgYWN0aW9ucy50b2dnbGVQaXZvdCA9ICd0b2dnbGVQaXZvdCc7XG4gIHZhciBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucyhob29rcykge1xuICAgIGhvb2tzLmdldFBpdm90VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldFBpdm90VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDcpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQWZ0ZXJEYXRhLnB1c2godXNlSW5zdGFuY2VBZnRlckRhdGEpO1xuICAgIGhvb2tzLmFsbENvbHVtbnMucHVzaChhbGxDb2x1bW5zKTtcbiAgICBob29rcy5hY2Nlc3NWYWx1ZS5wdXNoKGFjY2Vzc1ZhbHVlKTtcbiAgICBob29rcy5tYXRlcmlhbGl6ZWRDb2x1bW5zLnB1c2gobWF0ZXJpYWxpemVkQ29sdW1ucyk7XG4gICAgaG9va3MubWF0ZXJpYWxpemVkQ29sdW1uc0RlcHMucHVzaChtYXRlcmlhbGl6ZWRDb2x1bW5zRGVwcyk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyQxKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1uc0RlcHMucHVzaCh2aXNpYmxlQ29sdW1uc0RlcHMpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNyk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMik7XG4gIH07XG4gIF9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMucGx1Z2luTmFtZSA9ICd1c2VQaXZvdENvbHVtbnMnO1xuICB2YXIgZGVmYXVsdFBpdm90Q29sdW1ucyA9IFtdO1xuXG4gIHZhciBkZWZhdWx0R2V0UGl2b3RUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRQaXZvdFRvZ2dsZVByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGhlYWRlciA9IF9yZWYuaGVhZGVyO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGhlYWRlci5jYW5QaXZvdCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBoZWFkZXIudG9nZ2xlUGl2b3QoKTtcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6IGhlYWRlci5jYW5QaXZvdCA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFBpdm90J1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDcoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBkZWZhdWx0UGl2b3RDb2x1bW5zXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0UGl2b3QpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucGl2b3RDb2x1bW5zIHx8IGRlZmF1bHRQaXZvdENvbHVtbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVQaXZvdCkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIHNldFBpdm90ID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJlc29sdmVkUGl2b3QgPSB0eXBlb2Ygc2V0UGl2b3QgIT09ICd1bmRlZmluZWQnID8gc2V0UGl2b3QgOiAhc3RhdGUucGl2b3RDb2x1bW5zLmluY2x1ZGVzKGNvbHVtbklkKTtcblxuICAgICAgaWYgKHJlc29sdmVkUGl2b3QpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHBpdm90Q29sdW1uczogW10uY29uY2F0KHN0YXRlLnBpdm90Q29sdW1ucywgW2NvbHVtbklkXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBzdGF0ZS5waXZvdENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2VBZnRlckRhdGEoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzUGl2b3RTb3VyY2UgPSBpbnN0YW5jZS5zdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbENvbHVtbnMoY29sdW1ucywgX3JlZjIpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMi5pbnN0YW5jZTtcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzUGl2b3RTb3VyY2UgPSBpbnN0YW5jZS5zdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIGNvbHVtbi51bmlxdWVWYWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbnM7XG4gIH1cblxuICBmdW5jdGlvbiBhY2Nlc3NWYWx1ZSh2YWx1ZSwgX3JlZjMpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjMuY29sdW1uO1xuXG4gICAgaWYgKGNvbHVtbi51bmlxdWVWYWx1ZXMgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29sdW1uLnVuaXF1ZVZhbHVlcy5hZGQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGVyaWFsaXplZENvbHVtbnMobWF0ZXJpYWxpemVkLCBfcmVmNCkge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY0Lmluc3RhbmNlO1xuICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmICghc3RhdGUucGl2b3RDb2x1bW5zLmxlbmd0aCB8fCAhc3RhdGUuZ3JvdXBCeSB8fCAhc3RhdGUuZ3JvdXBCeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXRlcmlhbGl6ZWQ7XG4gICAgfVxuXG4gICAgdmFyIHBpdm90Q29sdW1ucyA9IHN0YXRlLnBpdm90Q29sdW1ucy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICB2YXIgc291cmNlQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gIWQuaXNQaXZvdFNvdXJjZSAmJiAhc3RhdGUuZ3JvdXBCeS5pbmNsdWRlcyhkLmlkKSAmJiAhc3RhdGUucGl2b3RDb2x1bW5zLmluY2x1ZGVzKGQuaWQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGJ1aWxkUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gYnVpbGRQaXZvdENvbHVtbnMoZGVwdGgsIHBhcmVudCwgcGl2b3RGaWx0ZXJzKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaXZvdEZpbHRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICBwaXZvdEZpbHRlcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBpdm90Q29sdW1uID0gcGl2b3RDb2x1bW5zW2RlcHRoXTtcblxuICAgICAgaWYgKCFwaXZvdENvbHVtbikge1xuICAgICAgICByZXR1cm4gc291cmNlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKHNvdXJjZUNvbHVtbikge1xuICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIG9mZmVyIHN1cHBvcnQgaGVyZSBmb3IgcmVuZXN0aW5nIHBpdm90ZWRcbiAgICAgICAgICAvLyBjb2x1bW5zIGluc2lkZSBjb3BpZXMgb2YgdGhlaXIgaGVhZGVyIGdyb3Vwcy4gRm9yIG5vdyxcbiAgICAgICAgICAvLyB0aGF0IHNlZW1zIGxpa2UgaXQgd291bGQgYmUgKDEpIG92ZXJraWxsIG9uIG5lc3RpbmcsIGNvbnNpZGVyaW5nXG4gICAgICAgICAgLy8geW91IGFscmVhZHkgZ2V0IG5lc3RpbmcgZm9yIGV2ZXJ5IHBpdm90IGxldmVsIGFuZCAoMilcbiAgICAgICAgICAvLyByZWFsbHkgaGFyZC4gOilcbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNvdXJjZUNvbHVtbiwge1xuICAgICAgICAgICAgY2FuUGl2b3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNQaXZvdGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICBpZDogXCJcIiArIChwYXJlbnQgPyBwYXJlbnQuaWQgKyBcIi5cIiArIHNvdXJjZUNvbHVtbi5pZCA6IHNvdXJjZUNvbHVtbi5pZCksXG4gICAgICAgICAgICBhY2Nlc3NvcjogZnVuY3Rpb24gYWNjZXNzb3Iob3JpZ2luYWxSb3csIGksIHJvdykge1xuICAgICAgICAgICAgICBpZiAocGl2b3RGaWx0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKHJvdyk7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdy52YWx1ZXNbc291cmNlQ29sdW1uLmlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaXF1ZVZhbHVlcyA9IEFycmF5LmZyb20ocGl2b3RDb2x1bW4udW5pcXVlVmFsdWVzKS5zb3J0KCk7XG4gICAgICByZXR1cm4gdW5pcXVlVmFsdWVzLm1hcChmdW5jdGlvbiAodW5pcXVlVmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gX2V4dGVuZHMoe30sIHBpdm90Q29sdW1uLCB7XG4gICAgICAgICAgSGVhZGVyOiBwaXZvdENvbHVtbi5QaXZvdEhlYWRlciB8fCB0eXBlb2YgcGl2b3RDb2x1bW4uaGVhZGVyID09PSAnc3RyaW5nJyA/IHBpdm90Q29sdW1uLkhlYWRlciArIFwiOiBcIiArIHVuaXF1ZVZhbHVlIDogdW5pcXVlVmFsdWUsXG4gICAgICAgICAgaXNQaXZvdEdyb3VwOiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICBpZDogcGFyZW50ID8gcGFyZW50LmlkICsgXCIuXCIgKyBwaXZvdENvbHVtbi5pZCArIFwiLlwiICsgdW5pcXVlVmFsdWUgOiBwaXZvdENvbHVtbi5pZCArIFwiLlwiICsgdW5pcXVlVmFsdWUsXG4gICAgICAgICAgcGl2b3RWYWx1ZTogdW5pcXVlVmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29sdW1uR3JvdXAuY29sdW1ucyA9IGJ1aWxkUGl2b3RDb2x1bW5zKGRlcHRoICsgMSwgY29sdW1uR3JvdXAsIFtdLmNvbmNhdChwaXZvdEZpbHRlcnMsIFtmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgcmV0dXJuIHJvdy52YWx1ZXNbcGl2b3RDb2x1bW4uaWRdID09PSB1bmlxdWVWYWx1ZTtcbiAgICAgICAgfV0pKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbkdyb3VwO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdNYXRlcmlhbGl6ZWQgPSBmbGF0dGVuQ29sdW1ucyhidWlsZFBpdm90Q29sdW1ucygpKTtcbiAgICByZXR1cm4gW10uY29uY2F0KG1hdGVyaWFsaXplZCwgbmV3TWF0ZXJpYWxpemVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGVyaWFsaXplZENvbHVtbnNEZXBzKGRlcHMsIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY1JGluc3RhbmNlJHN0YXRlID0gX3JlZjUuaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgIHBpdm90Q29sdW1ucyA9IF9yZWY1JGluc3RhbmNlJHN0YXRlLnBpdm90Q29sdW1ucyxcbiAgICAgICAgZ3JvdXBCeSA9IF9yZWY1JGluc3RhbmNlJHN0YXRlLmdyb3VwQnk7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbcGl2b3RDb2x1bW5zLCBncm91cEJ5XSk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlQ29sdW1ucyQxKHZpc2libGVDb2x1bW5zLCBfcmVmNikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWY2Lmluc3RhbmNlLnN0YXRlO1xuICAgIHZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gIWQuaXNQaXZvdFNvdXJjZTtcbiAgICB9KTtcblxuICAgIGlmIChzdGF0ZS5waXZvdENvbHVtbnMubGVuZ3RoICYmIHN0YXRlLmdyb3VwQnkgJiYgc3RhdGUuZ3JvdXBCeS5sZW5ndGgpIHtcbiAgICAgIHZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5pc0dyb3VwZWQgfHwgY29sdW1uLmlzUGl2b3RlZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpYmxlQ29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zRGVwcyhkZXBzLCBfcmVmNykge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY3Lmluc3RhbmNlO1xuICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucywgaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNyhpbnN0YW5jZSkge1xuICAgIHZhciBjb2x1bW5zID0gaW5zdGFuY2UuY29sdW1ucyxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0UGkgPSBpbnN0YW5jZS5hdXRvUmVzZXRQaXZvdCxcbiAgICAgICAgYXV0b1Jlc2V0UGl2b3QgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UGkgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UGksXG4gICAgICAgIG1hbmF1bFBpdm90ID0gaW5zdGFuY2UubWFuYXVsUGl2b3QsXG4gICAgICAgIGRpc2FibGVQaXZvdCA9IGluc3RhbmNlLmRpc2FibGVQaXZvdCxcbiAgICAgICAgZGVmYXVsdENhblBpdm90ID0gaW5zdGFuY2UuZGVmYXVsdENhblBpdm90O1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlR3JvdXBCeSddLCAndXNlUGl2b3RDb2x1bW5zJyk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5QaXZvdCA9IGNvbHVtbi5kZWZhdWx0UGl2b3QsXG4gICAgICAgICAgY29sdW1uRGlzYWJsZVBpdm90ID0gY29sdW1uLmRpc2FibGVQaXZvdDtcbiAgICAgIGNvbHVtbi5jYW5QaXZvdCA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5QaXZvdCwgY29sdW1uRGlzYWJsZVBpdm90ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVQaXZvdCA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKSA6IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuUGl2b3QsIGRlZmF1bHRDb2x1bW5QaXZvdCwgZGVmYXVsdENhblBpdm90LCBmYWxzZSk7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuUGl2b3QpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVBpdm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVQaXZvdChjb2x1bW4uaWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4uQWdncmVnYXRlZCA9IGNvbHVtbi5BZ2dyZWdhdGVkIHx8IGNvbHVtbi5DZWxsO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvZ2dsZVBpdm90ID0gZnVuY3Rpb24gdG9nZ2xlUGl2b3QoY29sdW1uSWQsIHZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUGl2b3QsXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICBoZWFkZXIuZ2V0UGl2b3RUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0UGl2b3RUb2dnbGVQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgaGVhZGVyOiBoZWFkZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRQaXZvdCA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRQaXZvdCk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UGl2b3QoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFBpdm90XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFuYXVsUGl2b3QgPyBudWxsIDogY29sdW1uc10pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHRvZ2dsZVBpdm90OiB0b2dnbGVQaXZvdFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQyKHJvdykge1xuICAgIHJvdy5hbGxDZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAvLyBHcm91cGVkIGNlbGxzIGFyZSBpbiB0aGUgcGl2b3RDb2x1bW5zIGFuZCB0aGUgcGl2b3QgY2VsbCBmb3IgdGhlIHJvd1xuICAgICAgY2VsbC5pc1Bpdm90ZWQgPSBjZWxsLmNvbHVtbi5pc1Bpdm90ZWQ7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGx1Z2luTmFtZSQxID0gJ3VzZVJvd1NlbGVjdCc7IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLnJlc2V0U2VsZWN0ZWRSb3dzID0gJ3Jlc2V0U2VsZWN0ZWRSb3dzJztcbiAgYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSAndG9nZ2xlQWxsUm93c1NlbGVjdGVkJztcbiAgYWN0aW9ucy50b2dnbGVSb3dTZWxlY3RlZCA9ICd0b2dnbGVSb3dTZWxlY3RlZCc7XG4gIGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICd0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkJztcbiAgdmFyIHVzZVJvd1NlbGVjdCA9IGZ1bmN0aW9uIHVzZVJvd1NlbGVjdChob29rcykge1xuICAgIGhvb2tzLmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDgpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkOCk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMyk7XG4gIH07XG4gIHVzZVJvd1NlbGVjdC5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZSQxO1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgICAgcm93ID0gX3JlZi5yb3c7XG4gICAgdmFyIF9pbnN0YW5jZSRtYW51YWxSb3dTZSA9IGluc3RhbmNlLm1hbnVhbFJvd1NlbGVjdGVkS2V5LFxuICAgICAgICBtYW51YWxSb3dTZWxlY3RlZEtleSA9IF9pbnN0YW5jZSRtYW51YWxSb3dTZSA9PT0gdm9pZCAwID8gJ2lzU2VsZWN0ZWQnIDogX2luc3RhbmNlJG1hbnVhbFJvd1NlO1xuICAgIHZhciBjaGVja2VkID0gZmFsc2U7XG5cbiAgICBpZiAocm93Lm9yaWdpbmFsICYmIHJvdy5vcmlnaW5hbFttYW51YWxSb3dTZWxlY3RlZEtleV0pIHtcbiAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja2VkID0gcm93LmlzU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgcm93LnRvZ2dsZVJvd1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFJvdyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiByb3cuaXNTb21lU2VsZWN0ZWRcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGluc3RhbmNlLmlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIFJvd3MgU2VsZWN0ZWQnLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogQm9vbGVhbighaW5zdGFuY2UuaXNBbGxSb3dzU2VsZWN0ZWQgJiYgT2JqZWN0LmtleXMoaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHMpLmxlbmd0aClcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjMuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEFsbCBDdXJyZW50IFBhZ2UgUm93cyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiBCb29sZWFuKCFpbnN0YW5jZS5pc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgaW5zdGFuY2UucGFnZS5zb21lKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZDtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0YXRlLnNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKVxuICAgIH1dO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ4KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFNlbGVjdGVkUm93cykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnNlbGVjdGVkUm93SWRzIHx8IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICB2YXIgc2V0U2VsZWN0ZWQgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgaXNBbGxSb3dzU2VsZWN0ZWQgPSBpbnN0YW5jZS5pc0FsbFJvd3NTZWxlY3RlZCxcbiAgICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICAgIF9pbnN0YW5jZSRub25Hcm91cGVkUiA9IGluc3RhbmNlLm5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgICAgICBub25Hcm91cGVkUm93c0J5SWQgPSBfaW5zdGFuY2Ukbm9uR3JvdXBlZFIgPT09IHZvaWQgMCA/IHJvd3NCeUlkIDogX2luc3RhbmNlJG5vbkdyb3VwZWRSO1xuICAgICAgdmFyIHNlbGVjdEFsbCA9IHR5cGVvZiBzZXRTZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRTZWxlY3RlZCA6ICFpc0FsbFJvd3NTZWxlY3RlZDsgLy8gT25seSByZW1vdmUvYWRkIHRoZSByb3dzIHRoYXQgYXJlIHZpc2libGUgb24gdGhlIHNjcmVlblxuICAgICAgLy8gIExlYXZlIGFsbCB0aGUgb3RoZXIgcm93cyB0aGF0IGFyZSBzZWxlY3RlZCBhbG9uZS5cblxuICAgICAgdmFyIHNlbGVjdGVkUm93SWRzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc2VsZWN0ZWRSb3dJZHMpO1xuXG4gICAgICBpZiAoc2VsZWN0QWxsKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vbkdyb3VwZWRSb3dzQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAocm93SWQpIHtcbiAgICAgICAgICBzZWxlY3RlZFJvd0lkc1tyb3dJZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vbkdyb3VwZWRSb3dzQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAocm93SWQpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbcm93SWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogc2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVSb3dTZWxlY3RlZCkge1xuICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgIF9zZXRTZWxlY3RlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBfcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgICBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8gPSBpbnN0YW5jZS5zZWxlY3RTdWJSb3dzLFxuICAgICAgICAgIHNlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8sXG4gICAgICAgICAgZ2V0U3ViUm93cyA9IGluc3RhbmNlLmdldFN1YlJvd3M7XG4gICAgICB2YXIgaXNTZWxlY3RlZCA9IHN0YXRlLnNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIHZhciBzaG91bGRFeGlzdCA9IHR5cGVvZiBfc2V0U2VsZWN0ZWQgIT09ICd1bmRlZmluZWQnID8gX3NldFNlbGVjdGVkIDogIWlzU2VsZWN0ZWQ7XG5cbiAgICAgIGlmIChpc1NlbGVjdGVkID09PSBzaG91bGRFeGlzdCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTZWxlY3RlZFJvd0lkcyA9IF9leHRlbmRzKHt9LCBzdGF0ZS5zZWxlY3RlZFJvd0lkcyk7XG5cbiAgICAgIHZhciBoYW5kbGVSb3dCeUlkID0gZnVuY3Rpb24gaGFuZGxlUm93QnlJZChpZCkge1xuICAgICAgICB2YXIgcm93ID0gX3Jvd3NCeUlkW2lkXTtcblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgaWYgKCFyb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBuZXdTZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGVjdFN1YlJvd3MgJiYgZ2V0U3ViUm93cyhyb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3ViUm93cyhyb3cpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVSb3dCeUlkKGlkKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHM6IG5ld1NlbGVjdGVkUm93SWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCkge1xuICAgICAgdmFyIF9zZXRTZWxlY3RlZDIgPSBhY3Rpb24udmFsdWU7XG5cbiAgICAgIHZhciBwYWdlID0gaW5zdGFuY2UucGFnZSxcbiAgICAgICAgICBfcm93c0J5SWQyID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgICAgX2luc3RhbmNlJHNlbGVjdFN1YlJvMiA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgICAgX3NlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHNlbGVjdFN1YlJvMixcbiAgICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBpbnN0YW5jZS5pc0FsbFBhZ2VSb3dzU2VsZWN0ZWQsXG4gICAgICAgICAgX2dldFN1YlJvd3MgPSBpbnN0YW5jZS5nZXRTdWJSb3dzO1xuXG4gICAgICB2YXIgX3NlbGVjdEFsbCA9IHR5cGVvZiBfc2V0U2VsZWN0ZWQyICE9PSAndW5kZWZpbmVkJyA/IF9zZXRTZWxlY3RlZDIgOiAhaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuXG4gICAgICB2YXIgX25ld1NlbGVjdGVkUm93SWRzID0gX2V4dGVuZHMoe30sIHN0YXRlLnNlbGVjdGVkUm93SWRzKTtcblxuICAgICAgdmFyIF9oYW5kbGVSb3dCeUlkID0gZnVuY3Rpb24gX2hhbmRsZVJvd0J5SWQoaWQpIHtcbiAgICAgICAgdmFyIHJvdyA9IF9yb3dzQnlJZDJbaWRdO1xuXG4gICAgICAgIGlmICghcm93LmlzR3JvdXBlZCkge1xuICAgICAgICAgIGlmIChfc2VsZWN0QWxsKSB7XG4gICAgICAgICAgICBfbmV3U2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIF9uZXdTZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9zZWxlY3RTdWJSb3dzICYmIF9nZXRTdWJSb3dzKHJvdykpIHtcbiAgICAgICAgICByZXR1cm4gX2dldFN1YlJvd3Mocm93KS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBfaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwYWdlLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJvd0J5SWQocm93LmlkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogX25ld1NlbGVjdGVkUm93SWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ4KGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIF9pbnN0YW5jZSRub25Hcm91cGVkUjIgPSBpbnN0YW5jZS5ub25Hcm91cGVkUm93c0J5SWQsXG4gICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZCA9IF9pbnN0YW5jZSRub25Hcm91cGVkUjIgPT09IHZvaWQgMCA/IHJvd3NCeUlkIDogX2luc3RhbmNlJG5vbkdyb3VwZWRSMixcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFNlID0gaW5zdGFuY2UuYXV0b1Jlc2V0U2VsZWN0ZWRSb3dzLFxuICAgICAgICBhdXRvUmVzZXRTZWxlY3RlZFJvd3MgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UsXG4gICAgICAgIHNlbGVjdGVkUm93SWRzID0gaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHMsXG4gICAgICAgIF9pbnN0YW5jZSRzZWxlY3RTdWJSbzMgPSBpbnN0YW5jZS5zZWxlY3RTdWJSb3dzLFxuICAgICAgICBzZWxlY3RTdWJSb3dzID0gX2luc3RhbmNlJHNlbGVjdFN1YlJvMyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRzZWxlY3RTdWJSbzMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIHBhZ2UgPSBpbnN0YW5jZS5wYWdlLFxuICAgICAgICBnZXRTdWJSb3dzID0gaW5zdGFuY2UuZ2V0U3ViUm93cztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUZpbHRlcnMnLCAndXNlR3JvdXBCeScsICd1c2VTb3J0QnknLCAndXNlRXhwYW5kZWQnLCAndXNlUGFnaW5hdGlvbiddLCAndXNlUm93U2VsZWN0Jyk7XG4gICAgdmFyIHNlbGVjdGVkRmxhdFJvd3MgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxlY3RlZEZsYXRSb3dzID0gW107XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdFN1YlJvd3MgPyBnZXRSb3dJc1NlbGVjdGVkKHJvdywgc2VsZWN0ZWRSb3dJZHMsIGdldFN1YlJvd3MpIDogISFzZWxlY3RlZFJvd0lkc1tyb3cuaWRdO1xuICAgICAgICByb3cuaXNTZWxlY3RlZCA9ICEhaXNTZWxlY3RlZDtcbiAgICAgICAgcm93LmlzU29tZVNlbGVjdGVkID0gaXNTZWxlY3RlZCA9PT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEZsYXRSb3dzO1xuICAgIH0sIFtyb3dzLCBzZWxlY3RTdWJSb3dzLCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93c10pO1xuICAgIHZhciBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4oT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5sZW5ndGggJiYgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmxlbmd0aCk7XG4gICAgdmFyIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGlzQWxsUm93c1NlbGVjdGVkO1xuXG4gICAgaWYgKGlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgaWYgKHBhZ2UgJiYgcGFnZS5sZW5ndGggJiYgcGFnZS5zb21lKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgaWQgPSBfcmVmNS5pZDtcbiAgICAgICAgcmV0dXJuICFzZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICB9KSkge1xuICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0U2VsZWN0ZWRSb3dzID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFNlbGVjdGVkUm93cyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0U2VsZWN0ZWRSb3dzKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRTZWxlY3RlZFJvd3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBkYXRhXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlUm93U2VsZWN0ZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICB2YXIgZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIHZhciBnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcywge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBzZWxlY3RlZEZsYXRSb3dzOiBzZWxlY3RlZEZsYXRSb3dzLFxuICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQ6IGlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkOiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQsXG4gICAgICB0b2dnbGVSb3dTZWxlY3RlZDogdG9nZ2xlUm93U2VsZWN0ZWQsXG4gICAgICB0b2dnbGVBbGxSb3dzU2VsZWN0ZWQ6IHRvZ2dsZUFsbFJvd3NTZWxlY3RlZCxcbiAgICAgIGdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzOiBnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wcyxcbiAgICAgIGdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wczogZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzLFxuICAgICAgdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZDogdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQzKHJvdywgX3JlZjYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmNi5pbnN0YW5jZTtcblxuICAgIHJvdy50b2dnbGVSb3dTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVSb3dTZWxlY3RlZChyb3cuaWQsIHNldCk7XG4gICAgfTtcblxuICAgIHJvdy5nZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzID0gbWFrZVByb3BHZXR0ZXIoaW5zdGFuY2UuZ2V0SG9va3MoKS5nZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICByb3c6IHJvd1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um93SXNTZWxlY3RlZChyb3csIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzKSB7XG4gICAgaWYgKHNlbGVjdGVkUm93SWRzW3Jvdy5pZF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdWJSb3dzID0gZ2V0U3ViUm93cyhyb3cpO1xuXG4gICAgaWYgKHN1YlJvd3MgJiYgc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgIHZhciBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHZhciBzb21lU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxuICAgICAgICBpZiAoc29tZVNlbGVjdGVkICYmICFhbGxDaGlsZHJlblNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldFJvd0lzU2VsZWN0ZWQoc3ViUm93LCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93cykpIHtcbiAgICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/IHRydWUgOiBzb21lU2VsZWN0ZWQgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IGZ1bmN0aW9uIGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3cpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IgPSBmdW5jdGlvbiBkZWZhdWx0SW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKGNlbGwpIHtcbiAgICByZXR1cm4ge307XG4gIH07IC8vIEFjdGlvbnNcblxuXG4gIGFjdGlvbnMuc2V0Um93U3RhdGUgPSAnc2V0Um93U3RhdGUnO1xuICBhY3Rpb25zLnNldENlbGxTdGF0ZSA9ICdzZXRDZWxsU3RhdGUnO1xuICBhY3Rpb25zLnJlc2V0Um93U3RhdGUgPSAncmVzZXRSb3dTdGF0ZSc7XG4gIHZhciB1c2VSb3dTdGF0ZSA9IGZ1bmN0aW9uIHVzZVJvd1N0YXRlKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkOSk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ5KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQ0KTtcbiAgfTtcbiAgdXNlUm93U3RhdGUucGx1Z2luTmFtZSA9ICd1c2VSb3dTdGF0ZSc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ5KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRpbml0aWFsUm93UyA9IGluc3RhbmNlLmluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yLFxuICAgICAgICBpbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsUm93UyA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxSb3dTLFxuICAgICAgICBfaW5zdGFuY2UkaW5pdGlhbENlbGwgPSBpbnN0YW5jZS5pbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsQ2VsbCA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsQ2VsbCxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZDtcblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICByb3dTdGF0ZToge31cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRSb3dTdGF0ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICByb3dTdGF0ZTogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnJvd1N0YXRlIHx8IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Um93U3RhdGUpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciByb3dJZCA9IGFjdGlvbi5yb3dJZCxcbiAgICAgICAgICB2YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBvbGRSb3dTdGF0ZSA9IHR5cGVvZiBzdGF0ZS5yb3dTdGF0ZVtyb3dJZF0gIT09ICd1bmRlZmluZWQnID8gc3RhdGUucm93U3RhdGVbcm93SWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93c0J5SWRbcm93SWRdKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcm93U3RhdGU6IF9leHRlbmRzKHt9LCBzdGF0ZS5yb3dTdGF0ZSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbcm93SWRdID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgb2xkUm93U3RhdGUpLCBfZXh0ZW5kczIpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldENlbGxTdGF0ZSkge1xuICAgICAgdmFyIF9vbGRSb3dTdGF0ZSRjZWxsU3RhdCwgX3Jvd3NCeUlkJF9yb3dJZCwgX3Jvd3NCeUlkJF9yb3dJZCRjZWxsLCBfZXh0ZW5kczMsIF9leHRlbmRzNDtcblxuICAgICAgdmFyIF9yb3dJZCA9IGFjdGlvbi5yb3dJZCxcbiAgICAgICAgICBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBfdmFsdWUgPSBhY3Rpb24udmFsdWU7XG5cbiAgICAgIHZhciBfb2xkUm93U3RhdGUgPSB0eXBlb2Ygc3RhdGUucm93U3RhdGVbX3Jvd0lkXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdGF0ZS5yb3dTdGF0ZVtfcm93SWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93c0J5SWRbX3Jvd0lkXSk7XG5cbiAgICAgIHZhciBvbGRDZWxsU3RhdGUgPSB0eXBlb2YgKF9vbGRSb3dTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogKF9vbGRSb3dTdGF0ZSRjZWxsU3RhdCA9IF9vbGRSb3dTdGF0ZS5jZWxsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUm93U3RhdGUkY2VsbFN0YXRbY29sdW1uSWRdKSAhPT0gJ3VuZGVmaW5lZCcgPyBfb2xkUm93U3RhdGUuY2VsbFN0YXRlW2NvbHVtbklkXSA6IGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcigoX3Jvd3NCeUlkJF9yb3dJZCA9IHJvd3NCeUlkW19yb3dJZF0pID09IG51bGwgPyB2b2lkIDAgOiAoX3Jvd3NCeUlkJF9yb3dJZCRjZWxsID0gX3Jvd3NCeUlkJF9yb3dJZC5jZWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3dzQnlJZCRfcm93SWQkY2VsbC5maW5kKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHJldHVybiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHJvd1N0YXRlOiBfZXh0ZW5kcyh7fSwgc3RhdGUucm93U3RhdGUsIChfZXh0ZW5kczQgPSB7fSwgX2V4dGVuZHM0W19yb3dJZF0gPSBfZXh0ZW5kcyh7fSwgX29sZFJvd1N0YXRlLCB7XG4gICAgICAgICAgY2VsbFN0YXRlOiBfZXh0ZW5kcyh7fSwgX29sZFJvd1N0YXRlLmNlbGxTdGF0ZSB8fCB7fSwgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbY29sdW1uSWRdID0gZnVuY3Rpb25hbFVwZGF0ZShfdmFsdWUsIG9sZENlbGxTdGF0ZSksIF9leHRlbmRzMykpXG4gICAgICAgIH0pLCBfZXh0ZW5kczQpKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkOShpbnN0YW5jZSkge1xuICAgIHZhciBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8gPSBpbnN0YW5jZS5hdXRvUmVzZXRSb3dTdGF0ZSxcbiAgICAgICAgYXV0b1Jlc2V0Um93U3RhdGUgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8sXG4gICAgICAgIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoO1xuICAgIHZhciBzZXRSb3dTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyb3dJZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Um93U3RhdGUsXG4gICAgICAgIHJvd0lkOiByb3dJZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0Q2VsbFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvd0lkLCBjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Q2VsbFN0YXRlLFxuICAgICAgICByb3dJZDogcm93SWQsXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0Um93U3RhdGUgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0Um93U3RhdGUpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldFJvd1N0YXRlKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSb3dTdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGF0YV0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHNldFJvd1N0YXRlOiBzZXRSb3dTdGF0ZSxcbiAgICAgIHNldENlbGxTdGF0ZTogc2V0Q2VsbFN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDQocm93LCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICB2YXIgX2luc3RhbmNlJGluaXRpYWxSb3dTMiA9IGluc3RhbmNlLmluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yLFxuICAgICAgICBpbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsUm93UzIgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsUm93UzIsXG4gICAgICAgIF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIgPSBpbnN0YW5jZS5pbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IgOiBfaW5zdGFuY2UkaW5pdGlhbENlbGwyLFxuICAgICAgICByb3dTdGF0ZSA9IGluc3RhbmNlLnN0YXRlLnJvd1N0YXRlO1xuXG4gICAgaWYgKHJvdykge1xuICAgICAgcm93LnN0YXRlID0gdHlwZW9mIHJvd1N0YXRlW3Jvdy5pZF0gIT09ICd1bmRlZmluZWQnID8gcm93U3RhdGVbcm93LmlkXSA6IGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yKHJvdyk7XG5cbiAgICAgIHJvdy5zZXRTdGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVyKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zZXRSb3dTdGF0ZShyb3cuaWQsIHVwZGF0ZXIpO1xuICAgICAgfTtcblxuICAgICAgcm93LmNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKCFyb3cuc3RhdGUuY2VsbFN0YXRlKSB7XG4gICAgICAgICAgcm93LnN0YXRlLmNlbGxTdGF0ZSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2VsbC5zdGF0ZSA9IHR5cGVvZiByb3cuc3RhdGUuY2VsbFN0YXRlW2NlbGwuY29sdW1uLmlkXSAhPT0gJ3VuZGVmaW5lZCcgPyByb3cuc3RhdGUuY2VsbFN0YXRlW2NlbGwuY29sdW1uLmlkXSA6IGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcihjZWxsKTtcblxuICAgICAgICBjZWxsLnNldFN0YXRlID0gZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2V0Q2VsbFN0YXRlKHJvdy5pZCwgY2VsbC5jb2x1bW4uaWQsIHVwZGF0ZXIpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYWN0aW9ucy5yZXNldENvbHVtbk9yZGVyID0gJ3Jlc2V0Q29sdW1uT3JkZXInO1xuICBhY3Rpb25zLnNldENvbHVtbk9yZGVyID0gJ3NldENvbHVtbk9yZGVyJztcbiAgdmFyIHVzZUNvbHVtbk9yZGVyID0gZnVuY3Rpb24gdXNlQ29sdW1uT3JkZXIoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciRhKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1uc0RlcHMucHVzaChmdW5jdGlvbiAoZGVwcywgX3JlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLmNvbHVtbk9yZGVyXSk7XG4gICAgfSk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyQyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJGEpO1xuICB9O1xuICB1c2VDb2x1bW5PcmRlci5wbHVnaW5OYW1lID0gJ3VzZUNvbHVtbk9yZGVyJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJGEoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgY29sdW1uT3JkZXI6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0Q29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uT3JkZXI6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlciB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldENvbHVtbk9yZGVyKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtbk9yZGVyOiBmdW5jdGlvbmFsVXBkYXRlKGFjdGlvbi5jb2x1bW5PcmRlciwgc3RhdGUuY29sdW1uT3JkZXIpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlQ29sdW1ucyQyKGNvbHVtbnMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbk9yZGVyID0gX3JlZjIuaW5zdGFuY2Uuc3RhdGUuY29sdW1uT3JkZXI7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBvcmRlciwgcmV0dXJuIHRoZSBub3JtYWwgY29sdW1uc1xuICAgIGlmICghY29sdW1uT3JkZXIgfHwgIWNvbHVtbk9yZGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuXG4gICAgdmFyIGNvbHVtbk9yZGVyQ29weSA9IFtdLmNvbmNhdChjb2x1bW5PcmRlcik7IC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xuXG4gICAgdmFyIGNvbHVtbnNDb3B5ID0gW10uY29uY2F0KGNvbHVtbnMpOyAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1uc0luT3JkZXIgPSBbXTsgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgIHZhciBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSB0YXJnZXRDb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm91bmRJbmRleCA+IC0xKSB7XG4gICAgICAgIGNvbHVtbnNJbk9yZGVyLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIGxlZnQsIGFkZCB0aGVtIHRvIHRoZSBlbmRcblxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChjb2x1bW5zSW5PcmRlciwgY29sdW1uc0NvcHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkYShpbnN0YW5jZSkge1xuICAgIHZhciBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoO1xuICAgIGluc3RhbmNlLnNldENvbHVtbk9yZGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbk9yZGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldENvbHVtbk9yZGVyLFxuICAgICAgICBjb2x1bW5PcmRlcjogY29sdW1uT3JkZXJcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICB9XG5cbiAgZGVmYXVsdENvbHVtbi5jYW5SZXNpemUgPSB0cnVlOyAvLyBBY3Rpb25zXG5cbiAgYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nID0gJ2NvbHVtblN0YXJ0UmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtblJlc2l6aW5nID0gJ2NvbHVtblJlc2l6aW5nJztcbiAgYWN0aW9ucy5jb2x1bW5Eb25lUmVzaXppbmcgPSAnY29sdW1uRG9uZVJlc2l6aW5nJztcbiAgYWN0aW9ucy5yZXNldFJlc2l6ZSA9ICdyZXNldFJlc2l6ZSc7XG4gIHZhciB1c2VSZXNpemVDb2x1bW5zID0gZnVuY3Rpb24gdXNlUmVzaXplQ29sdW1ucyhob29rcykge1xuICAgIGhvb2tzLmdldFJlc2l6ZXJQcm9wcyA9IFtkZWZhdWx0R2V0UmVzaXplclByb3BzXTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9XG4gICAgfSk7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkYik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSRiKTtcbiAgICBob29rcy51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMucHVzaCh1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMkMSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSZXNpemVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0UmVzaXplclByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgICAgaGVhZGVyID0gX3JlZi5oZWFkZXI7XG4gICAgdmFyIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG5cbiAgICB2YXIgb25SZXNpemVTdGFydCA9IGZ1bmN0aW9uIG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKSB7XG4gICAgICB2YXIgaXNUb3VjaEV2ZW50ID0gZmFsc2U7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAvLyBsZXRzIG5vdCByZXNwb25kIHRvIG11bHRpcGxlIHRvdWNoZXMgKGUuZy4gMiBvciAzIGZpbmdlcnMpXG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpc1RvdWNoRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGVhZGVyc1RvUmVzaXplID0gZ2V0TGVhZkhlYWRlcnMoaGVhZGVyKTtcbiAgICAgIHZhciBoZWFkZXJJZFdpZHRocyA9IGhlYWRlcnNUb1Jlc2l6ZS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIFtkLmlkLCBkLnRvdGFsV2lkdGhdO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2xpZW50WCA9IGlzVG91Y2hFdmVudCA/IE1hdGgucm91bmQoZS50b3VjaGVzWzBdLmNsaWVudFgpIDogZS5jbGllbnRYO1xuICAgICAgdmFyIHJhZjtcbiAgICAgIHZhciBtb3N0UmVjZW50Q2xpZW50WDtcblxuICAgICAgdmFyIGRpc3BhdGNoRW5kID0gZnVuY3Rpb24gZGlzcGF0Y2hFbmQoKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgICByYWYgPSBudWxsO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5jb2x1bW5Eb25lUmVzaXppbmdcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlzcGF0Y2hNb3ZlID0gZnVuY3Rpb24gZGlzcGF0Y2hNb3ZlKCkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgcmFmID0gbnVsbDtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMuY29sdW1uUmVzaXppbmcsXG4gICAgICAgICAgY2xpZW50WDogbW9zdFJlY2VudENsaWVudFhcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHNjaGVkdWxlRGlzcGF0Y2hNb3ZlT25OZXh0QW5pbWF0aW9uRnJhbWUoY2xpZW50WFBvcykge1xuICAgICAgICBtb3N0UmVjZW50Q2xpZW50WCA9IGNsaWVudFhQb3M7XG5cbiAgICAgICAgaWYgKCFyYWYpIHtcbiAgICAgICAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRpc3BhdGNoTW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVyc0FuZEV2ZW50cyA9IHtcbiAgICAgICAgbW91c2U6IHtcbiAgICAgICAgICBtb3ZlRXZlbnQ6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgIG1vdmVIYW5kbGVyOiBmdW5jdGlvbiBtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShlLmNsaWVudFgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBFdmVudDogJ21vdXNldXAnLFxuICAgICAgICAgIHVwSGFuZGxlcjogZnVuY3Rpb24gdXBIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVyc0FuZEV2ZW50cy5tb3VzZS51cEhhbmRsZXIpO1xuICAgICAgICAgICAgZGlzcGF0Y2hFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoOiB7XG4gICAgICAgICAgbW92ZUV2ZW50OiAndG91Y2htb3ZlJyxcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZnVuY3Rpb24gbW92ZUhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjaGVkdWxlRGlzcGF0Y2hNb3ZlT25OZXh0QW5pbWF0aW9uRnJhbWUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBFdmVudDogJ3RvdWNoZW5kJyxcbiAgICAgICAgICB1cEhhbmRsZXI6IGZ1bmN0aW9uIHVwSGFuZGxlcihlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLm1vdmVFdmVudCwgaGFuZGxlcnNBbmRFdmVudHMudG91Y2gubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC51cEV2ZW50LCBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkaXNwYXRjaEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBldmVudHMgPSBpc1RvdWNoRXZlbnQgPyBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaCA6IGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlO1xuICAgICAgdmFyIHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSA6IGZhbHNlO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMubW92ZUV2ZW50LCBldmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy51cEV2ZW50LCBldmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcsXG4gICAgICAgIGNvbHVtbklkOiBoZWFkZXIuaWQsXG4gICAgICAgIGNvbHVtbldpZHRoOiBoZWFkZXIudG90YWxXaWR0aCxcbiAgICAgICAgaGVhZGVySWRXaWR0aHM6IGhlYWRlcklkV2lkdGhzLFxuICAgICAgICBjbGllbnRYOiBjbGllbnRYXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgcmV0dXJuIGUucGVyc2lzdCgpIHx8IG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKTtcbiAgICAgIH0sXG4gICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICAgIHJldHVybiBlLnBlcnNpc3QoKSB8fCBvblJlc2l6ZVN0YXJ0KGUsIGhlYWRlcik7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZSdcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgcm9sZTogJ3NlcGFyYXRvcidcbiAgICB9XTtcbiAgfTtcblxuICB1c2VSZXNpemVDb2x1bW5zLnBsdWdpbk5hbWUgPSAndXNlUmVzaXplQ29sdW1ucyc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciRiKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgY29sdW1uUmVzaXppbmc6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRSZXNpemUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uUmVzaXppbmc6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGFjdGlvbi5jbGllbnRYLFxuICAgICAgICAgIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGNvbHVtbldpZHRoID0gYWN0aW9uLmNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzID0gYWN0aW9uLmhlYWRlcklkV2lkdGhzO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgc3RhcnRYOiBjbGllbnRYLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzOiBoZWFkZXJJZFdpZHRocyxcbiAgICAgICAgICBjb2x1bW5XaWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uSWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5SZXNpemluZykge1xuICAgICAgdmFyIF9jbGllbnRYID0gYWN0aW9uLmNsaWVudFg7XG5cbiAgICAgIHZhciBfc3RhdGUkY29sdW1uUmVzaXppbmcgPSBzdGF0ZS5jb2x1bW5SZXNpemluZyxcbiAgICAgICAgICBzdGFydFggPSBfc3RhdGUkY29sdW1uUmVzaXppbmcuc3RhcnRYLFxuICAgICAgICAgIF9jb2x1bW5XaWR0aCA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aCxcbiAgICAgICAgICBfc3RhdGUkY29sdW1uUmVzaXppbmcyID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nLmhlYWRlcklkV2lkdGhzLFxuICAgICAgICAgIF9oZWFkZXJJZFdpZHRocyA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZzIgPT09IHZvaWQgMCA/IFtdIDogX3N0YXRlJGNvbHVtblJlc2l6aW5nMjtcblxuICAgICAgdmFyIGRlbHRhWCA9IF9jbGllbnRYIC0gc3RhcnRYO1xuICAgICAgdmFyIHBlcmNlbnRhZ2VEZWx0YVggPSBkZWx0YVggLyBfY29sdW1uV2lkdGg7XG4gICAgICB2YXIgbmV3Q29sdW1uV2lkdGhzID0ge307XG5cbiAgICAgIF9oZWFkZXJJZFdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gX3JlZjJbMV07XG4gICAgICAgIG5ld0NvbHVtbldpZHRoc1toZWFkZXJJZF0gPSBNYXRoLm1heChoZWFkZXJXaWR0aCArIGhlYWRlcldpZHRoICogcGVyY2VudGFnZURlbHRhWCwgMCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcuY29sdW1uV2lkdGhzLCB7fSwgbmV3Q29sdW1uV2lkdGhzKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgc3RhcnRYOiBudWxsLFxuICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMkMSA9IGZ1bmN0aW9uIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBkaXNhYmxlUmVzaXppbmcgPSBpbnN0YW5jZS5kaXNhYmxlUmVzaXppbmcsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIGNvbHVtblJlc2l6aW5nID0gaW5zdGFuY2Uuc3RhdGUuY29sdW1uUmVzaXppbmc7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHZhciBjYW5SZXNpemUgPSBnZXRGaXJzdERlZmluZWQoaGVhZGVyLmRpc2FibGVSZXNpemluZyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlUmVzaXppbmcgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICBoZWFkZXIuY2FuUmVzaXplID0gY2FuUmVzaXplO1xuICAgICAgaGVhZGVyLndpZHRoID0gY29sdW1uUmVzaXppbmcuY29sdW1uV2lkdGhzW2hlYWRlci5pZF0gfHwgaGVhZGVyLm9yaWdpbmFsV2lkdGggfHwgaGVhZGVyLndpZHRoO1xuICAgICAgaGVhZGVyLmlzUmVzaXppbmcgPSBjb2x1bW5SZXNpemluZy5pc1Jlc2l6aW5nQ29sdW1uID09PSBoZWFkZXIuaWQ7XG5cbiAgICAgIGlmIChjYW5SZXNpemUpIHtcbiAgICAgICAgaGVhZGVyLmdldFJlc2l6ZXJQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0UmVzaXplclByb3BzLCB7XG4gICAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgICAgaGVhZGVyOiBoZWFkZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkYihpbnN0YW5jZSkge1xuICAgIHZhciBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFJlID0gaW5zdGFuY2UuYXV0b1Jlc2V0UmVzaXplLFxuICAgICAgICBhdXRvUmVzZXRSZXNpemUgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUsXG4gICAgICAgIGNvbHVtbnMgPSBpbnN0YW5jZS5jb2x1bW5zO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlQWJzb2x1dGVMYXlvdXQnXSwgJ3VzZVJlc2l6ZUNvbHVtbnMnKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0UmVzaXplID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFJlc2l6ZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UmVzaXplKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSZXNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2NvbHVtbnNdKTtcbiAgICB2YXIgcmVzZXRSZXNpemluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSZXNpemVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHJlc2V0UmVzaXppbmc6IHJlc2V0UmVzaXppbmdcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExlYWZIZWFkZXJzKGhlYWRlcikge1xuICAgIHZhciBsZWFmSGVhZGVycyA9IFtdO1xuXG4gICAgdmFyIHJlY3Vyc2VIZWFkZXIgPSBmdW5jdGlvbiByZWN1cnNlSGVhZGVyKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5jb2x1bW5zICYmIGhlYWRlci5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBoZWFkZXIuY29sdW1ucy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICB9XG5cbiAgICAgIGxlYWZIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICB9O1xuXG4gICAgcmVjdXJzZUhlYWRlcihoZWFkZXIpO1xuICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgfVxuXG4gIHZhciBjZWxsU3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMFxuICB9O1xuICB2YXIgdXNlQWJzb2x1dGVMYXlvdXQgPSBmdW5jdGlvbiB1c2VBYnNvbHV0ZUxheW91dChob29rcykge1xuICAgIGhvb2tzLmdldFRhYmxlQm9keVByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRSb3dQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0SGVhZGVyUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWYpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY29sdW1uLnRvdGFsTGVmdCArIFwicHhcIixcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjIpIHtcbiAgICAgIHZhciBjZWxsID0gX3JlZjIuY2VsbDtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY2VsbC5jb2x1bW4udG90YWxMZWZ0ICsgXCJweFwiLFxuICAgICAgICAgIHdpZHRoOiBjZWxsLmNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgICBob29rcy5nZXRGb290ZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjMpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcywge1xuICAgICAgICAgIGxlZnQ6IGNvbHVtbi50b3RhbExlZnQgKyBcInB4XCIsXG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgfTtcbiAgdXNlQWJzb2x1dGVMYXlvdXQucGx1Z2luTmFtZSA9ICd1c2VBYnNvbHV0ZUxheW91dCc7XG5cbiAgdmFyIGdldFJvd1N0eWxlcyA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmNC5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgd2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc1dpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGNlbGxTdHlsZXMkMSA9IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICB9O1xuXG4gIHZhciBnZXRSb3dTdHlsZXMkMSA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICB3aWR0aDogaW5zdGFuY2UudG90YWxDb2x1bW5zV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgdXNlQmxvY2tMYXlvdXQgPSBmdW5jdGlvbiB1c2VCbG9ja0xheW91dChob29rcykge1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlckdyb3VwUHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMSk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQxKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjIpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmMi5jb2x1bW47XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcyQxLCB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgICBob29rcy5nZXRDZWxsUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWYzKSB7XG4gICAgICB2YXIgY2VsbCA9IF9yZWYzLmNlbGw7XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcyQxLCB7XG4gICAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmNCkge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWY0LmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICB9O1xuICB1c2VCbG9ja0xheW91dC5wbHVnaW5OYW1lID0gJ3VzZUJsb2NrTGF5b3V0JztcblxuICBmdW5jdGlvbiB1c2VGbGV4TGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VGFibGVQcm9wcy5wdXNoKGdldFRhYmxlUHJvcHMpO1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzJDIpO1xuICAgIGhvb2tzLmdldEhlYWRlckdyb3VwUHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMik7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQyKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGdldEhlYWRlclByb3BzKTtcbiAgICBob29rcy5nZXRDZWxsUHJvcHMucHVzaChnZXRDZWxsUHJvcHMpO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZ2V0Rm9vdGVyUHJvcHMpO1xuICB9XG4gIHVzZUZsZXhMYXlvdXQucGx1Z2luTmFtZSA9ICd1c2VGbGV4TGF5b3V0JztcblxuICB2YXIgZ2V0VGFibGVQcm9wcyA9IGZ1bmN0aW9uIGdldFRhYmxlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG1pbldpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNNaW5XaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRSb3dTdHlsZXMkMiA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXg6ICcxIDAgYXV0bycsXG4gICAgICAgIG1pbldpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNNaW5XaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRIZWFkZXJQcm9wcyA9IGZ1bmN0aW9uIGdldEhlYWRlclByb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNvbHVtbi50b3RhbEZsZXhXaWR0aCA/IGNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiIDogdW5kZWZpbmVkLFxuICAgICAgICBtaW5XaWR0aDogY29sdW1uLnRvdGFsTWluV2lkdGggKyBcInB4XCIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRDZWxsUHJvcHMgPSBmdW5jdGlvbiBnZXRDZWxsUHJvcHMocHJvcHMsIF9yZWY0KSB7XG4gICAgdmFyIGNlbGwgPSBfcmVmNC5jZWxsO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBmbGV4OiBjZWxsLmNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiLFxuICAgICAgICBtaW5XaWR0aDogY2VsbC5jb2x1bW4udG90YWxNaW5XaWR0aCArIFwicHhcIixcbiAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZ2V0Rm9vdGVyUHJvcHMgPSBmdW5jdGlvbiBnZXRGb290ZXJQcm9wcyhwcm9wcywgX3JlZjUpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjUuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBmbGV4OiBjb2x1bW4udG90YWxGbGV4V2lkdGggPyBjb2x1bW4udG90YWxGbGV4V2lkdGggKyBcIiAwIGF1dG9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluV2lkdGg6IGNvbHVtbi50b3RhbE1pbldpZHRoICsgXCJweFwiLFxuICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcgPSAnY29sdW1uU3RhcnRSZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uUmVzaXppbmcgPSAnY29sdW1uUmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZyA9ICdjb2x1bW5Eb25lUmVzaXppbmcnO1xuICBhY3Rpb25zLnJlc2V0UmVzaXplID0gJ3Jlc2V0UmVzaXplJztcbiAgZnVuY3Rpb24gdXNlR3JpZExheW91dChob29rcykge1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJGMpO1xuICAgIGhvb2tzLmdldFRhYmxlUHJvcHMucHVzaChnZXRUYWJsZVByb3BzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZ2V0SGVhZGVyUHJvcHMkMSk7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dQcm9wcyk7XG4gIH1cbiAgdXNlR3JpZExheW91dC5wbHVnaW5OYW1lID0gJ3VzZUdyaWRMYXlvdXQnO1xuXG4gIHZhciBnZXRUYWJsZVByb3BzJDEgPSBmdW5jdGlvbiBnZXRUYWJsZVByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICB2YXIgZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IGluc3RhbmNlLnZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHN0YXRlJGNvbHVtO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHNbY29sdW1uLmlkXSkgcmV0dXJuIGluc3RhbmNlLnN0YXRlLmdyaWRMYXlvdXQuY29sdW1uV2lkdGhzW2NvbHVtbi5pZF0gKyBcInB4XCI7IC8vIFdoZW4gcmVzaXppbmcsIGxvY2sgdGhlIHdpZHRoIG9mIGFsbCB1bnNldCBjb2x1bW5zXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHVzZXItcHJvdmlkZWQgd2lkdGggb3IgZGVmYXVsdENvbHVtbiB3aWR0aCxcbiAgICAgIC8vIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGJlICdhdXRvJyBvciAnZnInIHVuaXRzIHRoYXQgZG9uJ3Qgc2NhbGUgbGluZWFybHlcblxuICAgICAgaWYgKChfaW5zdGFuY2Ukc3RhdGUkY29sdW0gPSBpbnN0YW5jZS5zdGF0ZS5jb2x1bW5SZXNpemluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRzdGF0ZSRjb2x1bS5pc1Jlc2l6aW5nQ29sdW1uKSByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5zdGFydFdpZHRoc1tjb2x1bW4uaWRdICsgXCJweFwiO1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW4ud2lkdGggPT09ICdudW1iZXInKSByZXR1cm4gY29sdW1uLndpZHRoICsgXCJweFwiO1xuICAgICAgcmV0dXJuIGNvbHVtbi53aWR0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogZ3JpZFRlbXBsYXRlQ29sdW1ucy5qb2luKFwiIFwiKVxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRIZWFkZXJQcm9wcyQxID0gZnVuY3Rpb24gZ2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBpZDogXCJoZWFkZXItY2VsbC1cIiArIGNvbHVtbi5pZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICAvL2VuYWJsZXMgYSBzY3JvbGwgd3JhcHBlciB0byBiZSBwbGFjZWQgYXJvdW5kIHRoZSB0YWJsZSBhbmQgaGF2ZSBzdGlja3kgaGVhZGVyc1xuICAgICAgICBncmlkQ29sdW1uOiBcInNwYW4gXCIgKyBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnRcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZ2V0Um93UHJvcHMgPSBmdW5jdGlvbiBnZXRSb3dQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgcm93ID0gX3JlZjMucm93O1xuXG4gICAgaWYgKHJvdy5pc0V4cGFuZGVkKSB7XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZ3JpZENvbHVtbjogXCIxIC8gXCIgKyAocm93LmNlbGxzLmxlbmd0aCArIDEpXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBbcHJvcHMsIHt9XTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyJGMoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZ3JpZExheW91dDoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJlc2l6ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiB7fVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZykge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzID0gYWN0aW9uLmhlYWRlcklkV2lkdGhzO1xuICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbklkKTtcblxuICAgICAgaWYgKGNvbHVtbldpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbY29sdW1uLmlkXSA9IGdldEVsZW1lbnRXaWR0aChjb2x1bW4uaWQpLCBfZXh0ZW5kczIpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgbWluV2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczM7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbY29sdW1uLmlkXSA9IGNvbHVtbi5taW5XaWR0aCwgX2V4dGVuZHMzKSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIG1heFdpZHRocyA9IGluc3RhbmNlLnZpc2libGVDb2x1bW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjb2x1bW4pIHtcbiAgICAgICAgICB2YXIgX2V4dGVuZHM0O1xuXG4gICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIChfZXh0ZW5kczQgPSB7fSwgX2V4dGVuZHM0W2NvbHVtbi5pZF0gPSBjb2x1bW4ubWF4V2lkdGgsIF9leHRlbmRzNCkpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBoZWFkZXJJZEdyaWRXaWR0aHMgPSBoZWFkZXJJZFdpZHRocy5tYXAoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgdmFyIGhlYWRlcklkID0gX3JlZjRbMF07XG4gICAgICAgICAgcmV0dXJuIFtoZWFkZXJJZCwgZ2V0RWxlbWVudFdpZHRoKGhlYWRlcklkKV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZ3JpZExheW91dDogX2V4dGVuZHMoe30sIHN0YXRlLmdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgIHN0YXJ0V2lkdGhzOiBzdGFydFdpZHRocyxcbiAgICAgICAgICAgIG1pbldpZHRoczogbWluV2lkdGhzLFxuICAgICAgICAgICAgbWF4V2lkdGhzOiBtYXhXaWR0aHMsXG4gICAgICAgICAgICBoZWFkZXJJZEdyaWRXaWR0aHM6IGhlYWRlcklkR3JpZFdpZHRocyxcbiAgICAgICAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5SZXNpemluZykge1xuICAgICAgdmFyIGNsaWVudFggPSBhY3Rpb24uY2xpZW50WDtcbiAgICAgIHZhciBzdGFydFggPSBzdGF0ZS5jb2x1bW5SZXNpemluZy5zdGFydFg7XG5cbiAgICAgIHZhciBfc3RhdGUkZ3JpZExheW91dCA9IHN0YXRlLmdyaWRMYXlvdXQsXG4gICAgICAgICAgX2NvbHVtbldpZHRoID0gX3N0YXRlJGdyaWRMYXlvdXQuY29sdW1uV2lkdGgsXG4gICAgICAgICAgX21pbldpZHRocyA9IF9zdGF0ZSRncmlkTGF5b3V0Lm1pbldpZHRocyxcbiAgICAgICAgICBfbWF4V2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQubWF4V2lkdGhzLFxuICAgICAgICAgIF9zdGF0ZSRncmlkTGF5b3V0JGhlYSA9IF9zdGF0ZSRncmlkTGF5b3V0LmhlYWRlcklkR3JpZFdpZHRocyxcbiAgICAgICAgICBfaGVhZGVySWRHcmlkV2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQkaGVhID09PSB2b2lkIDAgPyBbXSA6IF9zdGF0ZSRncmlkTGF5b3V0JGhlYTtcblxuICAgICAgdmFyIGRlbHRhWCA9IGNsaWVudFggLSBzdGFydFg7XG4gICAgICB2YXIgcGVyY2VudGFnZURlbHRhWCA9IGRlbHRhWCAvIF9jb2x1bW5XaWR0aDtcbiAgICAgIHZhciBuZXdDb2x1bW5XaWR0aHMgPSB7fTtcblxuICAgICAgX2hlYWRlcklkR3JpZFdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmNVswXSxcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gX3JlZjVbMV07XG4gICAgICAgIG5ld0NvbHVtbldpZHRoc1toZWFkZXJJZF0gPSBNYXRoLm1pbihNYXRoLm1heChfbWluV2lkdGhzW2hlYWRlcklkXSwgaGVhZGVyV2lkdGggKyBoZWFkZXJXaWR0aCAqIHBlcmNlbnRhZ2VEZWx0YVgpLCBfbWF4V2lkdGhzW2hlYWRlcklkXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgIGNvbHVtbldpZHRoczogX2V4dGVuZHMoe30sIHN0YXRlLmdyaWRMYXlvdXQuY29sdW1uV2lkdGhzLCB7fSwgbmV3Q29sdW1uV2lkdGhzKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgIHN0YXJ0V2lkdGhzOiB7fSxcbiAgICAgICAgICBtaW5XaWR0aHM6IHt9LFxuICAgICAgICAgIG1heFdpZHRoczoge31cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRXaWR0aChjb2x1bW5JZCkge1xuICAgIHZhciBfZG9jdW1lbnQkZ2V0RWxlbWVudEI7XG5cbiAgICB2YXIgd2lkdGggPSAoX2RvY3VtZW50JGdldEVsZW1lbnRCID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWFkZXItY2VsbC1cIiArIGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2N1bWVudCRnZXRFbGVtZW50Qi5vZmZzZXRXaWR0aDtcblxuICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5fVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zID0gX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucztcbiAgZXhwb3J0cy5hY3Rpb25zID0gYWN0aW9ucztcbiAgZXhwb3J0cy5kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbjtcbiAgZXhwb3J0cy5kZWZhdWx0R3JvdXBCeUZuID0gZGVmYXVsdEdyb3VwQnlGbjtcbiAgZXhwb3J0cy5kZWZhdWx0T3JkZXJCeUZuID0gZGVmYXVsdE9yZGVyQnlGbjtcbiAgZXhwb3J0cy5kZWZhdWx0UmVuZGVyZXIgPSBkZWZhdWx0UmVuZGVyZXI7XG4gIGV4cG9ydHMuZW1wdHlSZW5kZXJlciA9IGVtcHR5UmVuZGVyZXI7XG4gIGV4cG9ydHMuZW5zdXJlUGx1Z2luT3JkZXIgPSBlbnN1cmVQbHVnaW5PcmRlcjtcbiAgZXhwb3J0cy5mbGV4UmVuZGVyID0gZmxleFJlbmRlcjtcbiAgZXhwb3J0cy5mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZTtcbiAgZXhwb3J0cy5sb29wSG9va3MgPSBsb29wSG9va3M7XG4gIGV4cG9ydHMubWFrZVByb3BHZXR0ZXIgPSBtYWtlUHJvcEdldHRlcjtcbiAgZXhwb3J0cy5tYWtlUmVuZGVyZXIgPSBtYWtlUmVuZGVyZXI7XG4gIGV4cG9ydHMucmVkdWNlSG9va3MgPSByZWR1Y2VIb29rcztcbiAgZXhwb3J0cy5zYWZlVXNlTGF5b3V0RWZmZWN0ID0gc2FmZVVzZUxheW91dEVmZmVjdDtcbiAgZXhwb3J0cy51c2VBYnNvbHV0ZUxheW91dCA9IHVzZUFic29sdXRlTGF5b3V0O1xuICBleHBvcnRzLnVzZUFzeW5jRGVib3VuY2UgPSB1c2VBc3luY0RlYm91bmNlO1xuICBleHBvcnRzLnVzZUJsb2NrTGF5b3V0ID0gdXNlQmxvY2tMYXlvdXQ7XG4gIGV4cG9ydHMudXNlQ29sdW1uT3JkZXIgPSB1c2VDb2x1bW5PcmRlcjtcbiAgZXhwb3J0cy51c2VFeHBhbmRlZCA9IHVzZUV4cGFuZGVkO1xuICBleHBvcnRzLnVzZUZpbHRlcnMgPSB1c2VGaWx0ZXJzO1xuICBleHBvcnRzLnVzZUZsZXhMYXlvdXQgPSB1c2VGbGV4TGF5b3V0O1xuICBleHBvcnRzLnVzZUdldExhdGVzdCA9IHVzZUdldExhdGVzdDtcbiAgZXhwb3J0cy51c2VHbG9iYWxGaWx0ZXIgPSB1c2VHbG9iYWxGaWx0ZXI7XG4gIGV4cG9ydHMudXNlR3JpZExheW91dCA9IHVzZUdyaWRMYXlvdXQ7XG4gIGV4cG9ydHMudXNlR3JvdXBCeSA9IHVzZUdyb3VwQnk7XG4gIGV4cG9ydHMudXNlTW91bnRlZExheW91dEVmZmVjdCA9IHVzZU1vdW50ZWRMYXlvdXRFZmZlY3Q7XG4gIGV4cG9ydHMudXNlUGFnaW5hdGlvbiA9IHVzZVBhZ2luYXRpb247XG4gIGV4cG9ydHMudXNlUmVzaXplQ29sdW1ucyA9IHVzZVJlc2l6ZUNvbHVtbnM7XG4gIGV4cG9ydHMudXNlUm93U2VsZWN0ID0gdXNlUm93U2VsZWN0O1xuICBleHBvcnRzLnVzZVJvd1N0YXRlID0gdXNlUm93U3RhdGU7XG4gIGV4cG9ydHMudXNlU29ydEJ5ID0gdXNlU29ydEJ5O1xuICBleHBvcnRzLnVzZVRhYmxlID0gdXNlVGFibGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXRhYmxlLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJSZWFjdFRhYmxlIiwiUmVhY3QiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJrZXkiLCJhcmciLCJpbmZvIiwidmFsdWUiLCJlcnJvciIsImRvbmUiLCJQcm9taXNlIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZm4iLCJhcmdzIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJlcnIiLCJ1bmRlZmluZWQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJsZW5ndGgiLCJzb3VyY2UiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwicmVzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3RvUHJvcGVydHlLZXkiLCJyZW5kZXJFcnIiLCJhY3Rpb25zIiwiaW5pdCIsImRlZmF1bHRSZW5kZXJlciIsIl9yZWYiLCJfcmVmJHZhbHVlIiwiZW1wdHlSZW5kZXJlciIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImRlZmF1bHRDb2x1bW4iLCJDZWxsIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1lcmdlUHJvcHMiLCJfbGVuIiwicHJvcExpc3QiLCJBcnJheSIsIl9rZXkiLCJyZWR1Y2UiLCJwcm9wcyIsIm5leHQiLCJzdHlsZSIsImNsYXNzTmFtZSIsInJlc3QiLCJoYW5kbGVQcm9wR2V0dGVyIiwicHJldlByb3BzIiwidXNlclByb3BzIiwibWV0YSIsImlzQXJyYXkiLCJjb25jYXQiLCJtYWtlUHJvcEdldHRlciIsImhvb2tzIiwicHJldiIsInJlZHVjZUhvb2tzIiwiaW5pdGlhbCIsImFsbG93VW5kZWZpbmVkIiwibmV4dFZhbHVlIiwiY29uc29sZSIsIkVycm9yIiwibG9vcEhvb2tzIiwiY29udGV4dCIsImZvckVhY2giLCJob29rIiwiZW5zdXJlUGx1Z2luT3JkZXIiLCJwbHVnaW5zIiwiYmVmb3JlcyIsInBsdWdpbk5hbWUiLCJhZnRlcnMiLCJwbHVnaW5JbmRleCIsImZpbmRJbmRleCIsInBsdWdpbiIsImJlZm9yZSIsImJlZm9yZUluZGV4IiwiZnVuY3Rpb25hbFVwZGF0ZSIsInVwZGF0ZXIiLCJvbGQiLCJ1c2VHZXRMYXRlc3QiLCJvYmoiLCJyZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwidXNlQ2FsbGJhY2siLCJzYWZlVXNlTGF5b3V0RWZmZWN0IiwiZG9jdW1lbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNb3VudGVkTGF5b3V0RWZmZWN0IiwiZGVwcyIsIm1vdW50ZWRSZWYiLCJ1c2VBc3luY0RlYm91bmNlIiwiZGVmYXVsdEZuIiwiZGVmYXVsdFdhaXQiLCJkZWJvdW5jZVJlZiIsImdldERlZmF1bHRGbiIsImdldERlZmF1bHRXYWl0IiwiX3JlZjIiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJtYXJrIiwiX2NhbGxlZTIiLCJfbGVuMiIsIl9rZXkyIiwiX2FyZ3MyIiwid3JhcCIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsInByb21pc2UiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIl9jYWxsZWUiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwidDAiLCJ0MSIsInNlbnQiLCJ0MiIsImZpbmlzaCIsInN0b3AiLCJhYnJ1cHQiLCJtYWtlUmVuZGVyZXIiLCJpbnN0YW5jZSIsImNvbHVtbiIsInR5cGUiLCJDb21wIiwiZmxleFJlbmRlciIsImlzUmVhY3RDb21wb25lbnQiLCJjb21wb25lbnQiLCJpc0NsYXNzQ29tcG9uZW50IiwiaXNFeG90aWNDb21wb25lbnQiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiJCR0eXBlb2YiLCJpbmNsdWRlcyIsImRlc2NyaXB0aW9uIiwibGlua0NvbHVtblN0cnVjdHVyZSIsImNvbHVtbnMiLCJwYXJlbnQiLCJkZXB0aCIsIm1hcCIsImFzc2lnbkNvbHVtbkFjY2Vzc29yIiwiZmxhdHRlbkNvbHVtbnMiLCJmbGF0dGVuQnkiLCJpZCIsImFjY2Vzc29yIiwiSGVhZGVyIiwiYWNjZXNzb3JQYXRoIiwic3BsaXQiLCJyb3ciLCJnZXRCeSIsImRlY29yYXRlQ29sdW1uIiwidXNlckRlZmF1bHRDb2x1bW4iLCJGb290ZXIiLCJvcmlnaW5hbFdpZHRoIiwibWFrZUhlYWRlckdyb3VwcyIsImFsbENvbHVtbnMiLCJhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyIsImhlYWRlckdyb3VwcyIsInNjYW5Db2x1bW5zIiwidWlkIiwiZ2V0VUlEIiwiX2xvb3AiLCJoZWFkZXJHcm91cCIsImhlYWRlcnMiLCJwYXJlbnRDb2x1bW5zIiwiaGFzUGFyZW50cyIsInNvbWUiLCJkIiwibGF0ZXN0UGFyZW50Q29sdW1uIiwicmV2ZXJzZSIsIm5ld1BhcmVudCIsIm9yaWdpbmFsSWQiLCJwbGFjZWhvbGRlck9mIiwicHVzaCIsInBhdGhPYmpDYWNoZSIsIk1hcCIsInBhdGgiLCJkZWYiLCJjYWNoZUtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXRoT2JqIiwiZ2V0IiwibWFrZVBhdGhBcnJheSIsInNldCIsInZhbCIsImN1cnNvciIsInBhdGhQYXJ0IiwiZSIsImdldEZpcnN0RGVmaW5lZCIsImlzRnVuY3Rpb24iLCJhIiwiYXJyIiwiZmxhdCIsInJlY3Vyc2UiLCJleHBhbmRSb3dzIiwicm93cyIsIm1hbnVhbEV4cGFuZGVkS2V5IiwiZXhwYW5kZWQiLCJfcmVmJGV4cGFuZFN1YlJvd3MiLCJleHBhbmRTdWJSb3dzIiwiZXhwYW5kZWRSb3dzIiwiaGFuZGxlUm93IiwiYWRkVG9FeHBhbmRlZFJvd3MiLCJpc0V4cGFuZGVkIiwib3JpZ2luYWwiLCJjYW5FeHBhbmQiLCJzdWJSb3dzIiwiZ2V0RmlsdGVyTWV0aG9kIiwiZmlsdGVyIiwidXNlckZpbHRlclR5cGVzIiwiZmlsdGVyVHlwZXMiLCJ0ZXh0Iiwic2hvdWxkQXV0b1JlbW92ZUZpbHRlciIsImF1dG9SZW1vdmUiLCJ1bnByZXBhcmVkQWNjZXNzV2FybmluZyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJwYXNzaXZlRXZlbnRTdXBwb3J0ZWQiLCJzdXBwb3J0ZWQiLCJvcHRpb25zIiwicGFzc2l2ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVPcGVuQnJhY2tldCIsInJlQ2xvc2VCcmFja2V0IiwiZmxhdHRlbkRlZXAiLCJyZXBsYWNlIiwiam9pbiIsIm5ld0FyciIsImRlZmF1bHRHZXRUYWJsZVByb3BzIiwicm9sZSIsImRlZmF1bHRHZXRUYWJsZUJvZHlQcm9wcyIsImRlZmF1bHRHZXRIZWFkZXJQcm9wcyIsImNvbFNwYW4iLCJ0b3RhbFZpc2libGVIZWFkZXJDb3VudCIsImRlZmF1bHRHZXRGb290ZXJQcm9wcyIsImRlZmF1bHRHZXRIZWFkZXJHcm91cFByb3BzIiwiX3JlZjMiLCJpbmRleCIsImRlZmF1bHRHZXRGb290ZXJHcm91cFByb3BzIiwiX3JlZjQiLCJkZWZhdWx0R2V0Um93UHJvcHMiLCJfcmVmNSIsImRlZmF1bHRHZXRDZWxsUHJvcHMiLCJfcmVmNiIsImNlbGwiLCJtYWtlRGVmYXVsdFBsdWdpbkhvb2tzIiwidXNlT3B0aW9ucyIsInN0YXRlUmVkdWNlcnMiLCJ1c2VDb250cm9sbGVkU3RhdGUiLCJjb2x1bW5zRGVwcyIsImFsbENvbHVtbnNEZXBzIiwiYWNjZXNzVmFsdWUiLCJtYXRlcmlhbGl6ZWRDb2x1bW5zIiwibWF0ZXJpYWxpemVkQ29sdW1uc0RlcHMiLCJ1c2VJbnN0YW5jZUFmdGVyRGF0YSIsInZpc2libGVDb2x1bW5zIiwidmlzaWJsZUNvbHVtbnNEZXBzIiwiaGVhZGVyR3JvdXBzRGVwcyIsInVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyIsInVzZUluc3RhbmNlIiwicHJlcGFyZVJvdyIsImdldFRhYmxlUHJvcHMiLCJnZXRUYWJsZUJvZHlQcm9wcyIsImdldEhlYWRlckdyb3VwUHJvcHMiLCJnZXRGb290ZXJHcm91cFByb3BzIiwiZ2V0SGVhZGVyUHJvcHMiLCJnZXRGb290ZXJQcm9wcyIsImdldFJvd1Byb3BzIiwiZ2V0Q2VsbFByb3BzIiwidXNlRmluYWxJbnN0YW5jZSIsInJlc2V0SGlkZGVuQ29sdW1ucyIsInRvZ2dsZUhpZGVDb2x1bW4iLCJzZXRIaWRkZW5Db2x1bW5zIiwidG9nZ2xlSGlkZUFsbENvbHVtbnMiLCJ1c2VDb2x1bW5WaXNpYmlsaXR5IiwiZ2V0VG9nZ2xlSGlkZGVuUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHMiLCJnZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzIiwiZGVmYXVsdEdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMiLCJyZWR1Y2VyIiwic3RhdGUiLCJoaWRkZW5Db2x1bW5zIiwib25DaGFuZ2UiLCJ0b2dnbGVIaWRkZW4iLCJjaGVja2VkIiwiaXNWaXNpYmxlIiwidGl0bGUiLCJhbGxDb2x1bW5zSGlkZGVuIiwiaW5kZXRlcm1pbmF0ZSIsImFjdGlvbiIsInByZXZpb3VzU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzaG91bGQiLCJjb2x1bW5JZCIsInNob3VsZEFsbCIsImlzTW91bnRlZFJlZiIsImhhbmRsZUNvbHVtbiIsInBhcmVudFZpc2libGUiLCJzdWJDb2x1bW4iLCJzdWJIZWFkZXIiLCJmbGF0SGVhZGVycyIsImRpc3BhdGNoIiwiZ2V0SG9va3MiLCJfaW5zdGFuY2UkYXV0b1Jlc2V0SGkiLCJhdXRvUmVzZXRIaWRkZW5Db2x1bW5zIiwiZ2V0SW5zdGFuY2UiLCJnZXRBdXRvUmVzZXRIaWRkZW5Db2x1bW5zIiwiZGVmYXVsdEluaXRpYWxTdGF0ZSIsImRlZmF1bHRDb2x1bW5JbnN0YW5jZSIsImRlZmF1bHRSZWR1Y2VyIiwicHJldlN0YXRlIiwiZGVmYXVsdEdldFN1YlJvd3MiLCJkZWZhdWx0R2V0Um93SWQiLCJkZWZhdWx0VXNlQ29udHJvbGxlZFN0YXRlIiwiYXBwbHlEZWZhdWx0cyIsIl9wcm9wcyRpbml0aWFsU3RhdGUiLCJfcHJvcHMkZGVmYXVsdENvbHVtbiIsIl9wcm9wcyRnZXRTdWJSb3dzIiwiZ2V0U3ViUm93cyIsIl9wcm9wcyRnZXRSb3dJZCIsImdldFJvd0lkIiwiX3Byb3BzJHN0YXRlUmVkdWNlciIsInN0YXRlUmVkdWNlciIsIl9wcm9wcyR1c2VDb250cm9sbGVkUyIsInVzZVRhYmxlIiwiaW5zdGFuY2VSZWYiLCJCb29sZWFuIiwiX2dldEluc3RhbmNlIiwiZGF0YSIsInVzZXJDb2x1bW5zIiwiZ2V0U3RhdGVSZWR1Y2VyIiwicyIsImhhbmRsZXIiLCJfUmVhY3QkdXNlUmVkdWNlciIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyU3RhdGUiLCJ1c2VNZW1vIiwiX1JlYWN0JHVzZU1lbW8iLCJmbGF0Um93cyIsInJvd3NCeUlkIiwiYWxsQ29sdW1uc1F1ZXVlIiwic2hpZnQiLCJhY2Nlc3NSb3dzRm9yQ29sdW1uIiwiYWNjZXNzVmFsdWVIb29rcyIsImluaXRpYWxSb3dzIiwiZmluZCIsImR1cGxpY2F0ZUNvbHVtbnMiLCJhbGwiLCJ2aXNpYmxlQ29sdW1uc0RlcCIsInNvcnQiLCJfY2FsY3VsYXRlSGVhZGVyV2lkdGgiLCJjYWxjdWxhdGVIZWFkZXJXaWR0aHMiLCJ0b3RhbENvbHVtbnNNaW5XaWR0aCIsInRvdGFsQ29sdW1uc1dpZHRoIiwidG90YWxDb2x1bW5zTWF4V2lkdGgiLCJyZW5kZXIiLCJmb290ZXJHcm91cHMiLCJhbGxDZWxscyIsInZhbHVlcyIsImNlbGxzIiwibGVmdCIsInN1bVRvdGFsTWluV2lkdGgiLCJzdW1Ub3RhbFdpZHRoIiwic3VtVG90YWxNYXhXaWR0aCIsInN1bVRvdGFsRmxleFdpZHRoIiwiaGVhZGVyIiwic3ViSGVhZGVycyIsInRvdGFsTGVmdCIsIl9jYWxjdWxhdGVIZWFkZXJXaWR0aDIiLCJ0b3RhbE1pbldpZHRoIiwidG90YWxXaWR0aCIsInRvdGFsTWF4V2lkdGgiLCJ0b3RhbEZsZXhXaWR0aCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJjYW5SZXNpemUiLCJhY2Nlc3NSb3ciLCJvcmlnaW5hbFJvdyIsInJvd0luZGV4IiwicGFyZW50Um93cyIsIm9yaWdpbmFsU3ViUm93cyIsInJlc2V0RXhwYW5kZWQiLCJ0b2dnbGVSb3dFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsInVzZUV4cGFuZGVkIiwiZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMiLCJnZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzIiwiZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMiLCJyZWR1Y2VyJDEiLCJ1c2VJbnN0YW5jZSQxIiwib25DbGljayIsImlzQWxsUm93c0V4cGFuZGVkIiwiZXhwYW5kQWxsIiwicm93SWQiLCJzZXRFeHBhbmRlZCIsImV4aXN0cyIsInNob3VsZEV4aXN0IiwiX2V4dGVuZHMyIiwiX3N0YXRlJGV4cGFuZGVkIiwiXyIsIl9pbnN0YW5jZSRtYW51YWxFeHBhbiIsIl9pbnN0YW5jZSRwYWdpbmF0ZUV4cCIsInBhZ2luYXRlRXhwYW5kZWRSb3dzIiwiX2luc3RhbmNlJGV4cGFuZFN1YlJvIiwiX2luc3RhbmNlJGF1dG9SZXNldEV4IiwiYXV0b1Jlc2V0RXhwYW5kZWQiLCJnZXRBdXRvUmVzZXRFeHBhbmRlZCIsImV4cGFuZGVkRGVwdGgiLCJmaW5kRXhwYW5kZWREZXB0aCIsInByZUV4cGFuZGVkUm93cyIsIm1heERlcHRoIiwic3BsaXRJZCIsImlkcyIsImZpbHRlclZhbHVlIiwicm93VmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImV4YWN0VGV4dCIsImV4YWN0VGV4dENhc2UiLCJpbmNsdWRlc0FsbCIsImV2ZXJ5IiwiaW5jbHVkZXNTb21lIiwiaW5jbHVkZXNWYWx1ZSIsImV4YWN0IiwiZXF1YWxzIiwiYmV0d2VlbiIsIkluZmluaXR5IiwidGVtcCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsInJlc2V0RmlsdGVycyIsInNldEZpbHRlciIsInNldEFsbEZpbHRlcnMiLCJ1c2VGaWx0ZXJzIiwicmVkdWNlciQyIiwidXNlSW5zdGFuY2UkMiIsImZpbHRlcnMiLCJmaWx0ZXJNZXRob2QiLCJwcmV2aW91c2ZpbHRlciIsIm5ld0ZpbHRlciIsIl9hbGxDb2x1bW5zIiwiX3VzZXJGaWx0ZXJUeXBlcyIsIm1hbnVhbEZpbHRlcnMiLCJfaW5zdGFuY2UkZGVmYXVsdENhbkYiLCJkZWZhdWx0Q2FuRmlsdGVyIiwiZGlzYWJsZUZpbHRlcnMiLCJfaW5zdGFuY2UkYXV0b1Jlc2V0RmkiLCJhdXRvUmVzZXRGaWx0ZXJzIiwiY29sdW1uRGVmYXVsdENhbkZpbHRlciIsImNvbHVtbkRpc2FibGVGaWx0ZXJzIiwiY2FuRmlsdGVyIiwiZm91bmQiLCJmaWx0ZXJlZEZsYXRSb3dzIiwiZmlsdGVyZWRSb3dzQnlJZCIsImZpbHRlclJvd3MiLCJmaWx0ZXJlZFJvd3MiLCJmaWx0ZXJlZFNvRmFyIiwicHJlRmlsdGVyZWRSb3dzIiwid2FybiIsIm5vbkZpbHRlcmVkQ29sdW1ucyIsImdldEF1dG9SZXNldEZpbHRlcnMiLCJwcmVGaWx0ZXJlZEZsYXRSb3dzIiwicHJlRmlsdGVyZWRSb3dzQnlJZCIsInJlc2V0R2xvYmFsRmlsdGVyIiwic2V0R2xvYmFsRmlsdGVyIiwidXNlR2xvYmFsRmlsdGVyIiwicmVkdWNlciQzIiwidXNlSW5zdGFuY2UkMyIsImdsb2JhbEZpbHRlciIsInN0YXRlV2l0aG91dEdsb2JhbEZpbHRlciIsIm1hbnVhbEdsb2JhbEZpbHRlciIsImdsb2JhbEZpbHRlclZhbHVlIiwiX2luc3RhbmNlJGF1dG9SZXNldEdsIiwiYXV0b1Jlc2V0R2xvYmFsRmlsdGVyIiwiZGlzYWJsZUdsb2JhbEZpbHRlciIsImNvbHVtbkRpc2FibGVHbG9iYWxGaWx0ZXIiLCJmaWx0ZXJhYmxlQ29sdW1ucyIsImMiLCJnbG9iYWxGaWx0ZXJlZFJvd3MiLCJnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzIiwiZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZCIsImdldEF1dG9SZXNldEdsb2JhbEZpbHRlciIsInByZUdsb2JhbEZpbHRlcmVkUm93cyIsInByZUdsb2JhbEZpbHRlcmVkRmxhdFJvd3MiLCJwcmVHbG9iYWxGaWx0ZXJlZFJvd3NCeUlkIiwic3VtIiwiYWdncmVnYXRlZFZhbHVlcyIsIm1pbk1heCIsImF2ZXJhZ2UiLCJtZWRpYW4iLCJtaWQiLCJmbG9vciIsIm51bXMiLCJiIiwidW5pcXVlIiwiZnJvbSIsIlNldCIsInVuaXF1ZUNvdW50Iiwic2l6ZSIsImNvdW50IiwiYWdncmVnYXRpb25zIiwiZW1wdHlBcnJheSIsImVtcHR5T2JqZWN0IiwicmVzZXRHcm91cEJ5Iiwic2V0R3JvdXBCeSIsInRvZ2dsZUdyb3VwQnkiLCJ1c2VHcm91cEJ5IiwiZ2V0R3JvdXBCeVRvZ2dsZVByb3BzIiwiZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wcyIsInJlZHVjZXIkNCIsImdyb3VwQnkiLCJ1c2VJbnN0YW5jZSQ0IiwicHJlcGFyZVJvdyQxIiwiY2FuR3JvdXBCeSIsInBlcnNpc3QiLCJyZXNvbHZlZEdyb3VwQnkiLCJncm91cEJ5Q29sdW1ucyIsImciLCJjb2wiLCJub25Hcm91cEJ5Q29sdW1ucyIsImlzR3JvdXBlZCIsImdyb3VwZWRJbmRleCIsImRlZmF1bHRVc2VyQWdncmVnYXRpb25zIiwiX2luc3RhbmNlJGdyb3VwQnlGbiIsImdyb3VwQnlGbiIsImRlZmF1bHRHcm91cEJ5Rm4iLCJtYW51YWxHcm91cEJ5IiwiX2luc3RhbmNlJGFnZ3JlZ2F0aW9uIiwidXNlckFnZ3JlZ2F0aW9ucyIsIl9pbnN0YW5jZSRhdXRvUmVzZXRHciIsImF1dG9SZXNldEdyb3VwQnkiLCJkaXNhYmxlR3JvdXBCeSIsImRlZmF1bHRDYW5Hcm91cEJ5IiwiZGVmYXVsdENvbHVtbkdyb3VwQnkiLCJkZWZhdWx0R3JvdXBCeSIsImNvbHVtbkRpc2FibGVHcm91cEJ5IiwiQWdncmVnYXRlZCIsImV4aXN0aW5nR3JvdXBCeSIsImFnZ3JlZ2F0ZVJvd3NUb1ZhbHVlcyIsImxlYWZSb3dzIiwiZ3JvdXBlZFJvd3MiLCJhZ2dyZWdhdGVGbiIsImFnZ3JlZ2F0ZSIsImdyb3VwZWRWYWx1ZXMiLCJsZWFmVmFsdWVzIiwiY29sdW1uVmFsdWUiLCJhZ2dyZWdhdGVWYWx1ZSIsImFnZ3JlZ2F0ZVZhbHVlRm4iLCJncm91cGVkRmxhdFJvd3MiLCJncm91cGVkUm93c0J5SWQiLCJvbmx5R3JvdXBlZEZsYXRSb3dzIiwib25seUdyb3VwZWRSb3dzQnlJZCIsIm5vbkdyb3VwZWRGbGF0Um93cyIsIm5vbkdyb3VwZWRSb3dzQnlJZCIsImdyb3VwVXBSZWN1cnNpdmVseSIsInBhcmVudElkIiwicm93R3JvdXBzTWFwIiwiYWdncmVnYXRlZEdyb3VwZWRSb3dzIiwiZW50cmllcyIsImdyb3VwQnlWYWwiLCJncm91cEJ5SUQiLCJzdWJSb3ciLCJnZXRBdXRvUmVzZXRHcm91cEJ5IiwicHJlR3JvdXBlZFJvd3MiLCJwcmVHcm91cGVkRmxhdFJvdyIsInByZUdyb3VwZWRSb3dzQnlJZCIsIl9yb3ckc3ViUm93cyIsImlzUGxhY2Vob2xkZXIiLCJpc0FnZ3JlZ2F0ZWQiLCJyZXNLZXkiLCJyZVNwbGl0QWxwaGFOdW1lcmljIiwiYWxwaGFudW1lcmljIiwicm93QSIsInJvd0IiLCJfZ2V0Um93VmFsdWVzQnlDb2x1bW4iLCJnZXRSb3dWYWx1ZXNCeUNvbHVtbklEIiwidG9TdHJpbmciLCJhYSIsImJiIiwiYW4iLCJwYXJzZUludCIsImJuIiwiY29tYm8iLCJpc05hTiIsImRhdGV0aW1lIiwiX2dldFJvd1ZhbHVlc0J5Q29sdW1uMiIsImdldFRpbWUiLCJjb21wYXJlQmFzaWMiLCJiYXNpYyIsIl9nZXRSb3dWYWx1ZXNCeUNvbHVtbjMiLCJzdHJpbmciLCJfZ2V0Um93VmFsdWVzQnlDb2x1bW40IiwiYWxvd2VyIiwiYmxvd2VyIiwibnVtYmVyIiwiX2dldFJvd1ZhbHVlc0J5Q29sdW1uNSIsInJlcGxhY2VOb25OdW1lcmljIiwicm93MSIsInJvdzIiLCJzb3J0VHlwZXMiLCJyZXNldFNvcnRCeSIsInNldFNvcnRCeSIsInRvZ2dsZVNvcnRCeSIsImNsZWFyU29ydEJ5Iiwic29ydFR5cGUiLCJzb3J0RGVzY0ZpcnN0IiwidXNlU29ydEJ5IiwiZ2V0U29ydEJ5VG9nZ2xlUHJvcHMiLCJkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHMiLCJyZWR1Y2VyJDUiLCJ1c2VJbnN0YW5jZSQ1IiwiX2luc3RhbmNlJGlzTXVsdGlTb3J0IiwiaXNNdWx0aVNvcnRFdmVudCIsInNoaWZ0S2V5IiwiY2FuU29ydCIsImRpc2FibGVNdWx0aVNvcnQiLCJzb3J0QnkiLCJuZXdTb3J0QnkiLCJfc29ydEJ5IiwiZGVzYyIsIm11bHRpIiwiZGlzYWJsZVNvcnRSZW1vdmUiLCJkaXNhYmxlTXVsdGlSZW1vdmUiLCJfaW5zdGFuY2UkbWF4TXVsdGlTb3IiLCJtYXhNdWx0aVNvcnRDb2xDb3VudCIsIl9zb3J0QnkyIiwiZXhpc3RpbmdTb3J0QnkiLCJleGlzdGluZ0luZGV4IiwiaGFzRGVzY0RlZmluZWQiLCJfbmV3U29ydEJ5Iiwic29ydEFjdGlvbiIsInNwbGljZSIsIl9pbnN0YW5jZSRvcmRlckJ5Rm4iLCJvcmRlckJ5Rm4iLCJkZWZhdWx0T3JkZXJCeUZuIiwidXNlclNvcnRUeXBlcyIsIm1hbnVhbFNvcnRCeSIsImRlZmF1bHRDYW5Tb3J0IiwiZGlzYWJsZVNvcnRCeSIsIl9pbnN0YW5jZSRhdXRvUmVzZXRTbyIsImF1dG9SZXNldFNvcnRCeSIsImRlZmF1bHRDb2x1bW5DYW5Tb3J0IiwiY29sdW1uRGlzYWJsZVNvcnRCeSIsImNvbHVtblNvcnQiLCJpc1NvcnRlZCIsInNvcnRlZEluZGV4IiwiaXNTb3J0ZWREZXNjIiwic29ydGVkRmxhdFJvd3MiLCJhdmFpbGFibGVTb3J0QnkiLCJzb3J0RGF0YSIsInNvcnRlZERhdGEiLCJzb3J0TWV0aG9kIiwic29ydEludmVydGVkIiwic29ydGVkUm93cyIsImdldEF1dG9SZXNldFNvcnRCeSIsInByZVNvcnRlZFJvd3MiLCJwcmVTb3J0ZWRGbGF0Um93cyIsImZ1bmNzIiwiZGlycyIsInNvcnRGbiIsInNvcnRJbnQiLCJyZXNldFBhZ2UiLCJnb3RvUGFnZSIsInNldFBhZ2VTaXplIiwidXNlUGFnaW5hdGlvbiIsInJlZHVjZXIkNiIsInVzZUluc3RhbmNlJDYiLCJwYWdlU2l6ZSIsInBhZ2VJbmRleCIsInBhZ2VDb3VudCIsInBhZ2UiLCJuZXdQYWdlSW5kZXgiLCJjYW5OYXZpZ2F0ZSIsInRvcFJvd0luZGV4IiwiX2luc3RhbmNlJGF1dG9SZXNldFBhIiwiYXV0b1Jlc2V0UGFnZSIsInVzZXJQYWdlQ291bnQiLCJfaW5zdGFuY2Ukc3RhdGUiLCJtYW51YWxQYWdpbmF0aW9uIiwiZ2V0QXV0b1Jlc2V0UGFnZSIsImNlaWwiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJwYWdlU3RhcnQiLCJwYWdlRW5kIiwic2xpY2UiLCJjYW5QcmV2aW91c1BhZ2UiLCJjYW5OZXh0UGFnZSIsInByZXZpb3VzUGFnZSIsIm5leHRQYWdlIiwicmVzZXRQaXZvdCIsInRvZ2dsZVBpdm90IiwiX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucyIsImdldFBpdm90VG9nZ2xlUHJvcHMiLCJkZWZhdWx0R2V0UGl2b3RUb2dnbGVQcm9wcyIsInJlZHVjZXIkNyIsInZpc2libGVDb2x1bW5zJDEiLCJ1c2VJbnN0YW5jZSQ3IiwicHJlcGFyZVJvdyQyIiwiZGVmYXVsdFBpdm90Q29sdW1ucyIsImNhblBpdm90IiwicGl2b3RDb2x1bW5zIiwic2V0UGl2b3QiLCJyZXNvbHZlZFBpdm90IiwiaXNQaXZvdFNvdXJjZSIsInVuaXF1ZVZhbHVlcyIsImFkZCIsIm1hdGVyaWFsaXplZCIsInNvdXJjZUNvbHVtbnMiLCJidWlsZFBpdm90Q29sdW1ucyIsInBpdm90RmlsdGVycyIsInBpdm90Q29sdW1uIiwic291cmNlQ29sdW1uIiwiaXNQaXZvdGVkIiwidW5pcXVlVmFsdWUiLCJjb2x1bW5Hcm91cCIsIlBpdm90SGVhZGVyIiwiaXNQaXZvdEdyb3VwIiwicGl2b3RWYWx1ZSIsIm5ld01hdGVyaWFsaXplZCIsIl9yZWY1JGluc3RhbmNlJHN0YXRlIiwiX3JlZjciLCJfaW5zdGFuY2UkYXV0b1Jlc2V0UGkiLCJhdXRvUmVzZXRQaXZvdCIsIm1hbmF1bFBpdm90IiwiZGlzYWJsZVBpdm90IiwiZGVmYXVsdENhblBpdm90IiwiZGVmYXVsdENvbHVtblBpdm90IiwiZGVmYXVsdFBpdm90IiwiY29sdW1uRGlzYWJsZVBpdm90IiwiZ2V0QXV0b1Jlc2V0UGl2b3QiLCJwbHVnaW5OYW1lJDEiLCJyZXNldFNlbGVjdGVkUm93cyIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsInRvZ2dsZVJvd1NlbGVjdGVkIiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInVzZVJvd1NlbGVjdCIsImdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzIiwiZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzIiwiZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzIiwiZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyIsInJlZHVjZXIkOCIsInVzZUluc3RhbmNlJDgiLCJwcmVwYXJlUm93JDMiLCJfaW5zdGFuY2UkbWFudWFsUm93U2UiLCJtYW51YWxSb3dTZWxlY3RlZEtleSIsImlzU2VsZWN0ZWQiLCJpc1NvbWVTZWxlY3RlZCIsImlzQWxsUm93c1NlbGVjdGVkIiwic2VsZWN0ZWRSb3dJZHMiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJzZXRTZWxlY3RlZCIsIl9pbnN0YW5jZSRub25Hcm91cGVkUiIsInNlbGVjdEFsbCIsIl9zZXRTZWxlY3RlZCIsIl9yb3dzQnlJZCIsIl9pbnN0YW5jZSRzZWxlY3RTdWJSbyIsInNlbGVjdFN1YlJvd3MiLCJuZXdTZWxlY3RlZFJvd0lkcyIsImhhbmRsZVJvd0J5SWQiLCJfc2V0U2VsZWN0ZWQyIiwiX3Jvd3NCeUlkMiIsIl9pbnN0YW5jZSRzZWxlY3RTdWJSbzIiLCJfc2VsZWN0U3ViUm93cyIsIl9nZXRTdWJSb3dzIiwiX3NlbGVjdEFsbCIsIl9uZXdTZWxlY3RlZFJvd0lkcyIsIl9oYW5kbGVSb3dCeUlkIiwiX2luc3RhbmNlJG5vbkdyb3VwZWRSMiIsIl9pbnN0YW5jZSRhdXRvUmVzZXRTZSIsImF1dG9SZXNldFNlbGVjdGVkUm93cyIsIl9pbnN0YW5jZSRzZWxlY3RTdWJSbzMiLCJzZWxlY3RlZEZsYXRSb3dzIiwiZ2V0Um93SXNTZWxlY3RlZCIsImdldEF1dG9SZXNldFNlbGVjdGVkUm93cyIsImFsbENoaWxkcmVuU2VsZWN0ZWQiLCJzb21lU2VsZWN0ZWQiLCJkZWZhdWx0SW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IiLCJkZWZhdWx0SW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yIiwic2V0Um93U3RhdGUiLCJzZXRDZWxsU3RhdGUiLCJyZXNldFJvd1N0YXRlIiwidXNlUm93U3RhdGUiLCJyZWR1Y2VyJDkiLCJ1c2VJbnN0YW5jZSQ5IiwicHJlcGFyZVJvdyQ0IiwiX2luc3RhbmNlJGluaXRpYWxSb3dTIiwiaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IiLCJfaW5zdGFuY2UkaW5pdGlhbENlbGwiLCJpbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IiLCJyb3dTdGF0ZSIsIm9sZFJvd1N0YXRlIiwiX29sZFJvd1N0YXRlJGNlbGxTdGF0IiwiX3Jvd3NCeUlkJF9yb3dJZCIsIl9yb3dzQnlJZCRfcm93SWQkY2VsbCIsIl9leHRlbmRzMyIsIl9leHRlbmRzNCIsIl9yb3dJZCIsIl92YWx1ZSIsIl9vbGRSb3dTdGF0ZSIsIm9sZENlbGxTdGF0ZSIsImNlbGxTdGF0ZSIsIl9pbnN0YW5jZSRhdXRvUmVzZXRSbyIsImF1dG9SZXNldFJvd1N0YXRlIiwiZ2V0QXV0b1Jlc2V0Um93U3RhdGUiLCJfaW5zdGFuY2UkaW5pdGlhbFJvd1MyIiwiX2luc3RhbmNlJGluaXRpYWxDZWxsMiIsInNldFN0YXRlIiwicmVzZXRDb2x1bW5PcmRlciIsInNldENvbHVtbk9yZGVyIiwidXNlQ29sdW1uT3JkZXIiLCJyZWR1Y2VyJGEiLCJjb2x1bW5PcmRlciIsInZpc2libGVDb2x1bW5zJDIiLCJ1c2VJbnN0YW5jZSRhIiwiY29sdW1uT3JkZXJDb3B5IiwiY29sdW1uc0NvcHkiLCJjb2x1bW5zSW5PcmRlciIsInRhcmdldENvbHVtbklkIiwiZm91bmRJbmRleCIsImNvbHVtblN0YXJ0UmVzaXppbmciLCJjb2x1bW5SZXNpemluZyIsImNvbHVtbkRvbmVSZXNpemluZyIsInJlc2V0UmVzaXplIiwidXNlUmVzaXplQ29sdW1ucyIsImdldFJlc2l6ZXJQcm9wcyIsImRlZmF1bHRHZXRSZXNpemVyUHJvcHMiLCJwb3NpdGlvbiIsInJlZHVjZXIkYiIsInVzZUluc3RhbmNlJGIiLCJ1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMkMSIsIm9uUmVzaXplU3RhcnQiLCJpc1RvdWNoRXZlbnQiLCJ0b3VjaGVzIiwiaGVhZGVyc1RvUmVzaXplIiwiZ2V0TGVhZkhlYWRlcnMiLCJoZWFkZXJJZFdpZHRocyIsImNsaWVudFgiLCJyb3VuZCIsInJhZiIsIm1vc3RSZWNlbnRDbGllbnRYIiwiZGlzcGF0Y2hFbmQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRpc3BhdGNoTW92ZSIsInNjaGVkdWxlRGlzcGF0Y2hNb3ZlT25OZXh0QW5pbWF0aW9uRnJhbWUiLCJjbGllbnRYUG9zIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlcnNBbmRFdmVudHMiLCJtb3VzZSIsIm1vdmVFdmVudCIsIm1vdmVIYW5kbGVyIiwidXBFdmVudCIsInVwSGFuZGxlciIsInRvdWNoIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiZXZlbnRzIiwicGFzc2l2ZUlmU3VwcG9ydGVkIiwiY29sdW1uV2lkdGgiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hTdGFydCIsImRyYWdnYWJsZSIsImNvbHVtbldpZHRocyIsInN0YXJ0WCIsImlzUmVzaXppbmdDb2x1bW4iLCJfY2xpZW50WCIsIl9zdGF0ZSRjb2x1bW5SZXNpemluZyIsIl9jb2x1bW5XaWR0aCIsIl9zdGF0ZSRjb2x1bW5SZXNpemluZzIiLCJfaGVhZGVySWRXaWR0aHMiLCJkZWx0YVgiLCJwZXJjZW50YWdlRGVsdGFYIiwibmV3Q29sdW1uV2lkdGhzIiwiaGVhZGVySWQiLCJoZWFkZXJXaWR0aCIsImRpc2FibGVSZXNpemluZyIsImlzUmVzaXppbmciLCJfaW5zdGFuY2UkYXV0b1Jlc2V0UmUiLCJhdXRvUmVzZXRSZXNpemUiLCJnZXRBdXRvUmVzZXRSZXNpemUiLCJyZXNldFJlc2l6aW5nIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiY2VsbFN0eWxlcyIsInRvcCIsInVzZUFic29sdXRlTGF5b3V0IiwiZ2V0Um93U3R5bGVzIiwiY2VsbFN0eWxlcyQxIiwiZGlzcGxheSIsImJveFNpemluZyIsImdldFJvd1N0eWxlcyQxIiwidXNlQmxvY2tMYXlvdXQiLCJ1c2VGbGV4TGF5b3V0IiwiZ2V0Um93U3R5bGVzJDIiLCJmbGV4IiwidXNlR3JpZExheW91dCIsInJlZHVjZXIkYyIsImdldFRhYmxlUHJvcHMkMSIsImdldEhlYWRlclByb3BzJDEiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiX2luc3RhbmNlJHN0YXRlJGNvbHVtIiwiZ3JpZExheW91dCIsInN0YXJ0V2lkdGhzIiwiZ3JpZENvbHVtbiIsImdldEVsZW1lbnRXaWR0aCIsImFjYyIsIm1pbldpZHRocyIsIm1heFdpZHRocyIsImhlYWRlcklkR3JpZFdpZHRocyIsIl9zdGF0ZSRncmlkTGF5b3V0IiwiX21pbldpZHRocyIsIl9tYXhXaWR0aHMiLCJfc3RhdGUkZ3JpZExheW91dCRoZWEiLCJfaGVhZGVySWRHcmlkV2lkdGhzIiwiX2RvY3VtZW50JGdldEVsZW1lbnRCIiwiZ2V0RWxlbWVudEJ5SWQiLCJvZmZzZXRXaWR0aCIsImRlZmluZVByb3BlcnR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/dist/react-table.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-table/index.js":
/*!*******************************************!*\
  !*** ./node_modules/react-table/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./dist/react-table.development.js */ \"(ssr)/./node_modules/react-table/dist/react-table.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxpSkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0X2FwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJsZS9pbmRleC5qcz8zOTA3Il0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JlYWN0LXRhYmxlLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JlYWN0LXRhYmxlLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/index.js\n");

/***/ })

};
;